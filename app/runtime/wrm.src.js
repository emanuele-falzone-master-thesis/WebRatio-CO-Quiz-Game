(function(GLOBAL,undefined,define){if(GLOBAL["wrm"]){return};(function(n){function t(n){var f,i,e,u=this;if(!(u instanceof t))return new t(n);if(n instanceof t){u.s=n.s;u.e=n.e;u.c=n.c.slice();return}for(n===0&&1/n<0?n="-0":l.test(n+="")||r(NaN),u.s=n.charAt(0)=="-"?(n=n.slice(1),-1):1,(f=n.indexOf("."))>-1&&(n=n.replace(".","")),(i=n.search(/e/i))>0?(f<0&&(f=i),f+=+n.slice(i+1),n=n.substring(0,i)):f<0&&(f=n.length),i=0;n.charAt(i)=="0";i++);if(i==(e=n.length))u.c=[u.e=0];else{for(;n.charAt(--e)=="0";);for(u.e=f-i-1,u.c=[],f=0;i<=e;u.c[f++]=+n.charAt(i++));
}}function o(n,t,i,u){var e=n.c,f=n.e+t+1;if(i===1?u=e[f]>=5:i===2?u=e[f]>5||e[f]==5&&(u||f<0||e[f+1]!=null||e[f-1]&1):i===3?u=u||e[f]!=null||f<0:(u=!1,i!==0)&&r("!Big.RM!"),f<1||!e[0])n.c=u?(n.e=-t,[1]):[n.e=0];else{if(e.length=f--,u)for(;++e[f]>9;)e[f]=0,f--||(++n.e,e.unshift(1));for(f=e.length;!e[--f];e.pop());}return n}function r(n){var t=new Error(n);t.name="BigError";throw t;}function h(n,i,r){var u=i-(n=new t(n)).e,e=n.c;for(e.length>++i&&o(n,u,t.RM),u=e[0]?r?i:(e=n.c,n.e+u+1):u+1;e.length<
u;e.push(0));return u=n.e,r==1||r==2&&(i<=u||u<=f)?(n.s<0&&e[0]?"-":"")+(e.length>1?(e.splice(1,0,"."),e.join("")):e[0])+(u<0?"e":"e+")+u:n.toString()}t.DP=20;t.RM=1;var u=1E6,c=1E6,f=-7,e=21,i=t.prototype,l=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,s=new t(1);i.abs=function(){var n=new t(this);return n.s=1,n};i.cmp=function(n){var o,h=this,f=h.c,e=(n=new t(n)).c,i=h.s,s=n.s,r=h.e,u=n.e;if(!f[0]||!e[0])return f[0]?i:e[0]?-s:0;if(i!=s)return i;if(o=i<0,r!=u)return r>u^o?1:-1;for(i=-1,s=(r=f.length)<(u=
e.length)?r:u;++i<s;)if(f[i]!=e[i])return f[i]>e[i]^o?1:-1;return r==u?0:r>u^o?1:-1};i.div=function(n){var b=this,l=b.c,h=(n=new t(n)).c,p=b.s==n.s?1:-1,a=t.DP;if((a!==~~a||a<0||a>u)&&r("!Big.DP!"),!l[0]||!h[0])return l[0]==h[0]&&r(NaN),h[0]||r(p/0),new t(p*0);var c,k,w,v,e,it=h.slice(),d=c=h.length,rt=l.length,i=l.slice(0,c),f=i.length,y=new t(s),g=y.c=[],nt=0,tt=a+(y.e=b.e-n.e)+1;for(y.s=p,p=tt<0?0:tt,it.unshift(0);f++<c;i.push(0));do{for(w=0;w<10;w++){if(c!=(f=i.length))v=c>f?1:-1;else for(e=-1,
v=0;++e<c;)if(h[e]!=i[e]){v=h[e]>i[e]?1:-1;break}if(v<0){for(k=f==c?h:it;f;){if(i[--f]<k[f]){for(e=f;e&&!i[--e];i[e]=9);--i[e];i[f]+=10}i[f]-=k[f]}for(;!i[0];i.shift());}else break}g[nt++]=v?w:++w;i[0]&&v?i[f]=l[d]||0:i=[l[d]]}while((d++<rt||i[0]!=null)&&p--);return g[0]||nt==1||(g.shift(),y.e--),nt>tt&&o(y,a,t.RM,i[0]!=null),y};i.eq=function(n){return!this.cmp(n)};i.gt=function(n){return this.cmp(n)>0};i.gte=function(n){return this.cmp(n)>-1};i.lt=function(n){return this.cmp(n)<0};i.lte=function(n){return this.cmp(n)<
1};i.minus=function(n){var e,o,s,l,h=this,f=h.s,r=(n=new t(n)).s;if(f!=r)return n.s=-r,h.plus(n);var i=h.c.slice(),a=h.e,u=n.c,c=n.e;if(!i[0]||!u[0])return u[0]?(n.s=-r,n):new t(i[0]?h:0);if(f=a-c){for(e=(l=f<0)?(f=-f,i):(c=a,u),e.reverse(),r=f;r--;e.push(0));e.reverse()}else for(s=((l=i.length<u.length)?i:u).length,f=r=0;r<s;r++)if(i[r]!=u[r]){l=i[r]<u[r];break}if(l&&(e=i,i=u,u=e,n.s=-n.s),(r=-((s=i.length)-u.length))>0)for(;r--;i[s++]=0);for(r=u.length;r>f;){if(i[--r]<u[r]){for(o=r;o&&!i[--o];i[o]=
9);--i[o];i[r]+=10}i[r]-=u[r]}for(;i[--s]==0;i.pop());for(;i[0]==0;i.shift(),--c);return i[0]||(n.s=1,i=[c=0]),n.c=i,n.e=c,n};i.mod=function(n){n=new t(n);var e,i=this,u=i.s,f=n.s;return n.c[0]||r(NaN),i.s=n.s=1,e=n.cmp(i)==1,i.s=u,n.s=f,e?new t(i):(u=t.DP,f=t.RM,t.DP=t.RM=0,i=i.div(n),t.DP=u,t.RM=f,this.minus(i.times(n)))};i.plus=function(n){var e,o=this,r=o.s,f=(n=new t(n)).s;if(r!=f)return n.s=-f,o.minus(n);var h=o.e,i=o.c,s=n.e,u=n.c;if(!i[0]||!u[0])return u[0]?n:new t(i[0]?o:r*0);if(i=i.slice(),
r=h-s){for(e=r>0?(s=h,u):(r=-r,i),e.reverse();r--;e.push(0));e.reverse()}for(i.length-u.length<0&&(e=u,u=i,i=e),r=u.length,f=0;r;f=(i[--r]=i[r]+u[r]+f)/10^0,i[r]%=10);for(f&&(i.unshift(f),++s),r=i.length;i[--r]==0;i.pop());return n.c=i,n.e=s,n};i.pow=function(n){var f=n<0,i=new t(this),u=s;for((n!==~~n||n<-c||n>c)&&r("!pow!"),n=f?-n:n;;){if(n&1&&(u=u.times(i)),n>>=1,!n)break;i=i.times(i)}return f?s.div(u):u};i.round=function(n,i){var f=new t(this);return n==null?n=0:(n!==~~n||n<0||n>u)&&r("!round!"),
o(f,n,i==null?t.RM:i),f};i.sqrt=function(){var f,n,e,u=this,h=u.c,i=u.s,s=u.e,c=new t("0.5");if(!h[0])return new t(u);i<0&&r(NaN);i=Math.sqrt(u.toString());i==0||i==1/0?(f=h.join(""),f.length+s&1||(f+="0"),n=new t(Math.sqrt(f).toString()),n.e=((s+1)/2|0)-(s<0||s&1)):n=new t(i.toString());i=n.e+(t.DP+=4);do e=n,n=c.times(e.plus(u.div(e)));while(e.c.slice(0,i).join("")!==n.c.slice(0,i).join(""));return o(n,t.DP-=4,t.RM),n};i.times=function(n){var i,h=this,e=h.c,o=(n=new t(n)).c,s=e.length,r=o.length,
f=h.e,u=n.e;if(n.s=h.s==n.s?1:-1,!e[0]||!o[0])return new t(n.s*0);for(n.e=f+u,s<r&&(i=e,e=o,o=i,u=s,s=r,r=u),u=s+r,i=[];u--;i.push(0));for(f=r-1;f>-1;f--){for(r=0,u=s+f;u>f;r=i[u]+o[f]*e[u-f-1]+r,i[u--]=r%10|0,r=r/10|0);r&&(i[u]=(i[u]+r)%10)}for(r&&++n.e,i[0]||i.shift(),u=i.length;!i[--u];i.pop());return n.c=i,n};i.toString=i.valueOf=i.toJSON=function(){var r=this,t=r.e,n=r.c.join(""),i=n.length;if(t<=f||t>=e)n=n.charAt(0)+(i>1?"."+n.slice(1):"")+(t<0?"e":"e+")+t;else if(t<0){for(;++t;n="0"+n);n=
"0."+n}else if(t>0)if(++t>i)for(t-=i;t--;n+="0");else t<i&&(n=n.slice(0,t)+"."+n.slice(t));else i>1&&(n=n.charAt(0)+"."+n.slice(1));return r.s<0&&r.c[0]?"-"+n:n};i.toExponential=function(n){return n==null?n=this.c.length-1:(n!==~~n||n<0||n>u)&&r("!toExp!"),h(this,n,1)};i.toFixed=function(n){var t,i=this,o=f,s=e;return f=-(e=1/0),n==null?t=i.toString():n===~~n&&n>=0&&n<=u&&(t=h(i,i.e+n),i.s<0&&i.c[0]&&t.indexOf("-")<0&&(t="-"+t)),f=o,e=s,t||r("!toFix!"),t};i.toPrecision=function(n){return n==null?
this.toString():((n!==~~n||n<1||n>u)&&r("!toPre!"),h(this,n-1,2))};typeof module!="undefined"&&module.exports?module.exports=t:typeof define=="function"&&define.amd?define(function(){return t}):n.Big=t})(this);/*
 jahashtable, a JavaScript implementation of a hash table. It creates a single constructor function called
 Hashtable in the global scope.

 http://www.timdown.co.uk/jshashtable/
 Copyright 2013 Tim Down.
 Version: 3.0
 Build date: 17 July 2013

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
var Hashtable=function(t){function n(t){return typeof t==p?t:""+t}function e(t){var r;return typeof t==p?t:typeof t.hashCode==y?(r=t.hashCode(),typeof r==p?r:e(r)):n(t)}function r(t,n){for(var e in n)n.hasOwnProperty(e)&&(t[e]=n[e])}function i(t,n){return t.equals(n)}function u(t,n){return typeof n.equals==y?n.equals(t):t===n}function o(n){return function(e){if(null===e)throw new Error("null is not a valid "+n);if(e===t)throw new Error(n+" must not be undefined");}}function s(t,n,e,r){this[0]=t,this.entries=
[],this.addEntry(n,e),null!==r&&(this.getEqualityFunction=function(){return r})}function a(t){return function(n){for(var e,r=this.entries.length,i=this.getEqualityFunction(n);r--;)if(e=this.entries[r],i(n,e[0]))switch(t){case E:return!0;case K:return e;case q:return[r,e[1]]}return!1}}function l(t){return function(n){for(var e=n.length,r=0,i=this.entries,u=i.length;u>r;++r)n[e+r]=i[r][t]}}function f(t,n){for(var e,r=t.length;r--;)if(e=t[r],n===e[0])return r;return null}function h(t,n){var e=t[n];return e&&
e instanceof s?e:null}function c(){var n=[],i={},u={replaceDuplicateKey:!0,hashCode:e,equals:null},o=arguments[0],a=arguments[1];a!==t?(u.hashCode=o,u.equals=a):o!==t&&r(u,o);var l=u.hashCode,c=u.equals;this.properties=u,this.put=function(t,e){g(t),d(e);var r,o,a=l(t),f=null;return r=h(i,a),r?(o=r.getEntryForKey(t),o?(u.replaceDuplicateKey&&(o[0]=t),f=o[1],o[1]=e):r.addEntry(t,e)):(r=new s(a,t,e,c),n.push(r),i[a]=r),f},this.get=function(t){g(t);var n=l(t),e=h(i,n);if(e){var r=e.getEntryForKey(t);
if(r)return r[1]}return null},this.containsKey=function(t){g(t);var n=l(t),e=h(i,n);return e?e.containsKey(t):!1},this.containsValue=function(t){d(t);for(var e=n.length;e--;)if(n[e].containsValue(t))return!0;return!1},this.clear=function(){n.length=0,i={}},this.isEmpty=function(){return!n.length};var y=function(t){return function(){for(var e=[],r=n.length;r--;)n[r][t](e);return e}};this.keys=y("keys"),this.values=y("values"),this.entries=y("getEntries"),this.remove=function(t){g(t);var e,r=l(t),u=
null,o=h(i,r);return o&&(u=o.removeEntryForKey(t),null!==u&&0==o.entries.length&&(e=f(n,r),n.splice(e,1),delete i[r])),u},this.size=function(){for(var t=0,e=n.length;e--;)t+=n[e].entries.length;return t}}var y="function",p="string",v="undefined";if(typeof encodeURIComponent==v||Array.prototype.splice===t||Object.prototype.hasOwnProperty===t)return null;var g=o("key"),d=o("value"),E=0,K=1,q=2;return s.prototype={getEqualityFunction:function(t){return typeof t.equals==y?i:u},getEntryForKey:a(K),getEntryAndIndexForKey:a(q),
removeEntryForKey:function(t){var n=this.getEntryAndIndexForKey(t);return n?(this.entries.splice(n[0],1),n[1]):null},addEntry:function(t,n){this.entries.push([t,n])},keys:l(0),values:l(1),getEntries:function(t){for(var n=t.length,e=0,r=this.entries,i=r.length;i>e;++e)t[n+e]=r[e].slice(0)},containsKey:a(E),containsValue:function(t){for(var n=this.entries,e=n.length;e--;)if(t===n[e][1])return!0;return!1}},c.prototype={each:function(t){for(var n,e=this.entries(),r=e.length;r--;)n=e[r],t(n[0],n[1])},
equals:function(t){var n,e,r,i=this.size();if(i==t.size()){for(n=this.keys();i--;)if(e=n[i],r=t.get(e),null===r||r!==this.get(e))return!1;return!0}return!1},putAll:function(t,n){for(var e,r,i,u,o=t.entries(),s=o.length,a=typeof n==y;s--;)e=o[s],r=e[0],i=e[1],a&&(u=this.get(r))&&(i=n(r,u,i)),this.put(r,i)},clone:function(){var t=new c(this.properties);return t.putAll(this),t}},c.prototype.toQueryString=function(){for(var t,e=this.entries(),r=e.length,i=[];r--;)t=e[r],i[r]=encodeURIComponent(n(t[0]))+
"\x3d"+encodeURIComponent(n(t[1]));return i.join("\x26")},c}();;;(function(){"use strict";



//== __global.js ==============================================================

'use strict';




//== __global_defines.js ======================================================

/**
 * @define {boolean}
 */
var DEBUG = true;

/**
 * @define {string}
 */
var FILE_NAME = "wrm.src.js";

/**
 * @define {string}
 */
var FILE_VERSION = "8.10.2.201809120835";

/**
 * @define {number}
 */
var SLOWDOWN = 0;

/**
 * @define {boolean}
 */
var TEST_LOGS = false;

/**
 * @define {boolean}
 */
var TRACE = false;




//== __global_export.js =======================================================

/*
 * Exporting
 */

/**
 * Exposes an unobfuscated global namespace path for the given object. Note that fields of the exported object will be obfuscated,
 * unless they are exported in turn via this function or goog.exportProperty
 * <p>
 * Also handy for making public items that are defined in anonymous closures.
 * 
 * @internal
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Value the name should point to.
 * @param {Object=} objectToExportTo Object to add the path to; default is <code>GLOBAL</code>.
 */
var exportSymbol = function(publicPath, object, objectToExportTo) {
  _exportPath(publicPath, object, objectToExportTo);
};

/**
 * Builds an object structure for the provided namespace path, ensuring that names that already exist are not overwritten. <br>
 * For example: "a.b.c" -> a = {};a.b={};a.b.c={};
 * 
 * @private
 * @param {string} name Name of the object that this file defines.
 * @param {*=} object Value to expose at the end of the path.
 * @param {Object=} objectToExportTo Object to add the path to; default is <code>GLOBAL</code>.
 */
var _exportPath = function(name, object, objectToExportTo) {
  var parts = name.split(".");
  var cur = objectToExportTo || GLOBAL;
  
  /*
   * Certain browsers cannot parse code in the form for((a in b); c;); This pattern is produced by the Closure Compiler when it
   * collapses the statement above into the conditional loop below. To prevent this from happening, use a for-loop and reserve the
   * init logic as below.
   */
  for (var part;parts.length && (part = parts.shift());) {
    var curPrev = cur;
    if (!parts.length && object !== undefined) {
      /* Last part and we have an object; use it */
      cur[part] = object;
      if (DEBUG) {
        _processExportedSymbol(cur, part, object);
      }
    } else {
      if (cur[part]) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
        if (DEBUG) {
          _processExportedSymbol(curPrev, part, cur);
        }
      }
    }
  }
};

/**
 * Exports a property unobfuscated into the object's namespace.
 * 
 * @internal
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Value the name should point to.
 */
var exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
  if (DEBUG) {
    _processExportedSymbol(object, publicName, symbol);
  }
};

if (DEBUG) {
  
  /**
   * Processes a symbol that was just exported.
   * 
   * @private
   * @param {!Object} owner Owner object.
   * @param {string} property Property name.
   * @param {*} value Property value.
   */
  var _processExportedSymbol = function(owner, property, value) {
    var parentName, name;
    
    /* Name all symbols */
    if (value && (typeof value === "function" || typeof value === "object")) {
      parentName = owner === GLOBAL ? "" : _getSymbolName(owner) || null;
      if (parentName !== null) {
        name = parentName ? parentName + "." + property : property;
        
        _nameSymbol(value, name);
        if (typeof value === "function") {
          _nameSymbol(value.prototype, name + ".prototype");
        }
      }
    }
  };
  
  /**
   * Gives a debug name to a symbol.
   * 
   * @private
   * @param {*} symbol Symbol to name.
   * @param {string} name Name to give.
   */
  var _nameSymbol = function(symbol, name) {
    
    /* Test whether defineProperty can be used with native objects */
    var nativeDefinePropertySupported = false;
    try {
      var o = {};
      Object.defineProperty(o, "test", {value:"foo"});
      nativeDefinePropertySupported = o["test"] === "foo";
    } catch (e) {
    }
    
    /* Proceed only if read-only, non-enumerable properties can be defined */
    var _nameSymbolImpl;
    if (nativeDefinePropertySupported) {
      _nameSymbolImpl = function(symbol, name) {
        if (!Object.prototype.hasOwnProperty.call(symbol, "__wr_symbol")) {
          Object.defineProperty(symbol, "__wr_symbol", {value:name, enumerable:false, configurable:true});
        }
        
        /* Give a displayName property to functions for Firebug */
        if (typeof symbol === "function" && !Object.prototype.hasOwnProperty.call(symbol, "displayName")) {
          Object.defineProperty(symbol, "displayName", {value:name, configurable:true});
        }
      };
    } else {
      _nameSymbolImpl = function(symbol, name) {
      };
    }
    _nameSymbol = _nameSymbolImpl;
    
    _nameSymbolImpl(symbol, name);
  };
  
  /**
   * Gets the debug name of a symbol.
   * 
   * @private
   * @param {*} symbol Symbol.
   * @return {?string} Name or <code>null</code>.
   */
  var _getSymbolName = function(symbol) {
    return symbol["__wr_symbol"] || null;
  };
  
}
;




//== __global_tools.js ========================================================

/*
 * Special values and functions
 */

/**
 * A function that does not return or do anything.
 * 
 * @internal
 */
var EMPTY_FUNCTION = function() {
};

/*
 * OO constructs
 */

/**
 * Placeholder function for use in interfaces and abstract classes to implement abstract methods.
 * <p>
 * The returned function always throws an error, so that if it is not overridden by an actual implementation, a runtime error will
 * result.
 * 
 * @internal
 * @const
 * @type {!Function}
 * @throws {Error} Always, since this function should never be called in a correct program.
 */
var ABSTRACT_METHOD = function() {
  throw new Error("Unimplemented abstract method");
};
/**
 * Constructs a new object having a specific object as prototype.
 * <p>
 * This function enables creating objects with a specific prototype chain without having to create an ad-hoc constructor function.
 * 
 * @internal
 * @param {Object} proto Object to use as prototype for the new object or <code>null</code> for using the the built-in {@link Object}
 *            prototype.
 * @param {Object=} properties Own properties to set on the new object. If not specified, nothing is set.
 * @return {!Object} Created object.
 */
var newObject = function(proto, properties) {
  var o;
  if (proto) {
    /** @constructor */
    var ctor = function() {
    };
    ctor.prototype = proto;
    o = new ctor;
  } else {
    o = {};
  }
  if (properties) {
    for (var p in properties) {
      if (properties.hasOwnProperty(p)) {
        o[p] = properties[p];
      }
    }
  }
  return o;
};

/**
 * @private
 * @param {!Function} derived
 * @param {!Function} base
 */
var _extendConstructor = function(derived, base) {
  derived._super = base.prototype;
  derived.prototype = newObject(base.prototype);
  derived.prototype["constructor"] = derived;
};

/**
 * Implements inheritance by having a constructor extend a base constructor.
 * <p>
 * Instances of the derived constructor will successfully pass an <code>instanceof</code> test against both their constructor and all
 * super-constructors. In addition, all constructor instances will inherit prototype properties of all super-constructors.
 * 
 * @internal
 * @param {function(new:Object)} derived Derived (more specific) constructor function.
 * @param {function(new:Object)} base Base (more generic) constructor function.
 */
var extendConstructor = _extendConstructor;

/**
 * Implements inheritance by having a function prototype extend the prototype of another function.
 * 
 * @internal
 * @param {*} derived Derived (more specific) function.
 * @param {*} base Base (more generic) function.
 */
var extendFunctionPrototype = (_extendConstructor);

/**
 * Builds a constructor for custom errors.
 * 
 * @internal
 * @param {string} name Name of the error type.
 * @param {function(new:Error,string=)=} base Base constructor. If not specified, the global {@link Error} constructor is used.
 * @param {function(this:Error,?,?)=} initializer Custom initialization function receiving all the arguments passed to the created
 *            constructor. The context (<code>this</code>) is the error being constructed.
 * @return {function(new:Error,string=)} New error constructor function.
 */
var makeCustomErrorConstructor = function(name, base, initializer) {
  base = base || GLOBAL["Error"];
  
  /**
   * @constructor
   * @extends Error
   * @param {string=} message
   */
  var ctor = function(message) {
    message = message || name;
    var tmp = base.call(this, message);
    angular.extend(this, tmp);
    this.name = name;
    this.message = tmp.message;
    if (typeof Error["captureStackTrace"] === "function") {
      Error["captureStackTrace"](tmp, ctor);
    }
    if (tmp.stack !== undefined) {
      this.stack = name + (message ? ": " + message : "") + "\n" + tmp.stack.split(/\n+/).slice(1).join("\n");
    }
    if (initializer) {
      initializer.apply(this, Array.prototype.slice.call(arguments, 0));
    }
  };
  _extendConstructor(ctor, base);
  
  return ctor;
};

/*
 * Tools for dynamic type checking
 */

if (DEBUG) {
  
  /**
   * Checks implementation of an interface on an object.
   * 
   * @internal
   * @param {*} iface Interface to check or <code>null</code> to check only for <code>null</code> and <code>undefined</code>.
   * @param {*} object Object to check.
   * @throws {TypeError} if interface check fails.
   */
  var checkInterface = function(iface, object) {
    var problem = _checkInterface(object, iface);
    if (problem) {
      throw new TypeError("Object does not fully implement interface " + iface + ". " + problem);
    }
  };
  
}

/**
 * Tests whether an object implements an interface.
 * 
 * @internal
 * @param {*} object Object to test against.
 * @param {*} iface Interface to test or <code>null</code> to test only for <code>null</code> or <code>undefined</code>.
 * @return {boolean} <code>true</code> if object implements the interface, <code>false</code> if it does not.
 */
var implementsInterface = function(object, iface) {
  return _checkInterface(object, iface) === null;
};

/**
 * Internally checks conformity of an object to an interface.
 * 
 * @private
 * @param {*} object Object to check.
 * @param {*} iface Interface to check or <code>null</code> to check only for <code>null</code> and <code>undefined</code>.
 * @return {?string} Message describing the first problem that makes the object not implement the interface or <code>null</code> if
 *         there is no such problem and the object fully implements the interface.
 */
var _checkInterface = function(object, iface) {
  var objectType = typeof object;
  if (objectType === "undefined" || object === null) {
    return "Object is null or undefined";
  }
  /* Determine the collection of properties to check */
  var properties;
  if (typeof iface === "function") {
    properties = iface.prototype;
  } else {
    properties = iface;
  }
  
  /*
   * Check that properties exist on the object prototype chain. Also check that functions and non-functions are the same properties.
   */
  var pType, oType;
  for (var p in properties) {
    pType = typeof properties[p];
    oType = typeof object[p];
    if (oType === "undefined") {
      return "Missing property '" + p + "'";
    }
    if (pType === "function" && oType !== "function" || pType !== "function" && oType === "function") {
      return "Property '" + p + "' " + (pType === "function" ? "should be" : "should not be") + " a function";
    }
  }
  
  /* Conforming */
  return null;
};

/*
 * Tools to aid debugging
 */

if (DEBUG) {
  
  /*
   * Extend native Object and Function prototypes with a new toString method that works differently only for symbols exported from
   * this library. This should be safe... and anyway, it's just for debug mode.
   */
  if (GLOBAL.Object && GLOBAL.Object.prototype) {
    GLOBAL.Object.prototype.toString = function() {
      var $super = GLOBAL.Object.prototype.toString;
      return function() {
        var symbolInfo = this && this["__wr_symbol"];
        
        /* Use symbol name if present */
        if (symbolInfo) {
          return String(symbolInfo);
        }
        
        return $super.call(this);
      };
    }();
  }
  if (GLOBAL.Function && GLOBAL.Function.prototype) {
    GLOBAL.Function.prototype.toString = function() {
      var $super = GLOBAL.Function.prototype.toString;
      return function() {
        var symbolInfo = this && this["__wr_symbol"];
        
        /* Use symbol name if present */
        if (symbolInfo) {
          return String(symbolInfo);
        }
        
        return $super.call(this);
      };
    }();
  }
  
}
;




//== wrm/CatcherService.js ====================================================

var wrm = {};

/**
 * @interface
 * @extends wrm.Service
 */
wrm.CatcherService = function() {
};

/**
 * @param {!wrm.core.EventSubscribeContext} context
 * @return {undefined|!Promise}
 */
wrm.CatcherService.prototype.subscribe = function(context) {
};

/**
 * @param {!wrm.core.EventContext} context
 * @param {!wrm.nav.Event} event
 * @return {!Object|!Promise<!Object>}
 */
wrm.CatcherService.prototype.catchEvent = function(context, event) {
};




//== wrm/Constants.js =========================================================


/**
 * @internal
 * @enum {string}
 */
wrm.Constants = {FAKE_FLOW_ID:"impl", USER_ENT_ID:"MUser", USER_OID_ATT_ID:"mUserOID", USER_USERNAME_ATT_ID:"mUsername", USER_ROLES_ROL_ID:"MUser2MRole", ROLE_ENT_ID:"MRole", ROLE_OID_ATT_ID:"mRoleOID", ROLE_NAME_ATT_ID:"mRoleName", ROLE_USER_ROL_ID:"MRole2MUser"};




//== wrm/ViewComponentService.js ==============================================


/**
 * @interface
 * @extends wrm.Service
 */
wrm.ViewComponentService = function() {
};

/**
 * @param {!wrm.core.ViewComponentContext} context
 * @return {!Object|!Promise.<!Object>}
 */
wrm.ViewComponentService.prototype.computeOutput = function(context) {
};

/**
 * @param {!wrm.core.ViewComponentContext} context
 * @return {undefined|!Promise}
 */
wrm.ViewComponentService.prototype.updateView = function(context) {
};

/**
 * @param {!wrm.core.ViewComponentContext} context
 * @param {!wrm.nav.Event} event
 * @return {undefined|!Promise}
 */
wrm.ViewComponentService.prototype.catchEvent = function(context, event) {
};

/**
 * @param {!wrm.core.ViewComponentContext} context
 * @return {!Object|!Promise.<!Object>}
 */
wrm.ViewComponentService.prototype.submitView = function(context) {
};




//== wrm/Service.js ===========================================================


/**
 * @interface
 */
wrm.Service = function() {
};

/**
 * @param {!Object} descr
 * @return {*|!Promise}
 */
wrm.Service.prototype.initialize = function(descr) {
};

/**
 * @return {string}
 */
wrm.Service.prototype.getId = function() {
};




//== wrm/core/AbstractService.js ==============================================

wrm.core = {};


/**
 * @constructor
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 * @implements wrm.Service
 */
wrm.core.AbstractService = function(id, descr, manager) {
  
  /** @private */
  this._id = id;
  
  /** @private */
  this._manager = manager;
  
  /* Create logger */
  var serviceType = this._manager.getServiceType(this);
  var log = this._manager.getPlatform().createLog(serviceType, "[" + id + "]");
  
  /** @private */
  this._log = log;
};

/**
 * @override
 * @param {!Object} descr
 * @return {undefined|!Promise}
 */
wrm.core.AbstractService.prototype.initialize = function(descr) {
};

/**
 * @override
 * @const
 */
wrm.core.AbstractService.prototype.getId = function() {
  return this._id;
};

/**
 * @protected
 * @const
 * @return {!wrm.core.Manager}
 */
wrm.core.AbstractService.prototype.getManager = function() {
  return this._manager;
};

/**
 * @protected
 * @const
 * @return {!wrm.Log}
 */
wrm.core.AbstractService.prototype.getLog = function() {
  return this._log;
};

/** @override */
wrm.core.AbstractService.prototype.toString = function() {
  var name = this._manager.getServiceType(this) || "UnknownService";
  var idx = name.lastIndexOf(".");
  if (idx >= 0) {
    name = name.substring(idx + 1);
  }
  return name + ":" + this._id;
};

/*
 * Utilities for accessing descriptors
 */

/**
 * @protected
 * @const
 * @template T
 * @param {!Object} descr
 * @param {string} property
 * @return {!T}
 */
wrm.core.AbstractService.prototype.getDescriptorValue = function(descr, property) {
  var value = descr[property];
  if (value === null || value === undefined) {
    throw new Error("Required property '" + property + "' not found in descriptor of " + this);
  }
  return value;
};

/**
 * @protected
 * @const
 * @template T
 * @param {!Object} descr
 * @param {string} property
 * @return {null|undefined|!T}
 */
wrm.core.AbstractService.prototype.getOptionalDescriptorValue = function(descr, property) {
  return descr[property];
};




//== wrm/core/AbstractViewComponentService.js =================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.ViewComponentService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.AbstractViewComponentService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
};

extendConstructor(wrm.core.AbstractViewComponentService, wrm.core.AbstractService);

/** @override */
wrm.core.AbstractViewComponentService.prototype.computeOutput = ABSTRACT_METHOD;

/** @override */
wrm.core.AbstractViewComponentService.prototype.updateView = ABSTRACT_METHOD;

/** @override */
wrm.core.AbstractViewComponentService.prototype.catchEvent = function(context, event) {
};

/** @override */
wrm.core.AbstractViewComponentService.prototype.submitView = function(context) {
  return {};
};




//== wrm/core/AbstractCachedViewComponentService.js ===========================



/**
 * @constructor
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 * @extends wrm.core.AbstractViewComponentService
 */
wrm.core.AbstractCachedViewComponentService = function(id, descr, manager) {
  wrm.core.AbstractViewComponentService.call(this, id, descr, manager);
};

extendConstructor(wrm.core.AbstractCachedViewComponentService, wrm.core.AbstractViewComponentService);

/**
 * @override
 * @final
 */
wrm.core.AbstractCachedViewComponentService.prototype.computeOutput = function(context) {
  return this._retrieveResult(context).then(this.computeOutputFromResult.bind(this, context));
};

/**
 * @protected
 * @param {!wrm.core.ViewComponentContext} context
 * @param {!Object} result
 * @return {!Object}
 */
wrm.core.AbstractCachedViewComponentService.prototype.computeOutputFromResult = function(context, result) {
  return result;
};

/**
 * @override
 * @final
 */
wrm.core.AbstractCachedViewComponentService.prototype.updateView = function(context) {
  return this._retrieveResult(context).then(this.updateViewFromResult.bind(this, context));
};

/**
 * @protected
 * @param {!wrm.core.ViewComponentContext} context
 * @param {!Object} result
 */
wrm.core.AbstractCachedViewComponentService.prototype.updateViewFromResult = function(context, result) {
  angular.extend(context.getView(), result);
};

/**
 * @private
 * @param {!wrm.core.ViewComponentContext} context
 * @return {!Promise<!Object>}
 */
wrm.core.AbstractCachedViewComponentService.prototype._retrieveResult = function(context) {
  var log = this.getLog();
  
  /* Attempt to retrieve a previous result cached in context, but discarding it if stale */
  var RESULT_CACHE_KEY = "_cachedResult";
  var cachedResult = context[RESULT_CACHE_KEY];
  if (cachedResult && this.isStaleResult(context, cachedResult)) {
    log.debug("Discarding stale result");
    cachedResult = null;
  }
  
  /* If there was a non-stale cached result, return that */
  if (cachedResult) {
    return Promise.resolve(cachedResult);
  }
  
  /* If there is no cached result (or was stale), create a new one and cache it */
  return Promise.resolve(this.createResult(context)).then(function(createdResult) {
    createdResult = createdResult || {};
    context[RESULT_CACHE_KEY] = createdResult;
    return createdResult;
  });
};

/**
 * @protected
 * @param {!wrm.core.ViewComponentContext} context
 * @param {!Object} result
 * @return {boolean}
 */
wrm.core.AbstractCachedViewComponentService.prototype.isStaleResult = function(context, result) {
  return false;
};

/**
 * @protected
 * @param {!wrm.core.ViewComponentContext} context
 * @return {!Object|!Promise<!Object>}
 */
wrm.core.AbstractCachedViewComponentService.prototype.createResult = ABSTRACT_METHOD;




//== wrm/core/AbstractCatcherService.js =======================================



/**
 * @constructor
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 * @extends wrm.core.AbstractService
 * @implements wrm.CatcherService
 */
wrm.core.AbstractCatcherService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
};

extendConstructor(wrm.core.AbstractCatcherService, wrm.core.AbstractService);

/** @override */
wrm.core.AbstractCatcherService.prototype.subscribe = ABSTRACT_METHOD;

/** @override */
wrm.core.AbstractCatcherService.prototype.catchEvent = ABSTRACT_METHOD;




//== wrm/nav/Destination.js ===================================================

wrm.nav = {};

/**
 * @interface
 */
wrm.nav.Destination = function() {
};

/**
 * @return {?string}
 */
wrm.nav.Destination.prototype.getFence = function() {
};




//== wrm/nav/Notifiable.js ====================================================



/**
 * @interface
 * @extends wrm.nav.Destination
 */
wrm.nav.Notifiable = function() {
};

/**
 * @param {!wrm.nav.Event} event
 * @param {!wrm.nav.State} state
 * @return {?wrm.nav.Route|!Promise.<?wrm.nav.Route>}
 */
wrm.nav.Notifiable.prototype.notify = function(event, state) {
};




//== wrm/core/AbstractEventHandler.js =========================================



/**
 * @package
 * @constructor
 * @implements wrm.nav.Notifiable
 * @param {!wrm.core.Manager} manager
 */
wrm.core.AbstractEventHandler = function(manager) {
  
  /** @private */
  this._manager = manager;
};

/**
 * @protected
 * @const
 * @return {!wrm.core.Manager}
 */
wrm.core.AbstractEventHandler.prototype.getManager = function() {
  return this._manager;
};

/** @override */
wrm.core.AbstractEventHandler.prototype.getFence = function() {
  throw new Error("Unsupported");
};

/** @override */
wrm.core.AbstractEventHandler.prototype.notify = ABSTRACT_METHOD;




//== wrm/OperationService.js ==================================================


/**
 * @interface
 * @extends wrm.Service
 */
wrm.OperationService = function() {
};

/**
 * @param {!wrm.core.OperationContext} context
 * @return {!wrm.nav.Output|!Promise<!wrm.nav.Output>}
 */
wrm.OperationService.prototype.executeOperation = function(context) {
};




//== wrm/core/AbstractOperationService.js =====================================



/**
 * @constructor
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 * @extends wrm.core.AbstractService
 * @implements wrm.OperationService
 */
wrm.core.AbstractOperationService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
};

extendConstructor(wrm.core.AbstractOperationService, wrm.core.AbstractService);

/** @override */
wrm.core.AbstractOperationService.prototype.executeOperation = ABSTRACT_METHOD;




//== wrm/SubService.js ========================================================


/**
 * @interface
 */
wrm.SubService = function() {
};

/**
 * @param {!Object} descr
 * @return {*|!Promise}
 */
wrm.SubService.prototype.initialize = function(descr) {
};




//== wrm/core/AbstractSubService.js ===========================================



/**
 * @constructor
 * @param {!wrm.Service} parent
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 * @implements wrm.SubService
 */
wrm.core.AbstractSubService = function(parent, descr, manager) {
  
  /** @private */
  this._parent = parent;
  
  /** @private */
  this._manager = manager;
  
  /* Create logger */
  var subServiceType = this._manager.getSubServiceType(this);
  var log = this._manager.getPlatform().createLog(subServiceType, "[" + parent.getId() + "]");
  
  /** @private */
  this._log = log;
};

/**
 * @override
 * @param {!Object} descr
 * @return {undefined|!Promise}
 */
wrm.core.AbstractSubService.prototype.initialize = function(descr) {
};

/**
 * @protected
 * @const
 * @return {!wrm.Service}
 */
wrm.core.AbstractSubService.prototype.getParent = function() {
  return this._parent;
};

/**
 * @protected
 * @const
 * @return {!wrm.core.Manager}
 */
wrm.core.AbstractSubService.prototype.getManager = function() {
  return this._manager;
};

/**
 * @protected
 * @const
 * @return {!wrm.Log}
 */
wrm.core.AbstractSubService.prototype.getLog = function() {
  return this._log;
};

/** @override */
wrm.core.AbstractSubService.prototype.toString = function() {
  var name = this._manager.getSubServiceType(this) || "UnknownSubService";
  var idx = name.lastIndexOf(".");
  if (idx >= 0) {
    name = name.substring(idx + 1);
  }
  return name + ":" + this._parent.getId();
};




//== wrm/ThrowerService.js ====================================================


/**
 * @interface
 * @extends wrm.Service
 */
wrm.ThrowerService = function() {
};

/**
 * @param {!wrm.core.ComponentContext} context
 * @return {!wrm.nav.Event|!Promise.<!wrm.nav.Event>}
 */
wrm.ThrowerService.prototype.throwEvent = function(context) {
};




//== wrm/core/AbstractThrowerService.js =======================================



/**
 * @constructor
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 * @extends wrm.core.AbstractService
 * @implements wrm.ThrowerService
 */
wrm.core.AbstractThrowerService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
};

extendConstructor(wrm.core.AbstractThrowerService, wrm.core.AbstractService);

/** @override */
wrm.core.AbstractThrowerService.prototype.throwEvent = ABSTRACT_METHOD;




//== wrm/core/UpdateParticipant.js ============================================


/**
 * @interface
 */
wrm.core.UpdateParticipant = function() {
};

/**
 * @return {!Array<string>}
 */
wrm.core.UpdateParticipant.prototype.getRequiredParticipantIds = function() {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise|undefined}
 */
wrm.core.UpdateParticipant.prototype.beginUpdate = function(context) {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise|undefined}
 */
wrm.core.UpdateParticipant.prototype.prepareForExtensionUpdate = function(context) {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise|undefined}
 */
wrm.core.UpdateParticipant.prototype.performExtensionUpdate = function(context) {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise|undefined}
 */
wrm.core.UpdateParticipant.prototype.performCoreUpdate = function(context) {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise|undefined}
 */
wrm.core.UpdateParticipant.prototype.prepareForReductionUpdate = function(context) {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise|undefined}
 */
wrm.core.UpdateParticipant.prototype.performReductionUpdate = function(context) {
};

/**
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise<boolean>|boolean}
 */
wrm.core.UpdateParticipant.prototype.finishUpdate = function(context) {
};




//== wrm/core/AbstractUpdateParticipant.js ====================================



/**
 * @constructor
 * @implements wrm.core.UpdateParticipant
 */
wrm.core.AbstractUpdateParticipant = function() {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.getRequiredParticipantIds = function() {
  return [];
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.beginUpdate = function(context) {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.prepareForExtensionUpdate = function(context) {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.performExtensionUpdate = function(context) {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.performCoreUpdate = function(context) {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.prepareForReductionUpdate = function(context) {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.performReductionUpdate = function(context) {
};

/** @override */
wrm.core.AbstractUpdateParticipant.prototype.finishUpdate = function(context) {
  return false;
};




//== wrm/nav/Output.js ========================================================


/**
 * @constructor
 * @param {string} result
 * @param {!Object=} properties
 */
wrm.nav.Output = function(result, properties) {
  
  /* Non-enumerable property for saving result (to avoid it showing in 'toString') */
  Object.defineProperty(this, "_result", {value:result});
  
  angular.extend(this, properties);
};

/**
 * @return {string}
 */
wrm.nav.Output.prototype.getResult = function() {
  return this["_result"];
};

/** @override */
wrm.nav.Output.prototype.toString = function() {
  return "\x3c" + this["_result"] + "\x3e " + JSON.stringify(this);
};




//== wrm/core/ActionDefOutput.js ==============================================



/**
 * @package
 * @constructor
 * @extends wrm.nav.Output
 * @param {string} result
 * @param {boolean} success
 * @param {!Object=} properties
 */
wrm.core.ActionDefOutput = function(result, success, properties) {
  wrm.nav.Output.call(this, result, properties);
  
  /**
   * @private
   * @type {boolean}
   */
  this._success = success;
};

extendConstructor(wrm.core.ActionDefOutput, wrm.nav.Output);

/**
 * @return {boolean}
 */
wrm.core.ActionDefOutput.prototype.isSuccess = function() {
  return this._success;
};

/**
 * @return {?string}
 */
wrm.core.ActionDefOutput.prototype.getNotificationMessage = function() {
  return this[wrm.core.ActionDefService.NOTIFICATION_MESSAGE_OUTPUT] || null;
};

/**
 * @param {string} notificationMessage
 */
wrm.core.ActionDefOutput.prototype.setNotificationMessage = function(notificationMessage) {
  this[wrm.core.ActionDefService.NOTIFICATION_MESSAGE_OUTPUT] = notificationMessage;
};




//== wrm/nav/Executable.js ====================================================


/**
 * @interface
 */
wrm.nav.Executable = function() {
};

/**
 * @param {!Object} input
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Output|!Promise.<!wrm.nav.Output>}
 */
wrm.nav.Executable.prototype.execute = ABSTRACT_METHOD;




//== wrm/core/_core.js ========================================================


/**
 * @name wrm.core
 * @namespace
 */

/**
 * @internal
 * @const
 * @type {string}
 */
wrm.core.PASSINGS_COMPONENT_ID = "__passings";

/**
 * @internal
 * @param {string} id
 * @return {{componentId:string,name:string}}
 * @throws {Error}
 */
wrm.core.parseParameter = function(id) {
  var m = /^(?:([^:]+):)?(.+)$/.exec(id);
  if (!m) {
    throw new Error("Invalid parameter id '" + id + "'");
  }
  
  return {componentId:m[1] || wrm.core.PASSINGS_COMPONENT_ID, name:m[2]};
};




//== wrm/util/obj/_obj.js =====================================================

wrm.util = {};
wrm.util.obj = {};

/**
 * @name wrm.util.obj
 * @namespace
 */

/**
 * Looks up the value of an object property.
 * 
 * @param {string} name Fully qualified name of the property.
 * @param {!Object=} scope Object in the scope of which to look for the property. If not specified, the global object is used.
 * @return {*} Property value. If the last of the properties making up the qualified name is not found, <code>undefined</code> is
 *         returned as value.
 * @throws {TypeError} if it is not possible to find one of the properties making up the qualified name, except for the last property.
 */
wrm.util.obj.lookup = function(name, scope) {
  if (!name) {
    return undefined;
  }
  
  var parts = name.split(".");
  var cur = scope || GLOBAL;
  
  try {
    for (var part;parts.length && (part = parts.shift());) {
      cur = cur[part];
    }
  } catch (e) {
    if (e instanceof TypeError) {
      e = new TypeError("" + name + " is undefined");
    }
    throw e;
  }
  
  return cur;
};

/**
 * Looks up the value of an object property, limiting the search to <i>existing</i> properties.
 * <p>
 * The search will stop early if encountering a <code>null</code> or <code>undefined</code> reference. This helper is therefore safe to
 * use even when some of the properties do not exist or have no value.
 * 
 * @param {string} name Fully qualified name of the property.
 * @param {!Object=} scope Object in the scope of which to look for the property. If not specified, the global object is used.
 * @return {*} Property value. If a <code>null</code> or <code>undefined</code> is encountered, that value is returned even before
 *         reaching the last property.
 */
wrm.util.obj.lookupSafe = function(name, scope) {
  if (!name) {
    return undefined;
  }
  
  var parts = name.split(".");
  var cur = scope || GLOBAL;
  
  for (var part;parts.length && (part = parts.shift());) {
    cur = cur[part];
    if (cur === null || cur === undefined) {
      break;
    }
  }
  
  return cur;
};

/**
 * @template V
 * @param {!Array<string>} keys
 * @param {V|function(string):V} values
 * @return {!Object<string,V>}
 */
wrm.util.obj.createFromKeys = function(keys, values) {
  var result = {};
  for (var i = 0;i < keys.length;i++) {
    if (typeof values === "function") {
      result[keys[i]] = values(keys[i]);
    } else {
      result[keys[i]] = values;
    }
  }
  return result;
};

/**
 * // TODO doc
 * 
 * @param {!Array<*>} olderValues
 * @param {!Array<*>} newerValues
 * @return {{added:!Array<*>, removed:!Array<*>}}
 */
wrm.util.obj.findValuesDiff = function(olderValues, newerValues) {
  
  /* Put all old values in a map */
  var oldValuesMap = {};
  olderValues.forEach(function(v) {
    oldValuesMap[v] = v;
  });
  
  /* Extract added values and remove preserved ones from old-values key set */
  var added = [];
  newerValues.forEach(function(v) {
    if (oldValuesMap[v] !== undefined) {
      delete oldValuesMap[v];
    } else {
      added.push(v);
    }
  });
  
  /* Removed values are the old ones that are still in the map */
  var removed = Object.keys(oldValuesMap).map(function(key) {
    return oldValuesMap[key];
  });
  
  return {added:added, removed:removed};
};

/**
 * @param {!Object} targetObject
 * @param {!Object} sourceObject
 * @param {!Array<string>=} names
 * @return {!Object}
 */
wrm.util.obj.copyProperties = function(targetObject, sourceObject, names) {
  names = names || Object.keys(sourceObject);
  names.forEach(function(name) {
    if (sourceObject.hasOwnProperty(name)) {
      targetObject[name] = sourceObject[name];
    }
  });
  return targetObject;
};

/**
 * @param {!Array<!Object>|!Object} object
 * @param {!Array<string>=} names
 * @return {!Object}
 */
wrm.util.obj.extractPropertyValues = function(object, names) {
  
  /* Extract property values and put them in a result object by property name */
  var result = {};
  if (Array.isArray(object)) {
    var length = object.length;
    object.forEach(function(element, elementIndex) {
      (names || Object.keys(element)).forEach(function(name) {
        extractProperty(result, name, elementIndex, length, element);
      });
    });
  } else {
    (names || Object.keys(object)).forEach(function(name) {
      extractProperty(result, name, 0, 1, object);
    });
  }
  
  /* Function for extracting a single property and saving it in arrays or single values */
  function extractProperty(result, name, index, size, source) {
    var value = source[name];
    if (value === undefined) {
      return;
    }
    
    if (size > 1) {
      if (!result[name]) {
        result[name] = new Array(size);
      }
      result[name][index] = value;
    } else {
      result[name] = value;
    }
  }
  
  return result;
  
};

/**
 * @internal
 * @template T
 * @param {!Array<T>} list
 * @param {number} chunkSize
 * @return {!Array<!Array<T>>}
 */
wrm.util.obj.sliceList = function(list, chunkSize) {
  var chunks = [];
  for (var chunkStart = 0;chunkStart < list.length;chunkStart += chunkSize) {
    chunks.push(list.slice(chunkStart, chunkStart + chunkSize));
  }
  return chunks;
};

/*
 * Enumerations
 */

/**
 * @private
 * @type {{names:!Array<string>,values:!Array<string|number>,namesByValue:!Object<string|number,string>}}
 */
wrm.util.obj._EMPTY_INFO = {names:[], values:[], namesByValue:{}};

/**
 * Gets information about an enumeration type, extracting it if necessary.
 * 
 * @private
 * @param {!Object} enumType Enumeration type.
 * @return {{names:!Array<string>,values:!Array<string|number>,namesByValue:!Object<string|number,string>}} Enumeration type
 *         information.
 */
wrm.util.obj._getEnumTypeInfo = function(enumType) {
  var info = (enumType["_enum_type_info"]);
  
  if (!info) {
    var names = [];
    var values = [];
    var namesByValue = {};
    for (var p in enumType) {
      if (!Object.prototype.hasOwnProperty.call(enumType, p)) {
        continue;
      }
      var v = enumType[p];
      if (typeof v !== "function" && /^(?!_).+/.test(p)) {
        names.push(p);
        values.push(v);
        namesByValue[v] = p;
      }
    }
    info = {names:names, values:values, namesByValue:namesByValue};
    Object.defineProperty(enumType, "_enum_type_info", info);
  }
  
  return info;
};

/**
 * Gets the constant values of an enumeration type.
 * 
 * @template E
 * @param {!Object} enumType Enumeration type.
 * @return {!Array<E>} Constant values.
 */
wrm.util.obj.getEnumValues = function(enumType) {
  return wrm.util.obj._getEnumTypeInfo(enumType).values;
};

/**
 * Gets the constant names of an enumeration type.
 * 
 * @param {!Object} enumType Enumeration type.
 * @return {!Array<string>} Constant names.
 */
wrm.util.obj.getEnumNames = function(enumType) {
  return wrm.util.obj._getEnumTypeInfo(enumType).names;
};

/**
 * Gets the name of an enumeration constant value.
 * 
 * @param {!Object} enumType Enumeration type.
 * @param {string|number} value Constant value.
 * @return {string} Name of the constant.
 */
wrm.util.obj.getEnumName = function(enumType, value) {
  var name = (wrm.util.obj._getEnumTypeInfo(enumType).namesByValue[value]);
  if (!name) {
    throw new TypeError("Invalid constant value '" + value + "' for enumeration type " + enumType);
  }
  return name;
};

/**
 * Casts an enum value to the corresponding enum constant.
 * 
 * @template E
 * @param {!Object} enumType Enumeration type.
 * @param {string|number} value Constant value.
 * @return {!E} Enumeration value.
 */
wrm.util.obj.castEnumValue = function(enumType, value) {
  if (!wrm.util.obj._getEnumTypeInfo(enumType).namesByValue[value]) {
    throw new TypeError("Invalid constant value '" + value + "' for enumeration type " + enumType);
  }
  return value;
};

/*
 * Classes
 */

wrm.util.obj.defineClass = function() {
  var constructing = false;
  
  function defineClass(superConstructor, properties) {
    superConstructor = superConstructor || Object;
    var superProto = superConstructor.prototype;
    
    var currentThis = null;
    
    /* Create a wrapper for the super-constructor */
    var superCtorWrapper = function() {
      superConstructor.apply(currentThis, arguments);
    };
    
    /* Create a wrapper for accessing super-instance methods */
    var superObjectWrapper = {};
    if (superProto) {
      for (var key in superProto) {
        defineValueProperty(superObjectWrapper, key, function(key) {
          return function() {
            return superProto[key].apply(currentThis, arguments);
          };
        }(key), true);
      }
    }
    
    var localCtorImpl = properties["constructor"];
    var localStatics = properties["statics"];
    
    /* Create the local prototype */
    var localProto = Object.create(superProto);
    for (var key in properties) {
      if (key === "constructor" || key === "statics" || !properties.hasOwnProperty(key)) {
        continue;
      }
      defineValueProperty(localProto, key, function(propertyValue) {
        if (typeof propertyValue === "function") {
          return function() {
            currentThis = this;
            return propertyValue.apply(this, arguments);
          };
        }
        return propertyValue;
      }(properties[key]), true);
    }
    
    /* Create the constructor */
    var ctor = function() {
      var top = !constructing;
      if (localCtorImpl) {
        constructing = true;
        currentThis = this;
        defineValueProperty(this, "_superConstructor", superCtorWrapper, false, true);
        try {
          localCtorImpl.apply(this, arguments);
        } finally {
          delete this["_superConstructor"];
          if (top) {
            constructing = false;
          }
        }
      }
      if (!constructing) {
        defineValueProperty(this, "_super", superObjectWrapper);
      }
    };
    ctor.prototype = localProto;
    defineValueProperty(ctor.prototype, "constructor", ctor);
    
    /* Copy the local static properties */
    if (localStatics) {
      for (var key in localStatics) {
        if (localStatics.hasOwnProperty(key)) {
          defineValueProperty(ctor, key, localStatics[key], true);
        }
      }
    }
    
    Object.freeze(localProto);
    
    return ctor;
  }
  
  /**
   * @param {!Object} object
   * @param {string} key
   * @param {*} value
   * @param {boolean=} enumerable
   * @param {boolean=} configurable
   */
  function defineValueProperty(object, key, value, enumerable, configurable) {
    Object.defineProperty(object, key, {enumerable:!!enumerable, configurable:!!configurable, value:value});
  }
  
  return defineClass;
}();




//== wrm/nav/Flow.js ==========================================================


/**
 * @interface
 */
wrm.nav.Flow = function() {
};

/**
 * @return {string}
 */
wrm.nav.Flow.prototype.getId = function() {
};

/**
 * @internal
 * @return {?string}
 */
wrm.nav.Flow.prototype.getBoundSourceId = function() {
};

/**
 * @internal
 * @return {?string}
 */
wrm.nav.Flow.prototype.getBoundTargetId = function() {
};

/**
 * @param {!Object} source
 * @param {!wrm.nav.State} state
 */
wrm.nav.Flow.prototype.propagate = function(source, state) {
};

/**
 * @param {!Object} source
 * @param {number} score
 * @param {!Object<string,!Object<string,number>>} targetScoresMap
 * @param {!wrm.nav.State} state
 */
wrm.nav.Flow.prototype.propagateWithScore = function(source, score, targetScoresMap, state) {
};




//== wrm/nav/AbstractFlow.js ==================================================



/**
 * @internal
 * @constructor
 * @implements wrm.nav.Flow
 * @param {string} id
 */
wrm.nav.AbstractFlow = function(id) {
  
  /**
   * @private
   * @type {string}
   */
  this._id = id;
};

/** @override */
wrm.nav.AbstractFlow.prototype.getId = function() {
  return this._id;
};

/**
 * @override
 * @protected
 */
wrm.nav.AbstractFlow.prototype.getBoundSourceId = ABSTRACT_METHOD;

/**
 * @override
 * @protected
 */
wrm.nav.AbstractFlow.prototype.getBoundTargetId = ABSTRACT_METHOD;

/**
 * @override
 * @const
 */
wrm.nav.AbstractFlow.prototype.propagate = function(source, state) {
  this._doPropagate(source, 0, null, state);
};

/**
 * @override
 * @const
 */
wrm.nav.AbstractFlow.prototype.propagateWithScore = function(source, score, targetScoresMap, state) {
  this._doPropagate(source, score, targetScoresMap, state);
};

/**
 * @private
 * @param {!Object} source
 * @param {number} score
 * @param {?Object<string,!Object<string,number>>} targetScoresMap
 * @param {!wrm.nav.State} state
 */
wrm.nav.AbstractFlow.prototype._doPropagate = function(source, score, targetScoresMap, state) {
  
  /* Apply the preservation logic (must be done before propagation and in all cases) */
  this._applyPreservations(state);
  
  /* If there is no bound target, exit */
  var boundTargetId = this.getBoundTargetId();
  if (!boundTargetId) {
    return;
  }
  
  /* Propagate bindings to the bound target component inputs */
  var targetInput = state.getComponentInput(boundTargetId);
  var targetScores = score > 0 && targetScoresMap ? targetScoresMap[boundTargetId] : null;
  var bindings = this.getBindings();
  Object.keys(bindings).forEach(function(targetParam) {
    var binding = bindings[targetParam];
    
    /* Determine whether the particular parameter should be ignored because of the score */
    if (targetScores) {
      var targetScore = targetScores && targetScores[targetParam] || 0;
      if (targetScore >= score) {
        return;
      }
    }
    
    /* Actually propagate to the target */
    var value = this._computePropagatedValue(source, state, binding);
    if (value !== undefined) {
      targetInput[targetParam] = value;
      if (targetScores) {
        targetScores[targetParam] = score;
      }
      state.registerPropagation(boundTargetId, targetParam);
    }
  }, this);
  
  /* Propagate passing data to the navigation state */
  var currentPassingData = state.getPassingData();
  angular.forEach(this.getPassings(), function(passingBinding, passingId) {
    var value = this._computePropagatedValue(source, state, passingBinding);
    if (value !== undefined) {
      currentPassingData[passingId] = value;
    }
  }, this);
};

/**
 * @private
 * @param {!Object} source
 * @param {!wrm.nav.State} state
 * @param {!*} binding
 * @return {*}
 */
wrm.nav.AbstractFlow.prototype._computePropagatedValue = function(source, state, binding) {
  if (typeof binding === "object") {
    
    /* Constants */
    var constant = binding["k"];
    if (constant !== undefined) {
      switch(constant) {
        case wrm.nav.SystemValueKey.TOKEN:
          return wrm.nav.SystemValues.token;
        case wrm.nav.SystemValueKey.LAST_SYNCHRONIZATION_TIMESTAMP:
          return wrm.nav.SystemValues.lastSynchronizationTimestamp;
        case wrm.nav.SystemValueKey.LANGUAGE_ISO_CODE:
          return wrm.nav.SystemValues.languageIsoCode;
        case wrm.nav.SystemValueKey.COUNTRY_ISO_CODE:
          return wrm.nav.SystemValues.countryIsoCode;
        case wrm.nav.SystemValueKey.CURRENT_TIMESTAMP:
          return Date.now();
        case wrm.nav.SystemValueKey.CURRENT_DATE:
          return wrm.data.Date.fromDate(new Date);
        default:
          return constant;
      }
    }
    
    /* Passed parameters */
    var passed = binding["p"];
    if (passed !== undefined) {
      return state.getPassingData()[passed];
    }
  }
  
  /* Named parameters of the source */
  return wrm.util.obj.lookupSafe(String(binding), source);
};

/**
 * @private
 * @param {!wrm.nav.State} state
 */
wrm.nav.AbstractFlow.prototype._applyPreservations = function(state) {
  
  /* If there are no preservations, there is nothing to do (ALL is preserved) */
  var preserves = this.getPreserves();
  if (!preserves) {
    return;
  }
  
  /* Apply preservations to all component inputs of the state */
  var inputsToDiscard = [];
  angular.forEach(state.getComponentInputs(), function(input, componentId) {
    
    /* Get the parameters to keep. If no preserve is specified, there is nothing to keep */
    var keptParams = preserves[componentId];
    if (!keptParams) {
      inputsToDiscard.push(componentId);
      return;
    }
    
    /* Delete input parameters that are not to be kept. Parameters are found in public OWN properties of the input object */
    for (var inputProperty in input) {
      if (inputProperty.charAt(0) === "_") {
        continue;
      }
      if (!input.hasOwnProperty(inputProperty)) {
        continue;
      }
      if (keptParams[inputProperty] === true) {
        continue;
      }
      delete input[inputProperty];
    }
    
  }, this);
  
  /* Discard component inputs for which there is nothing to keep */
  inputsToDiscard.forEach(function(componentId) {
    state.discardComponentInput(componentId);
  });
};

/**
 * @protected
 * @return {Object.<string,!Object.<string,boolean>>}
 */
wrm.nav.AbstractFlow.prototype.getPreserves = function() {
  return null;
};

/**
 * @protected
 * @return {!Object.<string,*>}
 */
wrm.nav.AbstractFlow.prototype.getBindings = function() {
  return {};
};

/**
 * @protected
 * @return {!Object.<string,*>}
 */
wrm.nav.AbstractFlow.prototype.getPassings = function() {
  return {};
};

/** @override */
wrm.nav.AbstractFlow.prototype.toString = function() {
  return this._id;
};




//== wrm/nav/FlowImpl.js ======================================================



/**
 * @internal
 * @constructor
 * @extends wrm.nav.AbstractFlow
 * @param {!Object} descr
 */
wrm.nav.FlowImpl = function(descr) {
  wrm.nav.AbstractFlow.call(this, descr["id"]);
  
  /**
   * @private
   * @type {?string}
   */
  this._boundSourceId = descr["bindFrom"] || null;
  
  /**
   * @private
   * @type {?string}
   */
  this._boundTargetId = descr["bindTo"] || null;
  
  /**
   * @private
   * @type {Object.<string,!Object.<string,boolean>>}
   */
  this._preserves = typeof descr["preserve"] === "string" ? this._createPreserves(descr["preserve"]) : null;
  
  /**
   * @private
   * @type {!Object.<string,*>}
   */
  this._bindings = descr["bind"] || {};
  
  /**
   * @private
   * @type {!Object.<string,*>}
   */
  this._passings = descr["pass"] || {};
  
};

extendConstructor(wrm.nav.FlowImpl, wrm.nav.AbstractFlow);

/**
 * @private
 * @param {string} preservesString
 * @return {!Object.<string,!Object.<string,boolean>>}
 */
wrm.nav.FlowImpl.prototype._createPreserves = function(preservesString) {
  var result = {};
  
  /*
   * Extract parameters from the string and map their component-specific name to the component id that they refer to. Each parameter
   * is expected to be in the format "component:name"
   */
  if (preservesString) {
    angular.forEach(preservesString.split("|"), function(preserveId) {
      var param = wrm.core.parseParameter(preserveId);
      
      /* Map */
      var set = result[param.componentId];
      if (!set) {
        result[param.componentId] = set = {};
      }
      set[param.name] = true;
    });
  }
  
  return result;
};

/** @override */
wrm.nav.FlowImpl.prototype.getBoundSourceId = function() {
  return this._boundSourceId;
};

/** @override */
wrm.nav.FlowImpl.prototype.getBoundTargetId = function() {
  return this._boundTargetId;
};

/** @override */
wrm.nav.FlowImpl.prototype.getPreserves = function() {
  return this._preserves;
};

/** @override */
wrm.nav.FlowImpl.prototype.getBindings = function() {
  return this._bindings;
};

/** @override */
wrm.nav.FlowImpl.prototype.getPassings = function() {
  return this._passings;
};




//== wrm/nav/NavFlow.js =======================================================



/**
 * @interface
 * @extends wrm.nav.Flow
 */
wrm.nav.NavFlow = function() {
};

/**
 * @return {string}
 */
wrm.nav.NavFlow.prototype.getTargetId = function() {
};




//== wrm/nav/NavFlowImpl.js ===================================================



/**
 * @internal
 * @constructor
 * @extends wrm.nav.FlowImpl
 * @implements wrm.nav.NavFlow
 * @param {!Object} descr
 */
wrm.nav.NavFlowImpl = function(descr) {
  wrm.nav.FlowImpl.call(this, descr);
  
  /**
   * @private
   * @type {string}
   */
  this._targetId = descr["navTo"];
};

extendConstructor(wrm.nav.NavFlowImpl, wrm.nav.FlowImpl);

/** @override */
wrm.nav.NavFlowImpl.prototype.getTargetId = function() {
  return this._targetId;
};

/** @override */
wrm.nav.NavFlowImpl.prototype.getBoundTargetId = function() {
  var result = wrm.nav.NavFlowImpl._super.getBoundTargetId.call(this);
  return result || this._targetId;
};




//== wrm/core/ActionDefService.js =============================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.nav.Executable
 */
wrm.core.ActionDefService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  var outputPortsDescr = descr["outputPorts"];
  var defaultSuccessPort = outputPortsDescr["success"];
  var defaultErrorPort = outputPortsDescr["error"];
  
  /* Build a set of all success ports (default and others) */
  var successPorts = {};
  successPorts[defaultSuccessPort] = true;
  angular.forEach(outputPortsDescr["other_success"], function(otherPort) {
    successPorts[otherPort] = true;
  });
  
  /* Build a set of all error ports (default and others) */
  var errorPorts = {};
  errorPorts[defaultErrorPort] = true;
  angular.forEach(outputPortsDescr["other_error"], function(otherPort) {
    errorPorts[otherPort] = true;
  });
  
  /**
   * @private
   * @type {!Object}
   */
  this._inputFlowDescr = descr["input"];
  
  /**
   * @private
   * @type {Array<!Object>}
   */
  this._inputDataFlowDescrs = descr["input*"] || null;
  
  /**
   * @private
   * @type {!Object<string,!Object<string,!Object>>}
   */
  this._componentFlowDescrs = descr["components"];
  
  /**
   * @private
   * @type {string}
   */
  this._defaultSuccessPort = defaultSuccessPort;
  
  /**
   * @private
   * @type {string}
   */
  this._defaultErrorPort = defaultErrorPort;
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._successPorts = successPorts;
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._errorPorts = errorPorts;
  
  /**
   * @private
   * @type {?string}
   */
  this._progress = descr["progressNotification"] || null;
  
  /**
   * @private
   * @type {!Object<string,string>}
   */
  this._notifications = descr["outputNotifications"] || {};
  
  /**
   * @private
   * @type {!wrm.l10n.LocalizationService}
   */
  this._l10nService;
};

extendConstructor(wrm.core.ActionDefService, wrm.core.AbstractService);

/** @override */
wrm.core.ActionDefService.prototype.initialize = function() {
  var thisService = this;
  return this.getManager().getLocalizationService().then(function(l10nService) {
    thisService._l10nService = l10nService;
  });
};

/** @override */
wrm.core.ActionDefService.prototype.execute = function(input, state) {
  var thisService = this;
  var l10nService = this._l10nService;
  var progress = this._progress;
  
  if (progress) {
    state.reportProgress(new wrm.nav.Progress(l10nService.formatMessage(progress)));
  }
  state.pushIsland();
  
  function cleanup() {
    state.popIsland();
    if (progress) {
      state.reportProgress(new wrm.nav.Progress(null));
    }
  }
  
  return this._doExecute(input, state).then(function(output) {
    cleanup();
    thisService._enrichOutput(output);
    return output;
  }, function(e) {
    cleanup();
    throw e;
  });
};

/**
 * @private
 * @param {!Object} input
 * @param {!wrm.nav.State} state
 * @return {!wrm.core.ActionDefOutput|!Promise<!wrm.core.ActionDefOutput>}
 */
wrm.core.ActionDefService.prototype._doExecute = function(input, state) {
  var thisService = this;
  
  /* Navigate from the input */
  var promise = Promise.resolve(this._executeInput(input, state));
  
  /* Execute the chain of components, reaching an output port */
  promise = promise.then(function(firstComponentId) {
    return thisService._executeChain(firstComponentId, state);
  });
  
  /* Return the output port inputs as output for all the action definition */
  promise = promise.then(function(outputPortId) {
    var success = thisService._successPorts.hasOwnProperty(outputPortId);
    return new wrm.core.ActionDefOutput(outputPortId, success, state.getComponentInput(outputPortId));
  });
  
  return promise;
};

/**
 * @private
 * @param {!Object} input
 * @param {!wrm.nav.State} state
 * @return {string}
 */
wrm.core.ActionDefService.prototype._executeInput = function(input, state) {
  
  /* Propagate all data flows */
  if (this._inputDataFlowDescrs) {
    angular.forEach(this._inputDataFlowDescrs, function(dataFlowDescr) {
      var dataFlow = new wrm.nav.FlowImpl(dataFlowDescr);
      dataFlow.propagate(input, state);
    });
  }
  
  /* Propagate the flow associated with the input */
  if (this._inputFlowDescr) {
    var inputFlow = new wrm.nav.NavFlowImpl(this._inputFlowDescr);
    inputFlow.propagate(input, state);
    return inputFlow.getTargetId();
  } else {
    
    /* If there is no flow from the input jump directly to default output success port */
    return this._defaultSuccessPort;
  }
};

/**
 * @private
 * @param {string} firstComponentId
 * @param {!wrm.nav.State} state
 * @return {!Promise<string>}
 */
wrm.core.ActionDefService.prototype._executeChain = function(firstComponentId, state) {
  var thisService = this;
  
  /**
   * @param {string} componentId
   * @return {!Promise<string>}
   */
  function executeChainStep(componentId) {
    
    /* If the component is an output port, return its id */
    if (thisService._successPorts.hasOwnProperty(componentId) || thisService._errorPorts.hasOwnProperty(componentId)) {
      return Promise.resolve(componentId);
    }
    
    /* Execute the component and continue with the NEXT step of the chain */
    return (thisService._executeComponent(componentId, state).then(executeChainStep));
  }
  
  /*
   * Call the stepping function on the first component. After a number of recursive async calls, the last one will eventually return
   * the identifier of the reached output port
   */
  return executeChainStep(firstComponentId);
};
/**
 * @private
 * @param {string} componentId
 * @param {!wrm.nav.State} state
 * @return {!Promise<string>}
 */
wrm.core.ActionDefService.prototype._executeComponent = function(componentId, state) {
  var thisService = this;
  
  /* Retrieve the component service */
  var input = state.getComponentInput(componentId);
  var outputFlowDescrs = this._componentFlowDescrs[componentId];
  var promise = this.getManager().getService(componentId).then(function(componentService) {
    
    /* Wrap operations inside an executable adapter */
    var executable;
    if (implementsInterface(componentService, wrm.OperationService)) {
      executable = new wrm.core.ExecutableOperation((componentService));
    } else {
      executable = (componentService);
    }
    
    return thisService._doExecuteExecutable(executable, input, outputFlowDescrs, state);
  });
  
  return promise;
};

/**
 * @private
 * @param {!wrm.nav.Executable} executable
 * @param {!Object} input
 * @param {!Object<string,!Object>} outputFlowDescrs
 * @param {!wrm.nav.State} state
 * @return {!Promise<string>}
 */
wrm.core.ActionDefService.prototype._doExecuteExecutable = function(executable, input, outputFlowDescrs, state) {
  var thisService = this;
  var log = this.getLog();
  
  /* Execute the service */
  var promise = Promise.resolve().then(function() {
    log.debug("Executing", executable, "-", input);
    return Promise.resolve(executable.execute(input, state)).then(function(output) {
      log.debug("Executed", executable, "-", output);
      return output;
    });
  })["catch"](function(e) {
    log.error("Executed", executable, "- Thrown error", e);
    return new wrm.nav.Output("error");
  });
  
  /* Propagate data flows, then the flow associated with the output code */
  promise = promise.then(function(output) {
    var result = thisService._getResult(outputFlowDescrs, output);
    thisService._propagateComponentDataFlows(outputFlowDescrs, output, state, result);
    var flow = thisService._createComponentNavigationFlow(outputFlowDescrs, output, result);
    log.debug("Following flow", flow);
    flow.propagate(output, state);
    return flow.getTargetId();
  });
  
  return promise;
};

/**
 * @private
 * @param {!Object<string,!Object>} outputFlowDescrs
 * @param {!wrm.nav.Output} output
 * @param {!wrm.nav.State} state
 * @param {string} result
 */
wrm.core.ActionDefService.prototype._propagateComponentDataFlows = function(outputFlowDescrs, output, state, result) {
  
  /* Get descriptors (first code-specific, then generic) */
  var dataFlowDescrs = outputFlowDescrs[result + "*"] || outputFlowDescrs["*"];
  if (!dataFlowDescrs) {
    return;
  }
  
  /* Propagate all data flows */
  angular.forEach(dataFlowDescrs, function(dataFlowDescr) {
    var dataFlow = new wrm.nav.FlowImpl(dataFlowDescr);
    dataFlow.propagate(output, state);
  });
};

/**
 * @private
 * @param {!Object<string,!Object>} outputFlowDescrs
 * @param {!wrm.nav.Output} output
 * @param {string} result
 * @return {!wrm.nav.NavFlow}
 */
wrm.core.ActionDefService.prototype._createComponentNavigationFlow = function(outputFlowDescrs, output, result) {
  
  /* Attempt to get and exact match first */
  var flowDescr = outputFlowDescrs[result];
  if (flowDescr) {
    return new wrm.nav.NavFlowImpl(flowDescr);
  }
  
  /* Forward standard success/error results and unknown results to the default success/error ports */
  var portId;
  var m = /^(success|error)(?:\..+)?$/.exec(result);
  if (m && m[1] === "success") {
    portId = this._defaultSuccessPort;
  } else {
    portId = this._defaultErrorPort;
  }
  return new wrm.core.ActionDefService._JumpFlow(portId);
};

/**
 * @private
 * @param {!Object<string,!Object>} outputFlowDescrs
 * @param {!wrm.nav.Output} output
 * @return {string}
 */
wrm.core.ActionDefService.prototype._getResult = function(outputFlowDescrs, output) {
  var result = output.getResult();
  
  /* Attempt to get and exact match first */
  var flowDescr = outputFlowDescrs[result];
  if (flowDescr) {
    
    /* If a valid flow is found return that result */
    return result;
  }
  
  var m = /^(success|error)(?:\..+)?$/.exec(result);
  if (m && m[1] === "success") {
    result = "success";
  } else {
    if (m && m[1] === "error") {
      result = "error";
    }
  }
  return result;
};

/**
 * @const
 * @type {string}
 */
wrm.core.ActionDefService.NOTIFICATION_MESSAGE_OUTPUT = "notificationMessage";

/**
 * @private
 * @param {!wrm.core.ActionDefOutput} output
 */
wrm.core.ActionDefService.prototype._enrichOutput = function(output) {
  
  /* If the chain did not compute a notification message, localize one from the default key (if present) */
  if (!output.getNotificationMessage()) {
    var messageKey = this._notifications[output.getResult()];
    if (messageKey) {
      output.setNotificationMessage(this._l10nService.formatMessage(messageKey));
    }
  }
};

/*
 * Jump flow
 */

/**
 * @private
 * @constructor
 * @extends wrm.nav.FlowImpl
 * @implements wrm.nav.NavFlow
 * @param {string} targetId
 */
wrm.core.ActionDefService._JumpFlow = function(targetId) {
  wrm.nav.FlowImpl.call(this, {});
  
  /** @private */
  this._targetId = targetId;
};

extendConstructor(wrm.core.ActionDefService._JumpFlow, wrm.nav.FlowImpl);

/** @override */
wrm.core.ActionDefService._JumpFlow.prototype.getTargetId = function() {
  return this._targetId;
};

/** @override */
wrm.core.ActionDefService._JumpFlow.prototype.getBoundTargetId = function() {
  return this._targetId;
};

/** @override */
wrm.core.ActionDefService._JumpFlow.prototype.toString = function() {
  return "\x3cjump to " + this._targetId + "\x3e";
};




//== wrm/nav/Dialog.js ========================================================


/**
 * @constructor
 * @template R
 * @param {string} message
 * @param {!wrm.nav.Dialog.Flavor} flavor
 * @param {!Array<{label:string, value:R, default:(boolean|undefined)}>=} choices
 */
wrm.nav.Dialog = function(message, flavor, choices) {
  
  /** @private */
  this._flavor = flavor;
  
  /** @private */
  this._message = message;
  
  /** @private */
  this._choices = choices || [];
};

/**
 * @enum {string}
 */
wrm.nav.Dialog.Flavor = {POSITIVE:"positive", CAUTIONAL:"cautional", NEGATIVE:"negative"};

/**
 * @return {!wrm.nav.Dialog.Flavor}
 */
wrm.nav.Dialog.prototype.getFlavor = function() {
  return this._flavor;
};

/**
 * @return {string}
 */
wrm.nav.Dialog.prototype.getMessage = function() {
  return this._message;
};

/**
 * @return {!Array.<string>}
 */
wrm.nav.Dialog.prototype.getChoiceLabels = function() {
  return this._choices.map(function(choice) {
    return choice.label;
  });
};

/**
 * @return {number}
 */
wrm.nav.Dialog.prototype.getDefaultChoiceIndex = function() {
  for (var i = 0;i < this._choices.length;i++) {
    if (this._choices[i]["default"]) {
      return i;
    }
  }
  return 0;
};

/**
 * @param {number} choiceIndex
 * @return {R}
 */
wrm.nav.Dialog.prototype.getChoiceValue = function(choiceIndex) {
  var choice = this._choices[choiceIndex];
  if (!choice) {
    throw new Error("Invalid choice");
  }
  return choice.value;
};

/** @override */
wrm.nav.Dialog.prototype.toString = function() {
  return 'Dialog:"' + this._message + '"';
};




//== wrm/nav/Navigable.js =====================================================



/**
 * @interface
 * @extends wrm.nav.Destination
 */
wrm.nav.Navigable = function() {
};

/**
 * @param {?string} gate
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Route|!Promise.<!wrm.nav.Route>}
 */
wrm.nav.Navigable.prototype.navigate = function(gate, state) {
};




//== wrm/core/ActionService.js ================================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.nav.Navigable
 * @implements wrm.nav.Executable
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.ActionService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /**
   * @private
   * @type {?Array<string>}
   */
  this._protectionRoles = descr["protected"] || null;
  
  /**
   * @private
   * @type {?string}
   */
  this._fence = descr["fence"] || null;
  
  /**
   * @private
   * @type {string}
   */
  this._definitionId = descr["definition"];
  
  /**
   * @private
   * @type {!Object<string,!Object>}
   */
  this._flowDescrs = descr["flows"] || {};
  
  /**
   * @private
   * @type {!Object<string,string>}
   */
  this._notifications = descr["notifications"] || {};
  
  /**
   * @private
   * @type {!wrm.l10n.LocalizationService}
   */
  this._l10nService;
  
  /**
   * @private
   * @type {!wrm.data.sync.DataSyncService}
   */
  this._dataSyncService;
};

extendConstructor(wrm.core.ActionService, wrm.core.AbstractService);

/** @override */
wrm.core.ActionService.prototype.initialize = function() {
  var thisService = this;
  var manager = this.getManager();
  return Promise.all([manager.getLocalizationService().then(function(l10nService) {
    thisService._l10nService = l10nService;
  }), manager.getDataSyncService().then(function(dataSyncService) {
    thisService._dataSyncService = dataSyncService;
  })]);
};

/*
 * Navigation
 */

/** @override */
wrm.core.ActionService.prototype.getFence = function() {
  return this._fence;
};

/** @override */
wrm.core.ActionService.prototype.navigate = function(gate, state) {
  var thisActionService = this;
  
  /* Check permission. Unless denied access, proceed to navigate */
  return this._checkPermission(state).then(function(route) {
    if (route) {
      return route;
    }
    
    /* Navigate, then give a chance to data synchronization after the action */
    return thisActionService._navigate(state).then(function(resultRoute) {
      return thisActionService._dataSyncService.synchronizeDuringNavigation(state).then(function(dataSyncRoute) {
        return dataSyncRoute || resultRoute;
      });
    });
  }).then(function(finalRoute) {
    thisActionService._dataSyncService.collectSuccessEvents(state);
    return finalRoute;
  });
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.ActionService.prototype._checkPermission = function(state) {
  var allowedRoles = this._protectionRoles;
  if (allowedRoles) {
    return this.getManager().getSecurityService().then(function(securityService) {
      return securityService.checkPermission((allowedRoles), state);
    });
  }
  return Promise.resolve((null));
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Route|!Promise<!wrm.nav.Route>}
 */
wrm.core.ActionService.prototype._navigate = function(state) {
  var Dialog = wrm.nav.Dialog;
  var thisService = this;
  var log = this.getLog();
  
  /* Execute the action and get back the output code */
  var input = state.getComponentInput(this.getId());
  var promise = this.execute(input, state);
  
  /* Propagate data flows, then the flow associated with the output code */
  promise = promise.then(function(output) {
    thisService._propagateDataFlows(output, state);
    
    /* Prepare the final route out of the action */
    var route;
    var flow = thisService._createOutputNavigationFlow(output);
    if (flow) {
      log.debug("Following flow", flow);
      flow.propagate(output, state);
      state.stepAhead(flow);
      route = wrm.nav.Route.toService(flow.getTargetId());
    } else {
      log.debug("Following implicit flow");
      state.stepImplicitly();
      route = wrm.nav.Route.toService(state.getContextualStartPanelId() || undefined);
    }
    
    /* Present a notification dialog, if specified */
    var notificationMessage = output.getNotificationMessage();
    if (notificationMessage) {
      var notificationFlavor = output.isSuccess() ? Dialog.Flavor.POSITIVE : Dialog.Flavor.NEGATIVE;
      return state.presentDialog(new Dialog(notificationMessage, notificationFlavor)).then(function() {
        return route;
      });
    }
    
    return route;
  });
  
  return promise;
};

/**
 * @private
 * @param {!wrm.nav.Output} output
 * @param {!wrm.nav.State} state
 */
wrm.core.ActionService.prototype._propagateDataFlows = function(output, state) {
  var result = output.getResult();
  var dataFlowDescrs = this._flowDescrs[result + "*"];
  if (!dataFlowDescrs) {
    return;
  }
  
  /* Propagate all data flows */
  angular.forEach(dataFlowDescrs, function(dataFlowDescr) {
    var dataFlow = new wrm.nav.FlowImpl(dataFlowDescr);
    dataFlow.propagate(output, state);
  });
};

/**
 * !wrm.nav.Output} output
 * 
 * @return {wrm.nav.NavFlow}
 */
wrm.core.ActionService.prototype._createOutputNavigationFlow = function(output) {
  var result = output.getResult();
  var flowDescr = this._flowDescrs[result];
  if (flowDescr) {
    return new wrm.nav.NavFlowImpl(flowDescr);
  }
  return null;
};

/** @override */
wrm.core.ActionService.prototype.execute = function(input, state) {
  var thisService = this;
  
  /* Action may be prefixed with the action id itself: remove it */
  var fixedInput = {};
  var keyPrefix = this.getId() + ".";
  angular.forEach(input, function(value, key) {
    if (key.indexOf(keyPrefix) === 0) {
      key = key.substring(keyPrefix.length);
    }
    fixedInput[key] = value;
  });
  
  return this.getManager().getActionDefinitionService(this._definitionId).then(function(actionDefService) {
    return actionDefService.execute(fixedInput, state);
  }).then(function(output) {
    thisService._enrichOutput(output);
    return output;
  });
};

/**
 * @private
 * @param {!wrm.core.ActionDefOutput} output
 */
wrm.core.ActionService.prototype._enrichOutput = function(output) {
  
  /* If the definition did not compute a notification message, localize one from the default key (if present) */
  if (!output.getNotificationMessage()) {
    var messageKey = this._notifications[output.getResult()];
    if (messageKey) {
      output.setNotificationMessage(this._l10nService.formatMessage(messageKey));
    }
  }
};




//== wrm/core/AppResumeHandler.js =============================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractEventHandler
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.AppResumeHandler = function(descr, manager) {
  wrm.core.AbstractEventHandler.call(this, manager);
  
  /**
   * @private
   * @type {boolean}
   */
  this._reAccess = descr["reAccess"];
};

extendConstructor(wrm.core.AppResumeHandler, wrm.core.AbstractEventHandler);

/** @override */
wrm.core.AppResumeHandler.prototype.notify = function(event, state) {
  var manager = this.getManager();
  
  /* Access again if asked to */
  var promise;
  if (this._reAccess) {
    promise = manager.getSecurityService().then(function(securityService) {
      return securityService.accessAgain(false, state);
    }).then(function(accessRoute) {
      return accessRoute || null;
    });
  } else {
    promise = Promise.resolve(null);
  }
  
  /* Start a "resume" data synchronization */
  return promise.then(function(route) {
    if (route) {
      return route;
    }
    return manager.getDataSyncService().then(function(dataSyncService) {
      return dataSyncService.synchronizeOnResume(state).then(function() {
        return wrm.nav.Route.toNowhere();
      });
    });
  });
};




//== wrm/_wrm.js ==============================================================



/**
 * @name wrm
 * @namespace
 */

/**
 * Version number of the Runtime.
 * 
 * @const
 * @type {string}
 */
wrm.VERSION = FILE_VERSION;

/**
 * @internal
 * @typedef {{basePath:string, name:?string}}
 */
wrm.SystemDirectoryInfo;

/**
 * @internal
 * @type {!wrm.SystemDirectoryInfo}
 */
wrm.tempDirectory = {basePath:"tmp", name:null};

/**
 * @internal
 * @type {!wrm.SystemDirectoryInfo}
 */
wrm.persistentDirectory = {basePath:"data", name:null};

/**
 * @internal
 * @type {string}
 */
wrm.blobDirectoryName = "objects";

/**
 * Sets the directory to use for storing all temporary files of the application.
 * 
 * @param {string} basePath a path string identifying an existing directory.
 * @param {string=} name of an additional directory to create under the base path.
 */
wrm.setTempDirectory = function(basePath, name) {
  wrm.tempDirectory = {basePath:basePath, name:name || null};
};

/**
 * Sets the the directory to use for storing all persistent files of the application.
 * 
 * @param {string} basePath a path string identifying an existing directory.
 * @param {string=} name of an additional directory to create under the base path.
 */
wrm.setPersistentDirectory = function(basePath, name) {
  wrm.persistentDirectory = {basePath:basePath, name:name || null};
};

/**
 * @internal
 * @const
 * @type {!Object<string,!Object<string,*>>}
 */
wrm.DEFINED_MODULES = {};

/**
 * Defines a new module available to the Runtime.
 * 
 * @param {string} name Name of the module.
 * @param {!Object<string,*>} exports Values exported by the module, keyed by their name. The special key <code>default</code> denotes
 *            the default exported value of the module.
 */
wrm.defineModule = function(name, exports) {
  if (wrm.DEFINED_MODULES.hasOwnProperty(name)) {
    throw new Error("Module '" + name + "' is already defined");
  }
  wrm.DEFINED_MODULES[name] = exports || {};
};

/**
 * @internal
 * @param {string} name
 * @return {!Promise<!Object<string,*>>}
 */
wrm.importModule = function(name) {
  var module = wrm.DEFINED_MODULES[name];
  if (!module) {
    return Promise.reject(new Error("Module '" + name + "' not found"));
  }
  return Promise.resolve(module);
};

/**
 * @template SUPER, SUB
 * @param {function(new:SUPER,string,!Object,!wrm.core.Manager)} superConstructor
 * @param {!Object} properties
 * @return {function(new:SUB,string,!Object,!wrm.core.Manager)}
 */
wrm.defineService = function(superConstructor, properties) {
  
  /** @constructor */
  var serviceCtor = wrm.util.obj.defineClass(superConstructor, angular.extend({constructor:function(id, descr, manager) {
    this._superConstructor(id, descr, manager);
  }}, properties));
  
  return serviceCtor;
};




//== wrm/util/_util.js ========================================================


/**
 * @name wrm.util
 * @namespace
 */

/**
 * @internal
 * @deprecated Use ES6 array methods.
 * @template C
 * @param {!Object} collection
 * @param {function(this:C,*=,*=,Object=):?=} body
 * @param {!C=} context
 * @return {!Promise}
 */
wrm.util.asyncForEach = function(collection, body, context) {
  
  /* Enumerate all keys */
  var keys;
  if (angular.isArray(collection)) {
    keys = [];
    for (var i = 0;i < collection.length;i++) {
      keys.push(i);
    }
  } else {
    keys = Object.keys(collection);
  }
  
  var index = 0;
  return wrm.util.asyncFor(undefined, function() {
    return index < keys.length;
  }, function() {
    return index++;
  }, function($break) {
    var key = keys[index];
    return body(collection[key], key, $break);
  }, context);
};

/**
 * @internal
 * @deprecated Use ES6 array methods.
 * @param {function()|undefined} initialization
 * @param {function():*|undefined} condition
 * @param {function()|undefined} increment
 * @param {function(?):?=} body
 * @param {Object=} context
 * @return {!Promise}
 */
wrm.util.asyncFor = function(initialization, condition, increment, body, context) {
  initialization = initialization || angular.noop;
  condition = condition || function() {
    return true;
  };
  increment = increment || angular.noop;
  body = body || angular.noop;
  context = context || GLOBAL;
  
  var $break = {};
  
  function loop() {
    if (!condition()) {
      return Promise.resolve();
    }
    return Promise.resolve(body.call(context, $break)).then(function(ret) {
      if (ret != $break) {
        increment();
        return loop();
      }
    });
  }
  
  initialization();
  return loop();
};

/**
 * @internal
 * @param {!Array<string>} items
 * @param {function(string):!Array<string>} requirementsRetriever
 * @return {!Array<string>}
 */
wrm.util.sortTopologically = function(items, requirementsRetriever) {
  
  /* Construct a graph of dependencies */
  var graph = {};
  items.forEach(function(item) {
    graph[item] = requirementsRetriever(item).slice();
  });
  
  /*
   * Sort topologically by using the Khan algorithm
   */
  
  var queue = [], result = [];
  
  /* Find nodes with no preceding, queue them and count edges */
  var preceding = {}, edgeCount = 0;
  Object.keys(graph).forEach(function(node) {
    var precedingNodes = graph[node];
    if (precedingNodes.length <= 0) {
      queue.push(node);
    } else {
      preceding[node] = precedingNodes.slice(0);
      edgeCount += preceding[node];
    }
  });
  
  /* Iterate, removing edges and queue nodes as they become dependency-free */
  var currentNode;
  while (currentNode = queue.shift()) {
    result.push(currentNode);
    Object.keys(preceding).forEach(function(otherNode) {
      var otherPrecedingNodes = preceding[otherNode];
      var idx = otherPrecedingNodes.indexOf(currentNode);
      if (idx >= 0) {
        otherPrecedingNodes.splice(idx, 1);
        if (otherPrecedingNodes.length <= 0) {
          queue.push(otherNode);
          edgeCount--;
        }
      }
    });
  }
  if (edgeCount > 0) {
    throw new Error("Found dependency cycles");
  }
  
  return result;
};

/**
 * @internal
 * @param {*} value
 * @return {boolean}
 */
wrm.util.isPromise = function(value) {
  return typeof value === "object" && !!value && "then" in value;
};

/**
 * @template T
 * @param {!Array.<!Promise.<T>>} promises
 * @param {number} minDelay
 * @param {number} maxDelay
 * @param {function(!Array.<T>)} onIncrementalFulfilled
 * @return {!Promise.<!Array.<T>>}
 */
wrm.util.promiseAllIncrementally = function(promises, minDelay, maxDelay, onIncrementalFulfilled) {
  var firstResultTS = null;
  var results = [];
  var timeout = null;
  
  /* Function for tracking results as they arrive and starting/restarting timers */
  function appendResult(result) {
    results.push(result);
    var currentTS = (new Date).valueOf();
    if (timeout !== null && firstResultTS !== null && currentTS - firstResultTS < maxDelay) {
      GLOBAL.clearTimeout(timeout);
      timeout = null;
    }
    if (timeout === null) {
      timeout = GLOBAL.setTimeout(notifyResults, minDelay);
      if (firstResultTS === null) {
        firstResultTS = currentTS;
      }
    }
  }
  
  /* Function for notifying results to the callback */
  function notifyResults() {
    if (results.length > 0) {
      onIncrementalFulfilled(results);
    }
    firstResultTS = null;
    timeout = null;
    results = [];
  }
  
  promises.forEach(function(promise) {
    Promise.resolve(promise).then(appendResult);
  });
  
  return Promise.all(promises).then(function(allResults) {
    notifyResults();
    return allResults;
  }).finally(function() {
    if (timeout !== null) {
      GLOBAL.clearTimeout(timeout);
    }
  });
};

/**
 * @template T
 * @param {function(T)=} resultHandler
 * @return {{promise:!Promise<T>, callback:function(T)}}
 */
wrm.util.newPromiseCallbackAdapter = function(resultHandler) {
  var callback = undefined;
  
  /* Create a promise and use its 'resolve' function, optionally adapated, as the callback */
  var promise = new Promise(function(resolve, reject) {
    if (resultHandler) {
      callback = function(result) {
        try {
          resultHandler(result);
          resolve();
        } catch (e) {
          reject(e);
        }
      };
    } else {
      callback = resolve;
    }
  });
  
  return {promise:promise, callback:callback};
};

/**
 * @param {number} duration
 * @return {!Promise}
 */
wrm.util.sleep = function(duration) {
  return new Promise(function(resolve) {
    GLOBAL.setTimeout(resolve, duration);
  });
};

/**
 * @internal
 * @param {function(Error)} rejectFunction
 * @return {function(*)}
 */
wrm.util.toErrorReject = function(rejectFunction) {
  return function(e) {
    return rejectFunction(wrm.util.toError(e));
  };
};

/**
 * Converts any object to an {@link Error} instance, if it is not one already.
 * <p>
 * This function is useful for normalizing the behavior of code that throws non-<code>Error</code> instances or that passes them to
 * {@link Promise#reject}.
 * 
 * @param {*} object Any object/value, usually a string.
 * @return {!Error} An error.
 */
wrm.util.toError = function(object) {
  if (object instanceof Error) {
    return object;
  }
  return new Error(object.message || String(object));
};

/**
 * @template T
 * @param {function(function(T=),function(string))} boundFunction
 * @return {!Promise.<T>}
 */
wrm.util.invokePlugin = function(boundFunction) {
  return new Promise(function(resolve, reject) {
    boundFunction(function(result) {
      resolve(result);
    }, wrm.util.toErrorReject(reject));
  });
};




//== wrm/util/fs/_fs.js =======================================================

wrm.util.fs = {};


/**
 * @name wrm.util.fs
 * @namespace
 */

/**
 * @param {!string} path
 * @return {!Promise<!File>}
 */
wrm.util.fs.lookupFile = function(path) {
  return wrm.util.fs.lookupFileEntry(path).then(function(fileEntry) {
    return new Promise(function(resolve, reject) {
      fileEntry.file(function(file) {
        resolve(file);
      }, wrm.util.fs._tofileErrorReject(reject));
    });
  });
};

/**
 * @param {?string=} prefix
 * @param {?string=} suffix
 * @return {!Promise<!FileEntry>}
 */
wrm.util.fs.createTempFile = function(prefix, suffix) {
  prefix = prefix || "";
  suffix = suffix || "";
  
  /* Create a new file using a timestamp for added uniqueness */
  var timestamp = String((new Date).valueOf());
  var name = prefix + timestamp + suffix;
  return wrm.util.fs._retrieveTempDirectory().then(function(tempDir) {
    return new Promise(function(resolve, reject) {
      tempDir.getFile(name, {create:true}, resolve, wrm.util.fs._tofileErrorReject(reject));
    });
  });
};

/**
 * @param {string} name
 * @return {!Promise<!FileEntry>}
 */
wrm.util.fs.createNamedTempFile = function(name) {
  
  /*
   * Create a new file under a directory named with a timestamp, in order to provide uniqueness while preserving the specified name
   */
  var timestamp = String((new Date).valueOf());
  return wrm.util.fs._retrieveTempDirectory().then(function(tempDir) {
    return new Promise(function(resolve, reject) {
      tempDir.getDirectory(timestamp, {create:true}, function(timestampDir) {
        timestampDir.getFile(name, {create:true}, resolve, wrm.util.fs._tofileErrorReject(reject));
      }, wrm.util.fs._tofileErrorReject(reject));
    });
  });
};

/**
 * @param {!FileEntry} fileEntry
 * @return {!Promise}
 */
wrm.util.fs.deleteTempFile = function(fileEntry) {
  return new Promise(function(resolve, reject) {
    fileEntry.getParent(function(parentDir) {
      fileEntry.remove(function() {
        
        /*
         * Attempt to also delete the parent directory, which is either our temporary directory or a timestamp directory. Will
         * fail if not empty: that's OK
         */
        parentDir.remove(angular.noop());
        
        resolve(undefined);
      }, wrm.util.fs._tofileErrorReject(reject));
    }, wrm.util.fs._tofileErrorReject(reject));
  });
};

/**
 * @return {!Promise}
 */
wrm.util.fs.clearTempFiles = function() {
  
  /*
   * Delete the temporary directory under which all temporary files are created
   */
  return wrm.util.fs._retrieveTempDirectory(true).then(function(tempDir) {
    if (tempDir == null) {
      return;
    }
    
    return new Promise(function(resolve, reject) {
      tempDir.removeRecursively(function() {
        resolve(undefined);
      }, wrm.util.fs._tofileErrorReject(reject));
    });
  });
};

/**
 * @private
 * @param {boolean=} skipCreate
 * @return {!Promise<?DirectoryEntry>}
 */
wrm.util.fs._retrieveTempDirectory = function(skipCreate) {
  skipCreate = skipCreate || false;
  
  /*
   * Create our own temporary file directory under the system temporary directory, so that we can aggressively delete files that are
   * really temporary according to the Runtime
   */
  return wrm.util.fs._lookupSystemDirectory(wrm.tempDirectory).then(function(systemTempDir) {
    return new Promise(function(resolve, reject) {
      systemTempDir.getDirectory("temp", {create:!skipCreate}, resolve, function(e) {
        if (skipCreate && e["code"] === 1) {
          resolve(null);
        } else {
          reject(wrm.util.toError(e));
        }
      });
    });
  });
};

/**
 * @internal
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.util.fs.retrievePersistentDirectory = function() {
  return wrm.util.fs._lookupSystemDirectory(wrm.persistentDirectory);
};

/**
 * @private
 * @param {!wrm.SystemDirectoryInfo} info
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.util.fs._lookupSystemDirectory = function(info) {
  return wrm.util.fs.lookupDirectoryEntry(info.basePath).then(function(baseDir) {
    if (!info.name) {
      return baseDir;
    }
    return new Promise(function(resolve, reject) {
      baseDir.getDirectory((info.name), {create:true}, resolve, wrm.util.toErrorReject(reject));
    });
  });
};

/**
 * @internal
 * @param {!DirectoryEntry} root
 * @param {string} path
 * @param {boolean=} skipCreate
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.util.fs.retrieveDirectory = function(root, path, skipCreate) {
  skipCreate = skipCreate || false;
  var directories = path.split("/").filter(function(step) {
    return step.length > 0;
  });
  return wrm.util.fs._retrieveDirectory(root, directories, skipCreate);
};

/**
 * @private
 * @param {!DirectoryEntry} root
 * @param {!Array<string>} path
 * @param {boolean} skipCreate
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.util.fs._retrieveDirectory = function(root, path, skipCreate) {
  if (path.length <= 0) {
    return Promise.resolve(root);
  }
  return new Promise(function(resolve, reject) {
    root.getDirectory(path[0], {create:!skipCreate}, function(dirEntry) {
      resolve(wrm.util.fs._retrieveDirectory(dirEntry, path.slice(1), skipCreate));
    }, wrm.util.fs._tofileErrorReject(reject));
  });
};

/**
 * @internal
 * @param {!DirectoryEntry} directory
 * @param {string} name
 * @return {!Promise<!FileEntry>}
 */
wrm.util.fs.createNamedFile = function(directory, name) {
  return new Promise(function(resolve, reject) {
    directory.getFile(name, {create:true}, resolve, wrm.util.fs._tofileErrorReject(reject));
  });
};

/**
 * @internal
 * @param {!Entry} entry
 * @return {!Promise}
 */
wrm.util.fs.deleteEntry = function(entry) {
  return new Promise(function(resolve, reject) {
    if (entry.isDirectory) {
      entry.removeRecursively(resolve, wrm.util.fs._tofileErrorReject(reject));
    } else {
      entry.remove(resolve, wrm.util.fs._tofileErrorReject(reject));
    }
  });
};

/**
 * @internal
 * @param {string} path
 * @return {!Promise<!FileEntry>}
 */
wrm.util.fs.lookupFileEntry = function(path) {
  return wrm.util.fs._lookupFileSystemEntry(path).then(function(entry) {
    if (entry.isFile) {
      return entry;
    }
    throw new Error("Not a file: " + path);
  });
};

/**
 * @internal
 * @param {string} path
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.util.fs.lookupDirectoryEntry = function(path) {
  return wrm.util.fs._lookupFileSystemEntry(path).then(function(entry) {
    if (entry.isDirectory) {
      return entry;
    }
    throw new Error("Not a directory: " + path);
  });
};

/**
 * @private
 * @param {string} path
 * @return {!Promise<!Entry>}
 */
wrm.util.fs._lookupFileSystemEntry = function(path) {
  return new Promise(function(resolve, reject) {
    
    /*
     * Schedule a timeout, since the file plugin may have problem accessing the file system, especially during startup
     */
    var timeoutOccurred = false;
    var timeoutHandle = GLOBAL.setTimeout(function() {
      timeoutOccurred = true;
      reject(new Error("Access to path '" + path + "' timed out"));
    }, 2E3);
    
    /* Resolve the path */
    GLOBAL.resolveLocalFileSystemURL(path, function(entry) {
      if (!timeoutOccurred) {
        GLOBAL.clearTimeout(timeoutHandle);
        resolve(entry);
      }
    }, function(e) {
      e = wrm.util.fs._normalizeFileError(e);
      if (!timeoutOccurred) {
        GLOBAL.clearTimeout(timeoutHandle);
        reject(new Error("Error accessing path '" + path + "' (" + e.message + ")"));
      }
    });
  });
};

/**
 * @private
 * @param {function(?Error)} rejectFunction
 * @return {function(*)}
 */
wrm.util.fs._tofileErrorReject = function(rejectFunction) {
  return function(e) {
    return rejectFunction(wrm.util.fs._normalizeFileError(e));
  };
};

/**
 * @private
 * @param {?} error
 * @return {!Error}
 */
wrm.util.fs._normalizeFileError = function(error) {
  var code = error && error.code;
  if (typeof code !== "number") {
    code = 1E3;
  }
  
  var message = error && error.message;
  if (!message) {
    message = wrm.util.fs._ERROR_CODES[code];
  }
  if (!message) {
    message = "Unknown erorr (" + code + ")";
  }
  
  var e = new Error(message);
  e.code = code;
  return e;
};

/**
 * @private
 * @const
 * @type {!Array<string>}
 */
wrm.util.fs._ERROR_CODES = [null, "Not found", "Security error", "Aborted", "Not readable", "Encoding error", "No modification allowed", "Invalid state", "Syntax error", "Invalid modification", "Quota exceeded", "Type mismatch", "Path exists"];




//== wrm/core/AppStartupHandler.js ============================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractEventHandler
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.AppStartupHandler = function(descr, manager) {
  wrm.core.AbstractEventHandler.call(this, manager);
  
  /**
   * @private
   * @type {string}
   */
  this._homeId = descr["home"];
  
  /**
   * @private
   * @type {boolean}
   */
  this._initializeDataEnabled = true;
  
  /**
   * @private
   * @type {boolean}
   */
  this._reAccess = descr["reAccess"];
  
  /** @private */
  this._log = manager.getPlatform().createLog("wrm.core.AppStartupHandler");
};

extendConstructor(wrm.core.AppStartupHandler, wrm.core.AbstractEventHandler);

/** @override */
wrm.core.AppStartupHandler.prototype.notify = function(event, state) {
  var Dialog = wrm.nav.Dialog;
  var thisHandler = this;
  var homeId = this._homeId;
  var manager = this.getManager();
  var log = this._log;
  
  var warm = !!event.getParameters()["warm"];
  var promise = Promise.resolve();
  
  if (!warm) {
    
    /* Clear temporary files */
    promise = promise.then(function() {
      return thisHandler._clearTempFiles();
    });
    
    /* Perform application updates */
    promise = promise.then(function() {
      return manager.getUpdateService().then(function(updateService) {
        return updateService.update(state);
      });
    });
    
    /* Initialize data if asked to */
    if (this._initializeDataEnabled) {
      promise = promise.then(function(route) {
        if (route) {
          return route;
        }
        return thisHandler._initializeData().then(function() {
          return route;
        }, function(e) {
          log.error("Error initializing database", e);
          return state.presentDialog(new Dialog("Error initializing database: " + e.message, Dialog.Flavor.NEGATIVE)).then(function() {
            throw e;
          });
        });
      });
    }
    
    /* Execute the startup hook functions */
    promise = promise.then(function(route) {
      if (route) {
        return route;
      }
      var autorun = wrm.util.obj.lookup("wrxHookAfterDataInit");
      if (typeof autorun === "function") {
        return Promise.resolve().then(function() {
          return (autorun)(manager);
        }).then(function() {
          return route;
        });
      }
      return route;
    });
    
    /* Access again if asked to */
    if (this._reAccess) {
      promise = promise.then(function(route) {
        if (route) {
          return route;
        }
        return manager.getSecurityService().then(function(securityService) {
          return securityService.accessAgain(false, state);
        });
      });
    }
    
    /* Do a "startup" data synchronization */
    promise = promise.then(function(route) {
      if (route) {
        return route;
      }
      return manager.getDataSyncService().then(function(dataSyncService) {
        return dataSyncService.synchronizeOnStartup(state);
      });
    });
  }
  
  /* Start running "periodical" data synchronizations */
  promise = promise.then(function(route) {
    if (route) {
      return route;
    }
    return manager.getDataSyncService().then(function(dataSyncService) {
      return dataSyncService.startPeriodicalSynchronization(state).then(function() {
        return route;
      });
    });
  });
  
  /* If not routing for other reasons, route to the home element; in warm mode, only a stationary route should happen */
  return promise.then(function(route) {
    if (warm) {
      if (DEBUG && !!route) {
        throw new Error("Non-home route suppressed by warm startup");
      }
      return wrm.nav.Route.toNowhere();
    }
    return route || wrm.nav.Route.toService(homeId);
  });
};

/**
 * @private
 * @return {!Promise}
 */
wrm.core.AppStartupHandler.prototype._clearTempFiles = function() {
  var log = this._log;
  return wrm.util.fs.clearTempFiles().then(undefined, function(e) {
    log.warn("Error clearing temporary files", e);
  });
};

/**
 * @private
 * @return {!Promise}
 */
wrm.core.AppStartupHandler.prototype._initializeData = function() {
  var thisService = this;
  var mgr = this.getManager();
  var promise = Promise.all([mgr.getDataService(), mgr.getConfigurationObject("initialData")]).then(function(arr) {
    var dataService = arr[0];
    var data = arr[1];
    
    /* Clear the database then insert the new data */
    return thisService._clearData(dataService, data).then(function() {
      return thisService._insertData(dataService, data);
    }).then(function() {
      return undefined;
    });
  });
  
  return promise;
};

/**
 * @private
 * @param {!wrm.data.DataService} dataService
 * @param {!Object<string,?>} entityNames
 * @return {!Promise}
 */
wrm.core.AppStartupHandler.prototype._clearData = function(dataService, entityNames) {
  return dataService.execute(function(d) {
    
    /* Delete (in parallel) all instances of every entity whose name is in the set */
    return Promise.all(dataService.getMetadata().getEntities().map(function(entity) {
      if (entity.getServerName()) {
        return Promise.resolve();
      }
      if (!entityNames[entity.getName()]) {
        return Promise.resolve();
      }
      
      return d["delete"](entity.getId());
    }));
  });
};

/**
 * @private
 * @param {!wrm.data.DataService} dataService
 * @param {!Object} data
 * @return {!Promise}
 */
wrm.core.AppStartupHandler.prototype._insertData = function(dataService, data) {
  return dataService.execute(function(d) {
    
    /* Populate (sequentially) all entities for which data is available */
    return dataService.getMetadata().getEntities().reduce(function(chain, entity) {
      if (entity.getServerName()) {
        return chain;
      }
      var records = data[entity.getName()];
      if (!records) {
        return chain;
      }
      
      /* Transform records into valid insert objects */
      var properties = entity.getProperties();
      var insertObjects = records.map(function(record) {
        var obj = {};
        properties.forEach(function(property) {
          var value = record[property.getName()];
          if (value !== undefined) {
            obj[property.getId()] = value;
          }
        });
        return obj;
      });
      
      return chain.then(function() {
        return d.insert(entity.getId(), insertObjects);
      });
    }, Promise.resolve());
  });
};




//== wrm/core/BackEventHandler.js =============================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractEventHandler
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.BackEventHandler = function(descr, manager) {
  wrm.core.AbstractEventHandler.call(this, manager);
  
  /**
   * @private
   * @type {string}
   */
  this._homeId = descr["home"];
  
  /* Build a set of all home-like panels */
  var homeLikePanelIds = {};
  angular.forEach(descr["homeLikePanels"] ? descr["homeLikePanels"].split("|") : [], function(panelId) {
    homeLikePanelIds[panelId] = true;
  });
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._homeLikePanelIds = homeLikePanelIds;
  
  /** @private */
  this._backFlow = new wrm.core.BackEventHandler._Flow;
};

extendConstructor(wrm.core.BackEventHandler, wrm.core.AbstractEventHandler);

/** @override */
wrm.core.BackEventHandler.prototype.notify = function(event, state) {
  
  /* Propagate the back navigation flow */
  this._backFlow.propagate({}, state);
  
  return this._createBackRoute(event);
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @return {!wrm.nav.Route}
 */
wrm.core.BackEventHandler.prototype._createBackRoute = function(event) {
  var routes = [];
  
  /* First option: route BACK */
  routes.push(wrm.nav.Route.toBack());
  
  /* Second options: route to HOME or EXIT (in already at one of the home-like panels) */
  var targetId = event.getTarget() && event.getTarget().getId();
  if (targetId && this._homeLikePanelIds[targetId] === true) {
    routes.push(wrm.nav.Route.toExit());
  } else {
    routes.push(wrm.nav.Route.toService(this._homeId));
  }
  
  return wrm.nav.Route.toFirstOf(routes);
};

/*
 * Flow
 */

/**
 * @private
 * @constructor
 * @extends wrm.nav.FlowImpl
 */
wrm.core.BackEventHandler._Flow = function() {
  wrm.nav.FlowImpl.call(this, {});
};

extendConstructor(wrm.core.BackEventHandler._Flow, wrm.nav.FlowImpl);

/** @override */
wrm.core.BackEventHandler._Flow.prototype.getPreserves = function() {
  return {};
};

/** @override */
wrm.core.BackEventHandler._Flow.prototype.toString = function() {
  return "\x3cjump to back\x3e";
};




//== wrm/core/EventContext.js =================================================


/**
 * @constructor
 */
wrm.core.EventContext = function() {
};

/** @override */
wrm.core.EventContext.prototype.toString = function() {
  return "{}";
};




//== wrm/core/EventSubscribeContext.js ========================================



/**
 * @constructor
 * @extends wrm.core.EventContext
 * @param {function(!Object<string,*>=):!Promise} notifierFunction
 * @param {function()} suppressStartupFunction
 */
wrm.core.EventSubscribeContext = function(notifierFunction, suppressStartupFunction) {
  wrm.core.EventContext.call(this);
  
  /** @private */
  this._notifierFunction = notifierFunction;
  
  /** @private */
  this._suppressStartupFunction = suppressStartupFunction;
};

extendConstructor(wrm.core.EventSubscribeContext, wrm.core.EventContext);

/**
 * @return {function(!Object<string,*>=):!Promise}
 */
wrm.core.EventSubscribeContext.prototype.getNotifierFunction = function() {
  return this._notifierFunction;
};

/**
 * @return {undefined}
 */
wrm.core.EventSubscribeContext.prototype.suppressStartupNavigation = function() {
  this._suppressStartupFunction();
};




//== wrm/core/HomeEventHandler.js =============================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractEventHandler
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.HomeEventHandler = function(descr, manager) {
  wrm.core.AbstractEventHandler.call(this, manager);
  
  /**
   * @private
   * @type {string}
   */
  this._homeId = descr["home"];
};

extendConstructor(wrm.core.HomeEventHandler, wrm.core.AbstractEventHandler);

/** @override */
wrm.core.HomeEventHandler.prototype.notify = function(event, state) {
  
  /* Route to the home element */
  return wrm.nav.Route.toService(this._homeId);
};




//== wrm/nav/Route.js =========================================================


/**
 * @interface
 */
wrm.nav.Route = function() {
};

/**
 * @return {boolean}
 */
wrm.nav.Route.prototype.isStationary = function() {
};

/*
 * Factories
 */

/**
 * @return {!wrm.nav.ServiceRoute}
 */
wrm.nav.Route.toNowhere = function() {
  return wrm.nav.Route.toService();
};

/**
 * @param {string=} serviceId
 * @param {string=} gate
 * @return {!wrm.nav.ServiceRoute}
 */
wrm.nav.Route.toService = function(serviceId, gate) {
  return new wrm.nav.ServiceRoute(serviceId, gate);
};

/**
 * @return {!wrm.nav.VirtualRoute}
 */
wrm.nav.Route.toBack = function() {
  return new wrm.nav.VirtualRoute(wrm.nav.VirtualRoute.Type.BACK);
};

/**
 * @return {!wrm.nav.VirtualRoute}
 */
wrm.nav.Route.toExit = function() {
  return new wrm.nav.VirtualRoute(wrm.nav.VirtualRoute.Type.EXIT);
};

/**
 * @return {!wrm.nav.MultipleRoute}
 */
wrm.nav.Route.toFirstOf = function(routes) {
  return new wrm.nav.MultipleRoute(routes);
};




//== wrm/core/SynchronizationSuccessHandler.js ================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractEventHandler
 * @param {!wrm.core.Manager} manager
 */
wrm.core.SynchronizationSuccessHandler = function(manager) {
  wrm.core.AbstractEventHandler.call(this, manager);
};

extendConstructor(wrm.core.SynchronizationSuccessHandler, wrm.core.AbstractEventHandler);

/** @override */
wrm.core.SynchronizationSuccessHandler.prototype.notify = function(event, state) {
  
  /*
   * Handle with a stationary route, effectively doing nothing. In practice, the event is caught by a panel service and we only end
   * up here if a synchronization finishes while no panel is being displayed
   */
  return wrm.nav.Route.toNowhere();
};




//== wrm/core/TimerHandler.js =================================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractEventHandler
 * @param {!wrm.core.Manager} manager
 */
wrm.core.TimerHandler = function(manager) {
  wrm.core.AbstractEventHandler.call(this, manager);
  
  /**
   * @private
   * @type {!Object<string,function(!wrm.nav.State):(?wrm.nav.Route|!Promise<?wrm.nav.Route>)>}
   */
  this._callbacks = [];
  
  /** @private */
  this._nextHandle = 0;
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._runningCallbacks = {};
  
  /** @private */
  this._log = manager.getPlatform().createLog("wrm.core.TimerHandler");
};

extendConstructor(wrm.core.TimerHandler, wrm.core.AbstractEventHandler);

/** @override */
wrm.core.TimerHandler.prototype.notify = function(event, state) {
  var thisHandler = this;
  var log = this._log;
  
  /* Find the callback to run, also validating the specifier in the process */
  var handle = event.getSpecifier() || "";
  var callback = this._callbacks[handle];
  if (!callback) {
    log.debug("Ignoring unknown timer " + handle);
    return wrm.nav.Route.toNowhere();
  }
  
  /* Do not run the callback while an identical one is running */
  if (this._runningCallbacks[handle] === true) {
    log.debug("Skipping handling of timer " + handle + " while still in progress");
    return wrm.nav.Route.toNowhere();
  }
  
  /* Fire callback */
  return Promise.resolve().then(function() {
    thisHandler._runningCallbacks[handle] = true;
    return callback(state);
  }).then(function(route) {
    delete thisHandler._runningCallbacks[handle];
    return route || wrm.nav.Route.toNowhere();
  }, function(e) {
    delete thisHandler._runningCallbacks[handle];
    throw e;
  });
};

/**
 * @package
 * @param {function(!wrm.nav.State):(?wrm.nav.Route|!Promise<?wrm.nav.Route>)} callback
 * @param {number} interval
 * @param {!wrm.nav.State} state
 * @return {string}
 */
wrm.core.TimerHandler.prototype.registerTimer = function(callback, interval, state) {
  var handle = String(this._nextHandle++);
  this._callbacks[handle] = callback;
  state.startTimerEvents(handle, interval);
  return handle;
};

/**
 * @package
 * @param {string} handle
 * @param {!wrm.nav.State} state
 */
wrm.core.TimerHandler.prototype.unregisterTimer = function(handle, state) {
  delete this._callbacks[handle];
  state.stopTimerEvents(handle);
};




//== wrm/core/AppService.js ===================================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.nav.Notifiable
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.AppService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /* Create information objects for all plugin events */
  var eventInfos = this._createEventInfos(descr["events"]);
  
  /**
   * @private
   * @type {!Object<string,wrm.core.AppService._EventInfo>}
   */
  this._eventInfos = eventInfos.map;
  
  /**
   * @private
   * @type {!Array<wrm.core.AppService._EventInfo>}
   */
  this._eventInfosList = eventInfos.list;
  
  /**
   * @private
   * @type {!Object<string,!wrm.nav.Notifiable>}
   */
  this._builtinHandlers = {};
  
  /** @private */
  this._startupDone = false;
  
  /** @private */
  this._timerHandler = new wrm.core.TimerHandler(manager);
  
  /* Register built-in event handlers */
  this._builtinHandlers["AppResume"] = new wrm.core.AppResumeHandler(descr["resume"] || {}, manager);
  this._builtinHandlers["AppStartup"] = new wrm.core.AppStartupHandler(descr["startup"] || {}, manager);
  this._builtinHandlers["BackEvent"] = new wrm.core.BackEventHandler(descr["back"] || {}, manager);
  this._builtinHandlers["HomeEvent"] = new wrm.core.HomeEventHandler(descr["home"] || {}, manager);
  this._builtinHandlers["SynchronizationSuccess"] = new wrm.core.SynchronizationSuccessHandler(manager);
  this._builtinHandlers["Timer"] = this._timerHandler;
};

extendConstructor(wrm.core.AppService, wrm.core.AbstractService);

/**
 * @const
 * @type {string}
 */
wrm.core.AppService.ID = "_app";

/**
 * @private
 * @typedef {{eventId:string, type:string, dataFlows:!Array<!wrm.nav.Flow>, flow:?wrm.nav.NavFlow}}
 */
wrm.core.AppService._EventInfo;

/**
 * @private
 * @param {!Object} descr
 * @return {{map:!Object<string,!wrm.core.AppService._EventInfo>, list:!Array<wrm.core.AppService._EventInfo>}}
 */
wrm.core.AppService.prototype._createEventInfos = function(descr) {
  var result = {map:{}, list:[]};
  
  angular.forEach(descr, function(eventDescr, eventId) {
    var eventInfo = {eventId:eventId, type:eventDescr["type"], dataFlows:(eventDescr["dataFlows"] || []).map(function(dataFlowDescr) {
      return new wrm.nav.FlowImpl(dataFlowDescr);
    }), flow:eventDescr["flow"] ? new wrm.nav.NavFlowImpl(eventDescr["flow"]) : null};
    
    result.map[eventInfo.type + "." + eventInfo.eventId] = eventInfo;
    if (eventDescr["generic"] === true) {
      result.map[eventInfo.type] = eventInfo;
    }
    
    result.list.push(eventInfo);
  });
  
  return result;
};

/*
 * Notification
 */

/** @override */
wrm.core.AppService.prototype.getFence = function() {
  return null;
};

/** @override */
wrm.core.AppService.prototype.notify = function(event, state) {
  var thisAppService = this;
  var log = this.getLog();
  
  /* Suppress any non-startup event before the startup is done */
  var isStartupEvent = event.getType() === "AppStartup";
  if (!this._startupDone && !isStartupEvent) {
    log.warn("Suppressing event before startup", event);
    return wrm.nav.Route.toNowhere();
  }
  
  /* Handle built-in events using their handler */
  var builtinHandler = this._builtinHandlers[event.getType()];
  if (builtinHandler) {
    return Promise.resolve().then(function() {
      return builtinHandler.notify(event, state);
    }).then(function(route) {
      state.catchEvent(thisAppService, event);
      return thisAppService.getManager().getDataSyncService().then(function(dataSyncService) {
        dataSyncService.collectSuccessEvents(state);
        return route;
      });
    }).then(function(route) {
      
      /* Route immediately if the handler has routed to exit */
      if (route instanceof wrm.nav.VirtualRoute && route.getType() === wrm.nav.VirtualRoute.Type.EXIT) {
        return route;
      }
      
      /* After catching the special "startup" event, subscribe all event catchers */
      if (isStartupEvent) {
        thisAppService._startupDone = true;
        return thisAppService._subscribeEventCatchers(state).then(function(flags) {
          if (flags.suppressStartup) {
            log.debug("Suppressing startup route");
            return wrm.nav.Route.toNowhere();
          }
          return route;
        });
      }
      
      return route;
    });
  }
  
  /* Handle other events using a catcher */
  return thisAppService._handleEvent(event, state);
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<{suppressStartup:boolean}>}
 */
wrm.core.AppService.prototype._subscribeEventCatchers = function(state) {
  var thisAppService = this;
  
  /* Track request to suppress startup navigation */
  var suppressStartup = false;
  var suppressStartupFunction = function() {
    suppressStartup = true;
  };
  
  /* Subscribe all catchers */
  var promise = this._eventInfosList.reduce(function(chain, eventInfo) {
    return chain.then(function() {
      return thisAppService._subscribeEventCatcher(eventInfo, suppressStartupFunction, state);
    });
  }, Promise.resolve());
  
  return promise.then(function() {
    return {suppressStartup:suppressStartup};
  });
};

/**
 * @private
 * @param {wrm.core.AppService._EventInfo} eventInfo
 * @param {function()} suppressStartupFunction
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.AppService.prototype._subscribeEventCatcher = function(eventInfo, suppressStartupFunction, state) {
  var log = this.getLog();
  var eventId = eventInfo.eventId;
  
  /* Let the catcher subscribe to events */
  var context = this._getEventSubscribeContext(eventInfo, suppressStartupFunction, state);
  return this.getManager().getCatcherService(eventId).then(function(service) {
    log.debug("Subscribing for events at", service, "-", context);
    return Promise.resolve(service.subscribe(context));
  });
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @param {!wrm.nav.State} state
 * @return {?wrm.nav.Route|!Promise<?wrm.nav.Route>}
 */
wrm.core.AppService.prototype._handleEvent = function(event, state) {
  var thisAppService = this;
  var log = this.getLog();
  
  /* Extract information about the event; if event not known, bail out */
  var eventInfo = this._getEventInfo(event);
  if (!eventInfo) {
    return null;
  }
  var eventId = eventInfo.eventId;
  
  /* Let the catcher catch the event */
  var context = this._getEventCatchContext(eventInfo, state);
  var promise = this.getManager().getCatcherService(eventId).then(function(service) {
    log.debug("Catching at", service, "event", event, "-", context);
    return Promise.resolve(service.catchEvent(context, event)).then(function(output) {
      log.debug("Caught at", service, "-", output);
      state.catchEvent(service, event);
      return output;
    });
  }).then(function(output) {
    return thisAppService.getManager().getDataSyncService().then(function(dataSyncService) {
      dataSyncService.collectSuccessEvents(state);
      return output;
    });
  });
  
  /* Propagate the event data flows, then the main event flow */
  return promise.then(function(output) {
    thisAppService._propagateEventDataFlows(eventInfo, output, state);
    
    /* Navigate the event flow, if any; then, proceed with the flow target, or just stop */
    var eventFlow = thisAppService._createEventNavigationFlow((eventInfo));
    if (eventFlow) {
      log.debug("Following event flow", eventFlow);
      eventFlow.propagate(output, state);
      state.stepAhead(eventFlow);
      return wrm.nav.Route.toService(eventFlow.getTargetId());
    } else {
      log.debug("Following implicit flow");
      state.stepImplicitly();
      return wrm.nav.Route.toNowhere();
    }
  });
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @return {?wrm.core.AppService._EventInfo}
 */
wrm.core.AppService.prototype._getEventInfo = function(event) {
  
  /* Match specific, then generic (by name, then by type) */
  var eventInfo = this._eventInfos[event.getName()];
  if (!eventInfo) {
    eventInfo = this._eventInfos[event.getType()];
  }
  
  return eventInfo || null;
};

/**
 * @private
 * @param {!wrm.nav.Output} output
 * @param {!wrm.nav.State} state
 */
wrm.core.AppService.prototype._propagateEventDataFlows = function(eventInfo, output, state) {
  
  /* Propagate all data flows */
  eventInfo.dataFlows.forEach(function(dataFlow) {
    dataFlow.propagate(output, state);
  });
};

/**
 * @private
 * @param {wrm.core.AppService._EventInfo} eventInfo
 * @return {wrm.nav.NavFlow}
 */
wrm.core.AppService.prototype._createEventNavigationFlow = function(eventInfo) {
  return eventInfo.flow;
};

/**
 * @private
 * @param {!wrm.core.AppService._EventInfo} eventInfo
 * @param {function()} suppressStartupFunction
 * @param {!wrm.nav.State} state
 * @return {!wrm.core.EventSubscribeContext}
 */
wrm.core.AppService.prototype._getEventSubscribeContext = function(eventInfo, suppressStartupFunction, state) {
  var notifierFunction = state.getEventNotifier(eventInfo.type, eventInfo.eventId);
  return new wrm.core.EventSubscribeContext(notifierFunction, suppressStartupFunction);
};

/**
 * @private
 * @param {!wrm.core.AppService._EventInfo} eventInfo
 * @param {!wrm.nav.State} state
 * @return {!wrm.core.EventContext}
 */
wrm.core.AppService.prototype._getEventCatchContext = function(eventInfo, state) {
  return new wrm.core.EventContext;
};

/*
 * Timers
 */

/**
 * @param {function(!wrm.nav.State):(?wrm.nav.Route|!Promise<?wrm.nav.Route>)} callback
 * @param {number} interval
 * @param {!wrm.nav.State} state
 * @return {string}
 */
wrm.core.AppService.prototype.startTimer = function(callback, interval, state) {
  return this._timerHandler.registerTimer(callback, interval, state);
};

/**
 * @param {string} handle
 * @param {!wrm.nav.State} state
 */
wrm.core.AppService.prototype.stopTimer = function(handle, state) {
  this._timerHandler.unregisterTimer(handle, state);
};




//== wrm/core/AuthenticationError.js ==========================================


/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.core.AuthenticationError = makeCustomErrorConstructor("wrm.core.AuthenticationError");




//== wrm/core/AutoFlow.js =====================================================



/**
 * @package
 * @constructor
 * @extends wrm.nav.AbstractFlow
 * @implements wrm.nav.NavFlow
 * @param {!Object} descr
 * @param {!wrm.core.PanelService} panelService
 */
wrm.core.AutoFlow = function(descr, panelService) {
  wrm.nav.AbstractFlow.call(this, panelService.getId() + ".auto-link");
  
  /**
   * @private
   * @type {string}
   */
  this._panelId = panelService.getId();
  
  /**
   * @private
   * @type {Object<string,!Object<string,boolean>>}
   */
  this._preserves = descr["preserve"] ? this._createPreserves(descr["preserve"]) : null;
  
};

extendConstructor(wrm.core.AutoFlow, wrm.nav.AbstractFlow);

/**
 * @private
 * @param {string} preservesString
 * @return {!Object<string,!Object<string,boolean>>}
 */
wrm.core.AutoFlow.prototype._createPreserves = function(preservesString) {
  var result = {};
  
  /*
   * Extract parameters from the string and map their component-specific name to the component id that they refer to. Each parameter
   * is expected to be in the format "component:name"
   */
  angular.forEach(preservesString.split("|"), function(preserveId) {
    var param = wrm.core.parseParameter(preserveId);
    
    /* Map */
    var set = result[param.componentId];
    if (!set) {
      result[param.componentId] = set = {};
    }
    set[param.name] = true;
  });
  
  return result;
};

/**
 * @override
 * @protected
 */
wrm.core.AutoFlow.prototype.getBoundSourceId = function() {
  return this._panelId;
};

/**
 * @override
 * @protected
 */
wrm.core.AutoFlow.prototype.getBoundTargetId = function() {
  return this._panelId;
};

/** @override */
wrm.core.AutoFlow.prototype.getTargetId = function() {
  return this._panelId;
};

/**
 * @override
 * @protected
 */
wrm.core.AutoFlow.prototype.getPreserves = function() {
  return this._preserves;
};




//== wrm/core/BackEndUrlHandler.js ============================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractUpdateParticipant
 * @param {?string} currentUrl
 * @param {!wrm.Log} log
 */
wrm.core.BackEndUrlHandler = function(currentUrl, log) {
  wrm.core.AbstractUpdateParticipant.call(this);
  
  /** @private */
  this._currentUrl = wrm.core.BackEndUrlHandler._normalizeUrl(currentUrl);
  
  /** @private */
  this._log = log;
};

extendConstructor(wrm.core.BackEndUrlHandler, wrm.core.AbstractUpdateParticipant);

/*
 * Information access
 */

/**
 * @return {?string}
 */
wrm.core.BackEndUrlHandler.prototype.getUrl = function() {
  return this._currentUrl;
};

/*
 * Update logic
 */

/** @override */
wrm.core.BackEndUrlHandler.prototype.getRequiredParticipantIds = function() {
  return [wrm.data.DataService.UPDATE_ID];
};

/** @override */
wrm.core.BackEndUrlHandler.prototype.beginUpdate = function(context) {
  var URL_KEY = wrm.core.BackEndUrlHandler._ORIG_URL_SNAPSHOT_KEY;
  
  /*
   * The original URL is the saved one and will be null when a back-end is first introduced, including during the very first update
   * check. In order to support the update from pre-8.6 versions, we need to consider a null URL as being the same as the new one.
   */
  var snapshot = context.getStableSnapshot();
  var originalUrl = wrm.core.BackEndUrlHandler._normalizeUrl(snapshot.get(URL_KEY) || null);
  if (originalUrl === null) {
    originalUrl = this._currentUrl;
    snapshot.set(URL_KEY, String(originalUrl));
  }
  var currentUrl = this._currentUrl;
  var updating = originalUrl !== currentUrl;
  context.setInfo(({updating:updating, originalUrl:originalUrl, currentUrl:currentUrl}));
  if (!updating) {
    this._log.debug("No back-end change is needed");
    return;
  }
  
  /* From this point, working with the ORIGINAL URL */
  this._switchCurrentUrl(originalUrl);
};

/** @override */
wrm.core.BackEndUrlHandler.prototype.performReductionUpdate = function(context) {
  var info = (context.getInfo());
  if (!info.updating) {
    return;
  }
  
  /* From this point, working with the CURRENT URL */
  this._switchCurrentUrl(info.currentUrl);
};

/** @override */
wrm.core.BackEndUrlHandler.prototype.finishUpdate = function(context) {
  var URL_KEY = wrm.core.BackEndUrlHandler._ORIG_URL_SNAPSHOT_KEY;
  var info = (context.getInfo());
  
  /* If updating, it is now over: save the new url */
  if (info.updating) {
    var snapshot = context.getStableSnapshot();
    snapshot.set(URL_KEY, info.currentUrl || "");
  }
  
  /* From this point, the state is STABLE */
  return info.updating;
};

/**
 * @private
 * @param {?string} url
 */
wrm.core.BackEndUrlHandler.prototype._switchCurrentUrl = function(url) {
  if (url) {
    this._log.debug("Now using back-end", url);
  } else {
    this._log.debug("Now using no back-end");
  }
  this._currentUrl = url;
};

/**
 * @private
 * @typedef {{updating:boolean, originalUrl:?string, currentUrl:?string}}
 */
wrm.core.BackEndUrlHandler._UpdateInfo;

/**
 * @private
 * @const
 */
wrm.core.BackEndUrlHandler._ORIG_URL_SNAPSHOT_KEY = "url";

/*
 * Utilities
 */

/**
 * @private
 * @param {?string} url
 * @return {?string}
 */
wrm.core.BackEndUrlHandler._normalizeUrl = function(url) {
  
  /* Ensure to add a trailing slash */
  if (url && !/\/$/.test(url)) {
    url = url + "/";
  }
  
  return url;
};




//== wrm/core/ForbiddenError.js ===============================================


/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.core.ForbiddenError = makeCustomErrorConstructor("wrm.core.ForbiddenError");




//== wrm/core/NetworkError.js =================================================


/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.core.NetworkError = makeCustomErrorConstructor("wrm.core.NetworkError");




//== wrm/data/Comparable.js ===================================================

wrm.data = {};

/**
 * @interface
 */
wrm.data.Comparable = function() {
};

/**
 * @param {*} object
 * @return {number}
 */
wrm.data.Comparable.prototype.compareTo = ABSTRACT_METHOD;




//== wrm/data/TypedValue.js ===================================================


/**
 * @interface
 */
wrm.data.TypedValue = function() {
};

/**
 * @return {string}
 */
wrm.data.TypedValue.prototype.hashKey = ABSTRACT_METHOD;

/**
 * @param {!Object} object
 * @return {boolean}
 */
wrm.data.TypedValue.prototype.equals = ABSTRACT_METHOD;

/**
 * @return {!wrm.data.Type}
 */
wrm.data.TypedValue.prototype.getValueType = ABSTRACT_METHOD;




//== wrm/data/DateTime.js =====================================================



/**
 * @constructor
 * @implements wrm.data.Comparable
 * @implements wrm.data.TypedValue
 * @param {number} year
 * @param {number} month
 * @param {number} day
 * @param {number=} hours
 * @param {number=} minutes
 * @param {number=} seconds
 * @param {number=} milliseconds
 * @param {?number=} timeZoneOffset
 */
wrm.data.DateTime = function(year, month, day, hours, minutes, seconds, milliseconds, timeZoneOffset) {
  
  /* Construct the date */
  var date;
  if (typeof timeZoneOffset === "number") {
    var value = Date.UTC(year, month, day, hours || 0, minutes || 0, seconds || 0, milliseconds || 0);
    value -= timeZoneOffset * 60 * 1E3;
    date = new Date(value);
  } else {
    date = new Date(year, month, day, hours || 0, minutes || 0, seconds || 0, milliseconds || 0);
  }
  
  /**
   * @private
   * @type {!Date}
   */
  this._date = date;
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getYear = function() {
  return this._date.getFullYear();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getMonth = function() {
  return this._date.getMonth();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getDay = function() {
  return this._date.getDate();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getHours = function() {
  return this._date.getHours();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getMinutes = function() {
  return this._date.getMinutes();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getSeconds = function() {
  return this._date.getSeconds();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getMilliseconds = function() {
  return this._date.getMilliseconds();
};

/**
 * @return {number}
 */
wrm.data.DateTime.prototype.getTimezoneOffset = function() {
  return this._date.getTimezoneOffset();
};

/**
 * @return {!Date}
 */
wrm.data.DateTime.prototype.asDate = function() {
  return this._date;
};

/** @override */
wrm.data.DateTime.prototype.compareTo = function(object) {
  if (!(object instanceof wrm.data.DateTime)) {
    object = wrm.data.toTimestamp(object);
  }
  
  if (object === this) {
    return 0;
  }
  
  var left = this._date.valueOf();
  var right = object._date.valueOf();
  
  return left - right;
};

/** @override */
wrm.data.DateTime.prototype.hashKey = function() {
  return String(this._date.valueOf());
};

/** @override */
wrm.data.DateTime.prototype.equals = function(object) {
  if (!(object instanceof wrm.data.DateTime)) {
    return false;
  }
  if (object === this) {
    return true;
  }
  return this._date.valueOf() === object._date.valueOf();
};

/** @override */
wrm.data.DateTime.prototype.getValueType = function() {
  return wrm.data.Type.TIMESTAMP;
};

/** @override */
wrm.data.DateTime.prototype.toString = function() {
  var tzOffset = this.getTimezoneOffset();
  var tzAbsValue = Math.floor(Math.abs(tzOffset) / 60) * 100 + Math.floor(Math.abs(tzOffset) % 60);
  
  var s = ("0000" + this.getYear()).slice(-4);
  s += "-" + ("00" + (this.getMonth() + 1)).slice(-2);
  s += "-" + ("00" + this.getDay()).slice(-2);
  s += "T" + ("00" + this.getHours()).slice(-2);
  s += ":" + ("00" + this.getMinutes()).slice(-2);
  s += ":" + ("00" + this.getSeconds()).slice(-2);
  s += "." + ("000" + this.getMilliseconds()).slice(-3);
  s += (tzOffset < 0 ? "+" : "-") + ("0000" + tzAbsValue).slice(-4);
  return s;
};

/** @override */
wrm.data.DateTime.prototype.toJSON = function() {
  return this.toString();
};

/*
 * Factories
 */

/**
 * @return {!wrm.data.DateTime}
 */
wrm.data.DateTime.now = function() {
  return wrm.data.DateTime.fromDate(new Date);
};

/**
 * @param {string} s
 * @return {!wrm.data.DateTime}
 */
wrm.data.DateTime.fromString = function(s) {
  var regex = /^([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([0-9]|0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]|[0-9])(?::([0-5][0-9]|[0-9])(?:\.(\d{3}))?)?(Z|([+\-])([0-9][0-9]):?([0-5][0-9])?)?$/;
  var m = regex.exec(s);
  if (!m) {
    throw new Error("Invalid timestamp string: " + s);
  }
  
  var year = Number(m[1]);
  var month = Number(m[2]) - 1;
  var day = Number(m[3]);
  var hour = Number(m[4]);
  var minute = Number(m[5]);
  var second = Number(m[6] || "0");
  var millisecond = Number(m[7] || "0");
  var tzOffset = null;
  if (m[8] === "Z") {
    tzOffset = 0;
  } else {
    if (m[8]) {
      tzOffset = (m[9] === "-" ? -1 : +1) * (Number(m[10] || "0") * 60 + Number(m[11] || "0"));
    }
  }
  
  return new wrm.data.DateTime(year, month, day, hour, minute, second, millisecond, tzOffset);
};

/**
 * @param {number} timestamp
 * @return {!wrm.data.DateTime}
 */
wrm.data.DateTime.fromTimestamp = function(timestamp) {
  return wrm.data.DateTime.fromDate(new Date(timestamp));
};

/**
 * @param {!Date} date
 * @return {!wrm.data.DateTime}
 */
wrm.data.DateTime.fromDate = function(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  var day = date.getDate();
  var hour = date.getHours();
  var minute = date.getMinutes();
  var second = date.getSeconds();
  var millisecond = date.getMilliseconds();
  var tzOffset = -1 * date.getTimezoneOffset();
  
  return new wrm.data.DateTime(year, month, day, hour, minute, second, millisecond, tzOffset);
};




//== wrm/util/AsyncIterator.js ================================================


/**
 * @interface An iterator that returns values asynchronously.
 *            <p>
 *            If the data source changes between calls to {@link #next}, the promise is rejected with a
 *            {@link wrm.core.AsyncIterator.ConcurrencyError}.
 *            <p>
 *            The interface is inspired by the ES6 Iterator and the proposed AsyncIteartor interface.
 * @template T
 */
wrm.util.AsyncIterator = function() {
};

/**
 * @return {!Promise<{value: (T|undefined), done: boolean}>}
 */
wrm.util.AsyncIterator.prototype.next = function() {
};

/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.util.AsyncIterator.ConcurrencyError = makeCustomErrorConstructor("wrm.core.AsyncIterator.ConcurrencyError");

/*
 * Utilities
 */

/**
 * Iterates over the elements of an {@link wrm.util.AsyncIterator}, performing an operation on each one.
 * 
 * @template E
 * @param {!wrm.util.AsyncIterator<E>} iter Iterator to scan.
 * @param {function(E,number):(Promise<undefined>|undefined)} callback Function called for each step with the element and index.
 * @return {!Promise<undefined>} Promise of completing the iteration.
 */
wrm.util.AsyncIterator.forEach = function(iter, callback) {
  return wrm.util.AsyncIterator._forEachStep(iter, callback, 0);
};

/**
 * @private
 * @template E
 * @param {!wrm.util.AsyncIterator<E>} iter
 * @param {function(E,number):(Promise<undefined>|undefined)} callback
 * @param {number} index
 * @return {!Promise<undefined>}
 */
wrm.util.AsyncIterator._forEachStep = function(iter, callback, index) {
  return iter.next().then(function(res) {
    if (res.done) {
      return;
    }
    return Promise.resolve(callback(res.value, index)).then(function() {
      return wrm.util.AsyncIterator._forEachStep(iter, callback, index + 1);
    });
  });
};




//== wrm/core/BackEndService.js ===============================================



/**
 * Constructs a new service.
 * 
 * @constructor
 * @class Service acting as a client for the WebRatio Back End REST services.
 * @extends wrm.core.AbstractService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.BackEndService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /* Retrieve the currently configured base URL */
  var currentUrl = this.getDescriptorValue(descr, "baseUrl") || null;
  
  /** @private */
  this._urlHandler = new wrm.core.BackEndUrlHandler(currentUrl, this.getLog());
};

extendConstructor(wrm.core.BackEndService, wrm.core.AbstractService);

/** @override */
wrm.core.BackEndService.prototype.initialize = function() {
  var thisService = this;
  var manager = this.getManager();
  
  return Promise.all([manager.getUpdateService().then(function(updateService) {
    
    /* Register an update participant */
    updateService.registerParticipant(wrm.core.BackEndService.UPDATE_ID, thisService._urlHandler);
  })]);
};

/**
 * @const
 * @type {string}
 */
wrm.core.BackEndService.ID = "_backend";

/**
 * @const
 * @type {string}
 */
wrm.core.BackEndService.UPDATE_ID = "backend";

/**
 * Determines whether a back-end is expected to be available at some point.
 * 
 * @return {boolean} <code>true</code> if available.
 */
wrm.core.BackEndService.prototype.isAvailable = function() {
  return !!this._urlHandler.getUrl();
};

/**
 * Determines whether the back-end is currently reachable.
 * 
 * @returns {boolean} <code>true</code> if reachable.
 */
wrm.core.BackEndService.prototype.isReachable = function() {
  return navigator.connection.type !== Connection.NONE;
};

/*
 * User services
 */

/**
 * Logs in a user.
 * 
 * @param {string} username Username.
 * @param {string} password Password.
 * @return {!Promise<{serverKey:*, token:string, roles:!Array<string>, record:!Object<string,*>}>} Object containing:
 *         <ul>
 *         <li><code>token</code> - the granted authentication token, to use for subsequent operations;
 *         <li><code>roles</code> - the list of names of all granted roles;
 *         <li><code>record</code> - object containing user instance data.
 *         </ul>
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.AuthenticationErorr} (if the authentication fails) or {@link wrm.core.NetworkError} (if
 *         there are network issues).
 */
wrm.core.BackEndService.prototype.loginUser = function(username, password) {
  var thisService = this;
  
  return Promise.resolve().then(function() {
    return thisService._retrieveDeviceInfo();
  }).then(function(deviceInfo) {
    
    /* Prepare a block of data for the device */
    var deviceData = {};
    deviceData["deviceId"] = deviceInfo.id;
    deviceData["model"] = deviceInfo.model;
    deviceData["platform"] = deviceInfo.platform;
    deviceData["platformVersion"] = deviceInfo.platformVersion;
    deviceData["browser"] = deviceInfo.webEngineType;
    if (deviceInfo.notificationDeviceId) {
      deviceData["notificationDeviceId"] = deviceInfo.notificationDeviceId;
    }
    
    return thisService._makeRequest("POST", "users/login", {data:{"username":username, "password":password, "device":deviceData}, responseType:"json", errors:{400:wrm.core.AuthenticationError}, validator:function(data) {
      return typeof data["userOID"] !== "undefined" && typeof data["token"] === "string" && angular.isArray(data["roles"]);
    }, transformer:function(data) {
      var readAndDelete = wrm.core.BackEndService._readAndDelete;
      return {serverKey:readAndDelete(data, "userOID"), token:readAndDelete(data, "token"), roles:readAndDelete(data, "roles"), record:data};
    }});
  });
};

/**
 * Registers a new user.
 * 
 * @param {string} username Username of the new user.
 * @param {string} password Password of the new user.
 * @param {!Object} record Object containing the user instance data.
 * @return {!Promise<!Object<string,*>>} Object containing the <i>actual</i> data of the created user instance.
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.NetworkError} (if there are network issues).
 */
wrm.core.BackEndService.prototype.registerUser = function(username, password, record) {
  return this._makeRequest("POST", "users/register", {data:{"username":username, "password":password, "data":record}, responseType:"json"});
};

/**
 * Updates an existing user.
 * 
 * @param {string} token Authentication token.
 * @param {*} key Server key of the user to update.
 * @param {?string} oldPassword Old password to check for when changing the password or <code>null</code> if not changing the password.
 * @param {?string} newPassword New password to set on the user or <code>null</code> for keeping the old password.
 * @param {!Object} record Object containing the user instance data to change.
 * @return {!Promise<{token:?string, record:!Object<string,*>}>} Object containing:
 *         <ul>
 *         <li><code>record</code> - object containing the <i>actual</i> data of the updated user instance.
 *         </ul>
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NotFoundError} (if there is no user with the specified server key) or {@link wrm.core.NetworkError} (if
 *         there are network issues).
 */
wrm.core.BackEndService.prototype.updateUser = function(token, key, oldPassword, newPassword, record) {
  var data = {};
  if (newPassword) {
    data["oldPassword"] = oldPassword;
    data["newPassword"] = newPassword;
  }
  data["data"] = record;
  
  return this._makeRequest("PUT", "users/" + encodeURIComponent(String(key)), {authorization:token, data:data, responseType:"json", errors:{403:wrm.core.ForbiddenError, 404:wrm.core.NotFoundError}, transformer:function(data) {
    var readAndDelete = wrm.core.BackEndService._readAndDelete;
    return {record:data};
  }});
};

/*
 * Data services
 */

/**
 * Retrieves the data set of an entity, either in full or as changes after a point in time.
 * 
 * @param {string} token Authentication token.
 * @param {string} entityName Server name of the entity.
 * @param {?wrm.data.DateTime=} since Point in time from which to retrieve data. If <code>null</code> or not specified, everything is
 *            retrieved.
 * @return {!Promise<{timestamp:!wrm.data.DateTime, recordCount:number, recordPages:!wrm.util.AsyncIterator<!Array<!Object>>,
 *         deletedKeys:!Array<*>, keysHash:?number}>} Object containing:
 *         <ul>
 *         <li><code>timestamp</code> - the timestamp to which the returned data refer, according to server time;
 *         <li><code>recordCount</code> - total number of created/updated objects;
 *         <li><code>recordPages</code> - an iterator over pages of created/updated objects, each containing entity instance data;
 *         <li><code>deletedKeys</code> - the list of server keys of deleted objects;
 *         <li><code>keysHash</code> - the hash code of all current server keys of the entity or <code>null</code> if checking against
 *         an hash is not required.
 *         </ul>
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NetworkError} (if there are network issues).
 */
wrm.core.BackEndService.prototype.retrieveEntityData = function(token, entityName, since) {
  var $jscomp$this = this;
  return this._retrieveEntityDataPage(token, entityName, since || null, 0).then(function(firstPage) {
    
    /* Prepare an iterator for the first page and the subsequent ones */
    var pagesIter = new wrm.core.BackEndService._DataIterator(firstPage, function(pageIndex) {
      return $jscomp$this._retrieveEntityDataPage(token, entityName, since || null, pageIndex);
    });
    
    return {timestamp:firstPage.timestamp, recordCount:firstPage.totalCount, recordPages:pagesIter, deletedKeys:firstPage.deletedKeys, keysHash:firstPage.keysHash};
  });
};

/**
 * @private
 * @typedef {{ timestamp:!wrm.data.DateTime, records:!Array<!Object>, deletedKeys:!Array<*>, keysHash:?number, pageIndex: number,
 *          pageSize: number, totalCount: number }}
 */
wrm.core.BackEndService._DataPage;

/**
 * @private
 * @param {string} token
 * @param {string} entityName
 * @param {?wrm.data.DateTime} since
 * @param {number} pageIndex
 * @return {!Promise<wrm.core.BackEndService._DataPage>}
 */
wrm.core.BackEndService.prototype._retrieveEntityDataPage = function(token, entityName, since, pageIndex) {
  return this._makeRequest("GET", "data/" + encodeURIComponent(entityName), {headers:{"X-Props":"_SYNC_INFO"}, parameters:{"delta":since ? since.toString() : undefined, "page":pageIndex > 0 ? pageIndex + 1 : undefined}, authorization:token, responseType:"json", errors:{403:wrm.core.ForbiddenError}, validator:function(data) {
    return angular.isArray(data["data"]) && angular.isArray(data["deletedObjectIds"]) && typeof data["timestamp"] === "string";
  }, transformer:function(data) {
    return {timestamp:wrm.data.DateTime.fromString(data["timestamp"]), records:data["data"], deletedKeys:data["deletedObjectIds"], keysHash:data["checksum"] || null, pageIndex:data["page"] || 0, pageSize:data["pageSize"] || data["data"].length, totalCount:data["totalCount"] || data["data"].length};
  }});
};

/**
 * Retrieves the data of a single entity instance.
 * 
 * @param {string} token Authentication token.
 * @param {string} entityName Server name of the entity.
 * @param {*} key Server key of the instance to retrieve.
 * @return {!Promise<!Object>} Object containing the entity instance data or <code>null</code> if the instance does not exist.
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NotFoundError} (if there is no object with the specified server key) or {@link wrm.core.NetworkError} (if
 *         there are network issues).
 */
wrm.core.BackEndService.prototype.retrieveEntityInstanceData = function(token, entityName, key) {
  return this._makeRequest("GET", "data/" + encodeURIComponent(entityName) + "/" + encodeURIComponent(String(key)), {authorization:token, responseType:"json", errors:{403:wrm.core.ForbiddenError, 404:wrm.core.NotFoundError}, validator:function(data) {
    return angular.isArray(data["data"]) && data["data"].length === 1 && typeof data["timestamp"] === "string";
  }, transformer:function(data) {
    return data["data"][0];
  }});
};

/**
 * Retrieves all server keys of an entity.
 * 
 * @param {string} token Authentication token.
 * @param {string} entityName Server name of the entity.
 * @return {!Promise<!Array<*>>} List of server keys corresponding to valid instances at this time.
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NetworkError} (if there are network issues).
 */
wrm.core.BackEndService.prototype.retrieveEntityKeys = function(token, entityName) {
  return this._makeRequest("GET", "data/" + encodeURIComponent(entityName), {headers:{"X-Props":"_OBJECT_ID"}, authorization:token, responseType:"json", errors:{403:wrm.core.ForbiddenError}, validator:function(data) {
    return angular.isArray(data["objectIds"]);
  }, transformer:function(data) {
    return data["objectIds"];
  }});
};

/**
 * Creates a new entity instance.
 * 
 * @param {string} token Authentication token.
 * @param {string} entityName Server name of the entity.
 * @param {!Object} record Object containing the entity instance data.
 * @return {!Promise<!Object>} Object containing the <i>actual</i> data of the created entity instance.
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NetworkError} (if there are network issues).
 */
wrm.core.BackEndService.prototype.createEntityInstance = function(token, entityName, record) {
  return this._makeRequest("POST", "data/" + encodeURIComponent(entityName), {authorization:token, data:record, responseType:"json", errors:{403:wrm.core.ForbiddenError}});
};

/**
 * Updates an existing entity instance.
 * 
 * @param {string} token Authentication token.
 * @param {string} entityName Server name of the entity.
 * @param {*} key Server key of the instance to update.
 * @param {!Object} record Object containing the entity instance data to change.
 * @return {!Promise<!Object>} Object containing the <i>actual</i> data of the updated entity instance.
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NotFoundError} (if there is no object with the specified server key) or {@link wrm.core.NetworkError} (if
 *         there are network issues).
 */
wrm.core.BackEndService.prototype.updateEntityInstance = function(token, entityName, key, record) {
  return this._makeRequest("PUT", "data/" + encodeURIComponent(entityName) + "/" + encodeURIComponent(String(key)), {authorization:token, data:record, responseType:"json", errors:{403:wrm.core.ForbiddenError, 404:wrm.core.NotFoundError}});
};

/**
 * Deletes an entity instance.
 * 
 * @param {string} token Authentication token.
 * @param {string} entityName Server name of the entity.
 * @param {*} key Server key of the instance to delete.
 * @return {!Promise} No result.
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NetworkError} (if there are network issues).
 */
wrm.core.BackEndService.prototype.deleteEntityInstance = function(token, entityName, key) {
  return this._makeRequest("DELETE", "data/" + encodeURIComponent(entityName) + "/" + encodeURIComponent(String(key)), {authorization:token, responseType:"json", errors:{204:null, 404:null}});
};

/**
 * Downloads a file attached to an entity instance attribute.
 * 
 * @param {string} token Authentication token.
 * @param {string} fileId Identifier of the file. It also uniquely identifies the instance and attribute from which the file is
 *            downloaded.
 * @return {!Promise<{buffer:!ArrayBuffer, contentType:?string, fileName:?string}>} File data and metadata, as an object containing:
 *         <ul>
 *         <li><code>buffer</code> - a buffer containing the actual bytes;
 *         <li><code>contentType</code> - content type describing the binary content or <code>null</code> if not available;
 *         <li><code>fileName</code> - logical name of the file or <code>null</code> if not available.
 *         </ul>
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NotFoundError} (if there is no file with the specified identifier) or {@link wrm.core.NetworkError} (if
 *         there are network issues).
 */
wrm.core.BackEndService.prototype.downloadFile = function(token, fileId) {
  return this._makeRequest("GET", "files/download/" + encodeURIComponent(fileId), {authorization:token, responseType:"arraybuffer", errors:{403:wrm.core.ForbiddenError, 404:wrm.core.NotFoundError}, validator:function(data) {
    return data instanceof ArrayBuffer || typeof data["byteLength"] === "number";
  }, transformer:function(data, headers) {
    
    /* Extract content type from Content-Type header */
    var contentType = headers["content-type"];
    
    /* Extract filename from Content-Disposition header */
    var m = /\bfilename\s*=\s*(.+?)\s*(?:;.*)?$/.exec(headers["content-disposition"]);
    var fileName = m && m[1] || null;
    
    return {buffer:data, contentType:contentType, fileName:fileName};
  }});
};

/**
 * Uploads a file, putting it in place of the one attached to an entity instance attribute.
 * 
 * @param {string} token Authentication token.
 * @param {string} fileId Identifier of the file. It also uniquely identifies the instance and attribute to which the file is uploaded.
 * @param {{buffer:!ArrayBuffer, contentType:(string|undefined), fileName:(string|undefined)}} data File data and metadata, as an
 *            object containing:
 *            <ul>
 *            <li><code>buffer</code> - a buffer containing the actual bytes;
 *            <li><code>contentType</code> - content type describing the binary content or <code>null</code> if not available;
 *            <li><code>fileName</code> - logical name of the file or <code>null</code> if not available.
 *            </ul>
 * @return {!Promise<string>} New identifier representing the file <i>after</i> the upload. This should be considered the identifier to
 *         use for referring to the uploaded file in the future (for getting or replacing it).
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid) or
 *         {@link wrm.core.NotFoundError} (if there is no file with the specified identifier) or {@link wrm.core.NetworkError} (if
 *         there are network issues).
 */
wrm.core.BackEndService.prototype.uploadFile = function(token, fileId, data) {
  return this._makeRequest("POST", "files/upload/" + encodeURIComponent(fileId), {parameters:{"name":data.fileName ? data.fileName : undefined}, headers:{"Content-Type":data.contentType || undefined}, authorization:token, data:data.buffer, responseType:"json", errors:{403:wrm.core.ForbiddenError, 404:wrm.core.NotFoundError}, validator:function(data) {
    return typeof data["blobId"] === "string";
  }, transformer:function(data) {
    return data["blobId"];
  }});
};

/*
 * Low-level request handling
 */

/**
 * Makes a request to the back-end.
 * 
 * @private
 * @template T
 * @param {string} method
 * @param {string} path
 * @param {{parameters:(!Object|undefined), headers:(!Object|undefined), authorization:(string|undefined),
 *            responseType:(string|undefined), data:(!Object|undefined),
 *            errors:(!Object<number,function(new:Error,string)>|*|undefined), validator:(function(?):boolean|undefined),
 *            transformer:(function(?,!Object<string,string>):T|undefined)}} options
 * @return {!Promise<T>}
 * @throws {!Error} if an error occurs before the request.
 */
wrm.core.BackEndService.prototype._makeRequest = function(method, path, options) {
  var log = this.getLog();
  
  /* Not possible if the service is not available */
  var baseUrl = this._urlHandler.getUrl();
  if (!baseUrl) {
    throw new Error("The back-end service is not available");
  }
  
  /* Append parameters to the path */
  if (options.parameters) {
    path += this._buildQueryString(options.parameters);
  }
  
  log.debug("Invoking", method, path);
  
  /* Prepare headers */
  var headers = {};
  if (options.headers) {
    angular.extend(headers, options.headers);
  }
  if (options.authorization) {
    headers["Authorization"] = options.authorization;
  }
  
  /* Prepare the request configuration */
  var config = {method:method, url:baseUrl + path, headers:headers, responseType:options.responseType || ""};
  
  /* Include request data */
  if (options.data && options.data instanceof ArrayBuffer) {
    config.data = wrm.core.BackEndService._buildBinaryData(options.data);
    config.transformRequest = [];
  } else {
    config.data = options.data;
  }
  
  /* Make the request */
  var promise = this.getManager().getPlatform().makeHttpRequest(config);
  
  /* Function for handling the response */
  function handleResponse(response) {
    var data = response.data;
    var statusCode = response.status;
    
    /* Set an error message and class on request failure or on receiving invalid data */
    var errorMessage = null;
    var errorClass = undefined;
    if (statusCode < 200 || statusCode >= 400) {
      var serverErrorMessage = data && data["error-message"] || response.statusText;
      if (serverErrorMessage) {
        errorMessage = serverErrorMessage;
      } else {
        errorMessage = "Network error (status " + statusCode + ")";
        errorClass = wrm.core.NetworkError;
      }
    } else {
      if (!data) {
        errorMessage = "Received malformed response from back-end";
      } else {
        if (options.validator && !options.validator(data)) {
          errorMessage = "Received invalid response from back-end";
        }
      }
    }
    
    /* If there was a problem, return an appropriate error object or throw an appropriate error */
    if (errorMessage || errorClass) {
      var errorResult = errorClass || options.errors && options.errors[statusCode];
      if (errorResult === undefined) {
        errorResult = Error;
      }
      if (typeof errorResult !== "function") {
        return errorResult;
      }
      throw new errorResult(errorMessage || "");
    }
    
    /* Transform the result data */
    if (options.transformer) {
      data = options.transformer(data, response.headers());
    }
    
    return data;
  }
  
  return promise.then(handleResponse, handleResponse);
};

/**
 * @private
 * @param {!Object} parameters
 * @return {string}
 */
wrm.core.BackEndService.prototype._buildQueryString = function(parameters) {
  var parts = [];
  Object.keys(parameters).forEach(function(paramName) {
    var paramValue = parameters[paramName];
    if (paramValue !== undefined) {
      parts.push(encodeURIComponent(paramName) + "\x3d" + encodeURIComponent(paramValue));
    }
  });
  return parts.length > 0 ? "?" + parts.join("\x26") : "";
};

/**
 * @private
 * @param {!ArrayBuffer} buffer
 * @return {!Object}
 */
wrm.core.BackEndService._buildBinaryData = function(buffer) {
  
  /*
   * The new XHR2 specification mandates the use of an ARRAY BUFFER VIEW (e.g. a Uint8Array). Older platform do not support it and
   * still require a bare ArrayBuffer instead. As an added problem, the Blink engine has deprecated the use of bare ArrayBuffer and
   * so it is not future-proof to use it there. As a compromise, use ArrayBuffer on all platforms and the views only when sure that
   * we are using a newer Blink. Unfortunately this requires AGENT detection, since the XHR behavior cannot be feature-detected.
   */
  var chromeVersionMatch = /\bChrome\/(\d+)\./.exec(GLOBAL.navigator.userAgent);
  var useBufferView = chromeVersionMatch && Number(chromeVersionMatch[1]) >= 30;
  
  var impl;
  if (useBufferView) {
    
    /* Implementation using array buffer views (new spec) */
    impl = function(buffer) {
      return new Uint8Array(buffer);
    };
    
  } else {
    
    /* Implementation using a bare ArrayBuffer (old spec) */
    impl = function(buffer) {
      return buffer;
    };
    
  }
  
  wrm.core.BackEndService._buildBinaryData = impl;
  return impl(buffer);
};

/*
 * Data iterator
 */

/**
 * @private
 * @constructor
 * @class Asynchronous iterator over data returned by the back end as multiple pages.
 * @implements {wrm.util.AsyncIterator<!Array<!Object>>}
 * @param {wrm.core.BackEndService._DataPage} firstPage
 * @param {function(number):(Promise<wrm.core.BackEndService._DataPage>)} pageFetcher
 */
wrm.core.BackEndService._DataIterator = function(firstPage, pageFetcher) {
  
  /**
   * @private
   * @const
   */
  this._pageSize = firstPage.pageSize;
  
  /* State that changes during iteration */
  
  /** @private */
  this._pageIndex = 0;
  
  /** @private */
  this._pageFetcher = pageFetcher;
  
  /** @private */
  this._totalCount = firstPage.totalCount;
  
  /** @private {?wrm.core.BackEndService._DataPage} */
  this._pendingFirstPage = firstPage;
};

/**
 * @override
 * @return {!Promise<{value: (!Array<!Object>|undefined), done: boolean}>}
 */
wrm.core.BackEndService._DataIterator.prototype.next = function() {
  var $jscomp$this = this;
  
  /* Emit the first page if it is still pending */
  if (this._pendingFirstPage) {
    var firstPage = this._pendingFirstPage;
    this._pendingFirstPage = null;
    return Promise.resolve(({value:firstPage.records, done:false}));
  }
  
  /* If there are no more pages expected, end iteration */
  if (this._pageSize * (this._pageIndex + 1) >= this._totalCount) {
    return Promise.resolve(({value:undefined, done:true}));
  }
  
  /* Fetch the next page */
  return this._pageFetcher(++this._pageIndex).then(function(page) {
    if ($jscomp$this._isSourceChanged(page)) {
      throw new wrm.util.AsyncIterator.ConcurrencyError("Data changed while requesting pages");
    }
    $jscomp$this._totalCount = page.totalCount;
    return {value:page.records, done:false};
  });
};

/**
 * @private
 * @param {wrm.core.BackEndService._DataPage} page
 * @return {boolean}
 */
wrm.core.BackEndService._DataIterator.prototype._isSourceChanged = function(page) {
  
  /*
   * As a trade off, we are not throwing an error when some of the response metadata change.
   * 
   * - The DELETED KEYS can only grow. If we miss a new one, it will be present in the next synchronization episode and the
   * corresponding object will be eventually deleted anyway.
   * 
   * - The KEYS HASH can change, causing it to mismatch the one computed from the existing keys or, conversely, to start matching. It
   * it becomes mismatched, the synchronization would compare all object ids, with only a little performance penalty. If it becomes
   * matched (extremely unlikely), the synchronization may not immediately catch objects going in/out of scope, but they would be
   * caught during the next synchronization episode.
   * 
   * The only value that must never change is PAGE SIZE, since it disrupts the iteration cursor. Note however that since it is a
   * server configuration it is not expected to change without putting the server offline.
   */
  if (this._pageSize !== page.pageSize) {
    return true;
  }
  
  return false;
};

/*
 * Utilities
 */

/**
 * @private
 * @return {!Promise<{id:string, model:string, platform:string, platformVersion:string, webEngineType:string,
 *         notificationDeviceId:?string}>}
 */
wrm.core.BackEndService.prototype._retrieveDeviceInfo = function() {
  var platform = this.getManager().getPlatform();
  return platform.getNotificationDeviceId().then(function(notificationDeviceId) {
    return {id:platform.getDeviceId(), model:platform.getDeviceModel(), platform:platform.getDevicePlatform(), platformVersion:platform.getDevicePlatformVersion(), webEngineType:platform.getWebEngineType(), notificationDeviceId:notificationDeviceId};
  });
};

/**
 * @private
 * @param {!Object<string,?>} obj
 * @param {string} property
 * @return {?}
 */
wrm.core.BackEndService._readAndDelete = function(obj, property) {
  var result = obj[property];
  delete obj[property];
  return result;
};




//== wrm/core/ComponentContext.js =============================================


/**
 * @constructor
 * @param {!wrm.nav.Input} input
 */
wrm.core.ComponentContext = function(input) {
  
  /** @private */
  this._input = input;
};

/**
 * @return {!wrm.nav.Input}
 */
wrm.core.ComponentContext.prototype.getInput = function() {
  return this._input;
};

/** @override */
wrm.core.ComponentContext.prototype.toString = function() {
  return JSON.stringify(this._input);
};




//== wrm/core/DescriptorLoader.js =============================================


/**
 * @interface
 */
wrm.core.DescriptorLoader = function() {
};

/**
 * @param {string} id
 * @return {!Promise<Object>}
 */
wrm.core.DescriptorLoader.prototype.loadConfigurationObject = ABSTRACT_METHOD;

/**
 * @param {string} id
 * @return {!Promise<Object<string,string>>}
 */
wrm.core.DescriptorLoader.prototype.loadConfigurationProperties = ABSTRACT_METHOD;

/**
 * @param {string} id
 * @return {!Promise<Object>}
 */
wrm.core.DescriptorLoader.prototype.loadServiceDescriptor = ABSTRACT_METHOD;




//== wrm/core/ExecutableOperation.js ==========================================



/**
 * @constructor
 * @implements wrm.nav.Executable
 * @param {!wrm.OperationService} operationService
 */
wrm.core.ExecutableOperation = function(operationService) {
  
  /**
   * @private
   * @type {!wrm.OperationService}
   */
  this._operationService = operationService;
};

/** @override */
wrm.core.ExecutableOperation.prototype.execute = function(input, state) {
  var context = state.createOperationContext(this._operationService.getId());
  return this._operationService.executeOperation(context);
};

/** @override */
wrm.core.ExecutableOperation.prototype.toString = function() {
  return this._operationService.toString();
};




//== wrm/core/FormInfo.js =====================================================


/**
 * @constructor
 * @param {!Object<string,!wrm.form.FormSubService>} formSubServices
 */
wrm.core.FormInfo = function(formSubServices) {
  
  /** @private */
  this._formSubServices = formSubServices;
};

/**
 * @param {string} componentId
 * @param {string} viewPropertyRef
 * @return {?string}
 */
wrm.core.FormInfo.prototype.resolvePropertyFromView = function(componentId, viewPropertyRef) {
  return this._getFormSubService(componentId).resolvePropertyFromView(viewPropertyRef);
};

/**
 * @param {string} componentId
 * @param {string} propertyName
 * @return {?wrm.data.Type}
 */
wrm.core.FormInfo.prototype.getPropertyType = function(componentId, propertyName) {
  return this._getFormSubService(componentId).getPropertyType(propertyName);
};

/**
 * @private
 * @param {string} componentId
 * @return {!wrm.form.FormSubService}
 */
wrm.core.FormInfo.prototype._getFormSubService = function(componentId) {
  var formSubService = this._formSubServices[componentId];
  if (!formSubService) {
    throw new Error("Component '" + componentId + "' is not associated with a form");
  }
  return formSubService;
};




//== wrm/nav/Environ.js =======================================================


/**
 * @interface
 */
wrm.nav.Environ = function() {
};

/**
 * @param {string} primaryPanelId
 * @param {string} viewComponentId
 * @return {?wrm.core.View}
 */
wrm.nav.Environ.prototype.retrieveView = ABSTRACT_METHOD;

/**
 * @param {!Object} object
 * @param {*} trackingId
 */
wrm.nav.Environ.prototype.markObjectForViewTracking = ABSTRACT_METHOD;

/**
 * @param {string} primaryPanelId
 * @param {string} viewComponentId
 * @return {wrm.form.FormState}
 */
wrm.nav.Environ.prototype.retrieveFormState = ABSTRACT_METHOD;

/**
 * @param {!wrm.nav.Event} event
 * @return {!Promise}
 */
wrm.nav.Environ.prototype.handleEvent = ABSTRACT_METHOD;

/**
 * @param {string} primaryPanelId
 * @param {boolean} clearHistory
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Reuse}
 */
wrm.nav.Environ.prototype.enterPanel = ABSTRACT_METHOD;
/**
 * @param {string} specifier
 * @param {number} interval
 */
wrm.nav.Environ.prototype.startTimerEvents = ABSTRACT_METHOD;
/**
 * @param {string} specifier
 */
wrm.nav.Environ.prototype.stopTimerEvents = ABSTRACT_METHOD;

/**
 * @param {string} type
 * @param {?string=} specifier
 * @return {function(!Object.<string,*>=):!Promise}
 */
wrm.nav.Environ.prototype.retrieveEventNotifier = ABSTRACT_METHOD;

/**
 * @template R
 * @param {!wrm.nav.Dialog<R>} dialog
 * @return {!Promise<{value:R, data:!Object}>}
 */
wrm.nav.Environ.prototype.presentDialog = ABSTRACT_METHOD;

/**
 * @param {!wrm.nav.Progress} progress
 */
wrm.nav.Environ.prototype.reportProgress = ABSTRACT_METHOD;




//== wrm/core/InternalEnviron.js ==============================================



/**
 * @constructor
 * @implements wrm.nav.Environ
 */
wrm.core.InternalEnviron = function() {
};

/** @override */
wrm.core.InternalEnviron.prototype.retrieveView = function(primaryPanelId, viewComponentId) {
  return null;
};

/** @override */
wrm.core.InternalEnviron.prototype.markObjectForViewTracking = function(object, trackingId) {
};

/** @override */
wrm.core.InternalEnviron.prototype.retrieveFormState = function(primaryPanelId, viewComponentId) {
  return null;
};

/** @override */
wrm.core.InternalEnviron.prototype.handleEvent = function(event) {
  return Promise.reject(new Error("Cannot handle events in the current execution environment"));
};

/** @override */
wrm.core.InternalEnviron.prototype.enterPanel = function(primaryPanelId, clearHistory, state) {
};

/** @override */
wrm.core.InternalEnviron.prototype.presentDialog = function(dialog) {
  throw new Error("Cannot present dialogs in the current execution environment");
};

/** @override */
wrm.core.InternalEnviron.prototype.reportProgress = function(progress) {
};

/** @override */
wrm.core.InternalEnviron.prototype.startTimerEvents = function(specifier, interval) {
  throw new Error("Cannot manage timer events in the current execution environment");
};

/** @override */
wrm.core.InternalEnviron.prototype.stopTimerEvents = function(specifier) {
  throw new Error("Cannot manage timer events in the current execution environment");
};

/**
 * @override
 * @param {string} type
 * @param {?string=} specifier
 * @return {function(!Object<string,*>=):!Promise}
 */
wrm.core.InternalEnviron.prototype.retrieveEventNotifier = function(type, specifier) {
  throw new Error("Cannot notify events in the current execution environment");
};




//== wrm/core/NavigableThrower.js =============================================



/**
 * @constructor
 * @implements wrm.nav.Navigable
 * @param {!wrm.ThrowerService} throwerService
 */
wrm.core.NavigableThrower = function(throwerService) {
  
  /**
   * @private
   * @type {!wrm.ThrowerService}
   */
  this._throwerService = throwerService;
};

/** @override */
wrm.core.NavigableThrower.prototype.getFence = function() {
  return null;
};

/** @override */
wrm.core.NavigableThrower.prototype.navigate = function(gate, state) {
  
  /* Execute the thrower and get back the thrown event */
  var context = state.createComponentContext(this._throwerService.getId());
  var promise = Promise.resolve(this._throwerService.throwEvent(context));
  
  /* Dispatch the thrown event */
  promise = promise.then(function(event) {
    state.dispatchEvent(event);
    
    /* Step implicitly back to the start panel */
    state.stepImplicitly();
    return wrm.nav.Route.toService(state.getContextualStartPanelId() || undefined);
  });
  
  return promise;
};

/** @override */
wrm.core.NavigableThrower.prototype.toString = function() {
  return this._throwerService.toString();
};




//== wrm/core/UserInfo.js =====================================================


/**
 * Constructs a new set of user information.
 * 
 * @constructor
 * @class Full information about a user of the application, including its identity.
 * @param {string} username Username identifying the user.
 * @param {*} key Local key of the user on the application database.
 * @param {?*} serverKey Key of the user on the back-end or <code>null</code> if not known or not logged in.
 * @param {!Object<string,*>} properties Additional properties of the user profile, by property id.
 * @param {!Object<string,!Object<string,*>>} allRoleProperties Map of roles to which the user belongs, keyed by role name. Each role
 *            object contains property values by id.
 */
wrm.core.UserInfo = function(username, key, serverKey, properties, allRoleProperties) {
  
  /** @private */
  this._username = username;
  
  /** @private */
  this._serverKey = serverKey;
  
  /** @private */
  this._key = key;
  
  /** @private */
  this._properties = properties;
  
  /** @private */
  this._allRoleProperties = allRoleProperties;
};

/**
 * Gets the username that uniquely identifies the user.
 * 
 * @return {string} A string.
 */
wrm.core.UserInfo.prototype.getUsername = function() {
  return this._username;
};

/**
 * Gets the unique key of the user on the back-end server, if known.
 * 
 * @return {?*} A key value or <code>null</code> if not known or not logged in.
 */
wrm.core.UserInfo.prototype.getServerKey = function() {
  return this._serverKey;
};

/**
 * Gets the key of the user on the application database.
 * 
 * @return {*} A key value.
 */
wrm.core.UserInfo.prototype.getKey = function() {
  return this._key;
};

/**
 * Gets all additional properties tied to the user (profile information, etc.).
 * 
 * @return {!Object<string,*>} Values by property id.
 */
wrm.core.UserInfo.prototype.getProperties = function() {
  return this._properties;
};

/**
 * Gets the names of the roles to which the user belongs.
 * 
 * @return {!Array<string>} List of role names.
 */
wrm.core.UserInfo.prototype.getRoleNames = function() {
  return Object.keys(this._allRoleProperties);
};

/**
 * Gets the additional properties tied to one of the roles of the user.
 * 
 * @param {string} roleName Name of a role to which the user belongs.
 * @return {!Object<string,*>} Values by property id.
 */
wrm.core.UserInfo.prototype.getRoleProperties = function(roleName) {
  var properties = this._allRoleProperties[roleName];
  if (!properties) {
    throw new Error("User does not belong to role " + roleName);
  }
  return properties;
};




//== wrm/core/ServerStore.js ==================================================


/**
 * @internal
 * @interface
 */
wrm.core.ServerStore = function() {
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.core.ServerStore.prototype.getEntity = ABSTRACT_METHOD;

/**
 * @return {boolean}
 */
wrm.core.ServerStore.prototype.isServerAvailable = ABSTRACT_METHOD;

/**
 * @return {boolean}
 */
wrm.core.ServerStore.prototype.isServerReadable = ABSTRACT_METHOD;

/**
 * @param {string} token
 * @param {?wrm.data.DateTime=} since
 * @return {!Promise<{timestamp:!wrm.data.DateTime, recordCount:number, recordPages:!wrm.util.AsyncIterator<!Array<!Object>>,
 *         deletedKeys:!Array<*>, keysHash:?number}>}
 */
wrm.core.ServerStore.prototype.retrieveEntityData = ABSTRACT_METHOD;

/**
 * @param {string} token Authentication token.
 * @param {*} key Server key of the instance to retrieve.
 * @return {!Promise<!Object>}
 */
wrm.core.ServerStore.prototype.retrieveEntityInstanceData = ABSTRACT_METHOD;

/**
 * @param {string} token
 * @return {!Promise<!Array<*>>}
 */
wrm.core.ServerStore.prototype.retrieveEntityKeys = ABSTRACT_METHOD;

/**
 * @param {string} token
 * @param {!Object} record
 * @return {!Promise<!Object>}
 */
wrm.core.ServerStore.prototype.createEntityInstance = ABSTRACT_METHOD;

/**
 * @param {string} token
 * @param {*} key
 * @param {!Object} record
 * @return {!Promise<!Object>}
 */
wrm.core.ServerStore.prototype.updateEntityInstance = ABSTRACT_METHOD;

/**
 * @param {string} token
 * @param {*} key
 * @return {!Promise}
 */
wrm.core.ServerStore.prototype.deleteEntityInstance = ABSTRACT_METHOD;




//== wrm/util/ArrayAsyncIterator.js ===========================================



/**
 * Constructs a new array-based asynchronous iterator.
 * 
 * @internal
 * @constructor
 * @class Asynchronous iterator based on an array that is available synchronously.
 * @template E
 * @implements {wrm.util.AsyncIterator<E>}
 * @param {!Array<E>} elements
 */
wrm.util.ArrayAsyncIterator = function(elements) {
  
  /** @private */
  this._elements = elements;
  
  /** @private */
  this._nextElementIndex = 0;
};

/** @override */
wrm.util.ArrayAsyncIterator.prototype.next = function() {
  
  /* Attempt to return the next element */
  if (this._nextElementIndex < this._elements.length) {
    var value = this._elements[this._nextElementIndex++];
    return (Promise.resolve({value:value, done:false}));
  }
  
  return (Promise.resolve({value:undefined, done:true}));
};




//== wrm/core/UserServerStore.js ==============================================



/**
 * Constructs a new service.
 * 
 * @internal
 * @constructor
 * @implements wrm.core.ServerStore
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.core.BackEndService} backEndService
 */
wrm.core.UserServerStore = function(entity, backEndService) {
  
  /** @private */
  this._entity = entity;
  
  /**
   * @private
   * @type {?string}
   */
  this._serverName = this._entity.getServerName();
  
  /**
   * @private
   * @type {Array<!Object>}
   */
  this._data = null;
};

/** @override */
wrm.core.UserServerStore.prototype.getEntity = function() {
  return this._entity;
};

/** @override */
wrm.core.UserServerStore.prototype.isServerAvailable = function() {
  return true;
};

/** @override */
wrm.core.UserServerStore.prototype.isServerReadable = function() {
  return this._data ? true : false;
};

/**
 * @return {?string}
 */
wrm.core.UserServerStore.prototype.isMappedUser = function() {
  return this._serverName;
};

/**
 * @param {!Object} data
 */
wrm.core.UserServerStore.prototype.setData = function(data) {
  if (this._data) {
    throw Error("Data already present");
  }
  this._data = [data];
};

/**
 * @return {undefined}
 */
wrm.core.UserServerStore.prototype.clearData = function() {
  if (!this._data) {
    throw Error("Data is already empty");
  }
  this._data = null;
};

/*
 * Data services
 */

/** @override */
wrm.core.UserServerStore.prototype.retrieveEntityData = function(token, since) {
  if (!this._data) {
    throw Error("Data should not be empty");
  }
  
  var result = this._data;
  this._data = null;
  
  return (Promise.resolve({timestamp:wrm.data.DateTime.now(), recordCount:result.length, recordPages:new wrm.util.ArrayAsyncIterator([result]), deletedKeys:[], keysHash:null}));
};

/** @override */
wrm.core.UserServerStore.prototype.retrieveEntityInstanceData = function(token, key) {
  return this._operationNotAllowed();
};

/** @override */
wrm.core.UserServerStore.prototype.retrieveEntityKeys = function(token) {
  return this._operationNotAllowed();
};

/** @override */
wrm.core.UserServerStore.prototype.createEntityInstance = function(token, record) {
  return this._operationNotAllowed();
};

/** @override */
wrm.core.UserServerStore.prototype.updateEntityInstance = function(token, key, record) {
  return this._operationNotAllowed();
};

/** @override */
wrm.core.UserServerStore.prototype.deleteEntityInstance = function(token, key) {
  return this._operationNotAllowed();
};

/**
 * @private
 */
wrm.core.UserServerStore.prototype._operationNotAllowed = function() {
  throw new Error("Operation not allowed");
};




//== wrm/core/VolatileHolder.js ===============================================


/**
 * @internal
 * @template T
 * @constructor
 * @param {!T} finalInstance
 */
wrm.core.VolatileHolder = function(finalInstance) {
  
  /** @private */
  this._finalInstance = finalInstance;
  
  /**
   * @private
   * @type {?T|undefined}
   */
  this._instance = undefined;
  
  /**
   * @private
   * @type {!Array<function(!T,boolean)>}
   */
  this._usersCallbacks = [];
};

/**
 * @param {?T} instance
 */
wrm.core.VolatileHolder.prototype.swap = function(instance) {
  if (this._instance === null) {
    throw new Error("Cannot swap away the final instance");
  }
  if (this._instance && implementsInterface(this._instance, wrm.core.VolatileHolder.Instance)) {
    this._instance.invalidate();
  }
  this._instance = instance;
  
  /* Notify all users */
  this._usersCallbacks.forEach(function(callback) {
    callback(this._instance || this._finalInstance, this._instance === null);
  }, this);
};

/**
 * @param {function(!T,boolean)} callback
 */
wrm.core.VolatileHolder.prototype.use = function(callback) {
  this._usersCallbacks.push(callback);
  
  /* Immediately notify */
  callback(this._instance || this._finalInstance, this._instance === null);
};

/*
 * Instance
 */

/**
 * @interface
 */
wrm.core.VolatileHolder.Instance = function() {
};

/**
 * @return {undefined}
 */
wrm.core.VolatileHolder.prototype.invalidate = function() {
};




//== wrm/data/Blob.js =========================================================



/**
 * @constructor
 * @implements wrm.data.TypedValue
 * @param {!File|!Blob|!Uint8Array|!ArrayBuffer} content
 * @param {string=} contentType
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 */
wrm.data.Blob = function(content, contentType, metadata) {
  
  /** @private */
  this._uniqueId = wrm.data.Blob._nextUniqueId++;
  
  var internalContent = null;
  if (content instanceof File) {
    internalContent = content;
  } else {
    internalContent = wrm.data.Blob["_constructBlob"](content, contentType);
  }
  
  /** @private */
  this._content = internalContent;
  
  /**
   * @private
   * @type {{fileName:(?string), contentSignature:(?string), availabilityStatus:(?wrm.data.AvailabilityStatus)}}
   */
  this._metadata = angular.extend({fileName:null, contentSignature:null, availabilityStatus:wrm.data.AvailabilityStatus.AVAILABLE}, metadata);
  
  /**
   * @private
   * @type {?string}
   */
  this._contentType = wrm.data.ContentType.retrieveBestContentType([this._content.type, contentType, this._retrieveContentType()]).getName();
  
  /**
   * @private
   * @type {?Promise<!FileEntry>}
   */
  this._externalFileEntry = null;
  
  /** @private */
  this._fileUrlUsages = 0;
  
  /** @private */
  this._fileUrl = null;
  
  /** @private */
  this._externalUrlUsages = 0;
};

/**
 * @private
 * @type {number}
 */
wrm.data.Blob._nextUniqueId = 0;

/**
 * @private
 * @param {!Blob|!Uint8Array|!ArrayBuffer} content
 * @param {string=} contentType
 * @return {!Blob}
 */
wrm.data.Blob["_constructBlob"] = function(content, contentType) {
  
  /* Perform some one-time feature detection */
  var blobCtorWithBufferViewSupported = function() {
    try {
      var testBlob = new Blob([new Uint8Array([65])]);
      return testBlob.size === 1;
    } catch (e) {
    }
    return false;
  }();
  var blobCtorSupported = function() {
    try {
      var testBlob = new Blob([(new Uint8Array([65])).buffer]);
      return testBlob.size === 1;
    } catch (e) {
    }
    return false;
  }();
  
  var BlobBuilder = GLOBAL.BlobBuilder || GLOBAL["WebKitBlobBuilder"];
  
  /* Choose the best implementation */
  var impl;
  if (blobCtorWithBufferViewSupported) {
    
    /* Implementation based on the soon-standard Blob constructor */
    impl = function(content, contentType) {
      if (contentType) {
        return new Blob([content], {type:contentType});
      } else {
        return new Blob([content]);
      }
    };
    
  } else {
    if (blobCtorSupported) {
      
      /* Implementation based on the Blob constructor, but not supporting array buffer views */
      impl = function(content, contentType) {
        
        /* Extract the underlying buffer */
        if (content.buffer) {
          content = content.buffer;
        }
        
        if (contentType) {
          return new Blob([content], {type:contentType});
        } else {
          return new Blob([content]);
        }
      };
      
    } else {
      if (BlobBuilder) {
        
        /* Implementation based on the deprecated BlobBuilder */
        impl = function(content, contentType) {
          
          /* Extract the underlying buffer (Safari does not handle buffer views) */
          if (content.buffer) {
            content = content.buffer;
          }
          
          var builder = new BlobBuilder;
          builder.append(content);
          if (contentType) {
            return builder.getBlob(contentType);
          } else {
            return builder.getBlob();
          }
        };
      } else {
        throw new Error("The device does not support BLOB handling");
      }
    }
  }
  
  wrm.data.Blob["_constructBlob"] = impl;
  return impl(content, contentType);
};

/**
 * @return {number}
 */
wrm.data.Blob.prototype.getUniqueId = function() {
  return this._uniqueId;
};

/**
 * @return {number}
 */
wrm.data.Blob.prototype.getSize = function() {
  return this._content.size;
};

/**
 * @return {?string}
 */
wrm.data.Blob.prototype.getContentType = function() {
  return this._contentType;
};

/**
 * @return {{fileName:(?string), contentSignature:(?string), availabilityStatus:(?wrm.data.AvailabilityStatus)}}
 */
wrm.data.Blob.prototype.getMetadata = function() {
  return this._metadata;
};

/**
 * @return {string}
 */
wrm.data.Blob.prototype.computeExternalFileName = function() {
  var fileName = this.getMetadata().fileName;
  if (fileName) {
    return fileName.replace(/ /g, "_");
  }
  
  /* No file name available in metadata: generate one with a correct suffix matching the type */
  var contentType = wrm.data.ContentType.lookup(this.getContentType(), "application/octet-stream");
  var suffix = contentType.getFileNameSuffix();
  return "file" + (suffix || "");
};

/**
 * @return {!Promise<!Uint8Array>}
 */
wrm.data.Blob.prototype.read = function() {
  var content = this._content;
  
  return new Promise(function(resolve, reject) {
    var reader = new FileReader;
    reader.onload = function() {
      var buffer = (reader.result);
      resolve(new Uint8Array(buffer));
    };
    reader.onerror = function(e) {
      reject(new Error("Blob read failed"));
    };
    reader.readAsArrayBuffer(content);
  });
};

/**
 * @return {!Promise<!Blob>}
 */
wrm.data.Blob.prototype.readBlob = function() {
  var contentType = this.getContentType() || undefined;
  return this.read().then(function(arrayBuffer) {
    var newBlob = wrm.data.Blob.fromBytes(arrayBuffer, contentType);
    return newBlob._content;
  });
};

/**
 * @return {!Promise<string>} url
 */
wrm.data.Blob.prototype.createObjectURL = function() {
  
  var URL = GLOBAL.URL || GLOBAL["webkitURL"];
  
  var impl = function() {
    if (this._isContentFile()) {
      if (this._fileUrlUsages === 0) {
        this._fileUrl = this._content["nativeURL"] + "?" + (new Date).valueOf();
      }
      this._fileUrlUsages++;
      return Promise.resolve(this._fileUrl);
    } else {
      return Promise.resolve(URL.createObjectURL(this._content));
    }
  };
  
  wrm.data.Blob.prototype.createObjectURL = impl;
  return impl.call(this);
};

/**
 * @param {string} url
 */
wrm.data.Blob.prototype.revokeObjectURL = function(url) {
  
  var URL = GLOBAL.URL || GLOBAL["webkitURL"];
  
  var impl = function(url) {
    if (this._isContentFile()) {
      this._fileUrlUsages--;
      if (this._fileUrlUsages === 0) {
        this._fileUrl = null;
      }
    } else {
      URL.revokeObjectURL(url);
    }
  };
  
  wrm.data.Blob.prototype.revokeObjectURL = impl;
  return impl.call(this, url);
};

/**
 * @return {!Promise<string>}
 */
wrm.data.Blob.prototype.createExternalURL = function() {
  var thisBlob = this;
  
  this._externalUrlUsages++;
  
  /* Create an external file if not already done (or doing) so */
  var externalFilePromise = this._externalFileEntry;
  if (!externalFilePromise) {
    this._externalFileEntry = externalFilePromise = Promise.resolve().then(function() {
      var externalFileName = thisBlob.computeExternalFileName();
      return wrm.util.fs.createNamedTempFile(externalFileName);
    }).then(function(tempFileEntry) {
      return thisBlob.writeIntoFileEntry(tempFileEntry);
    })["catch"](function(e) {
      
      /* Revert the failed allocation */
      thisBlob._externalUrlUsages--;
      thisBlob._externalFileEntry = null;
      
      throw e;
    });
  }
  
  return externalFilePromise.then(function(fileEntry) {
    return fileEntry.toURL();
  });
};

/**
 * @param {string} url
 * @return {!Promise}
 */
wrm.data.Blob.prototype.revokeExternalURL = function(url) {
  
  this._externalUrlUsages--;
  
  /* After revoking the last URL, delete the file */
  var externalFilePromise = this._externalFileEntry;
  if (this._externalUrlUsages <= 0 && externalFilePromise) {
    this._externalUrlUsages = null;
    return externalFilePromise.then(function(fileEntry) {
      return wrm.util.fs.deleteTempFile(fileEntry).then(undefined, function(e) {
        throw new Error("Error deleting file: " + e);
      });
    });
  }
  
  return Promise.resolve();
};
/**
 * @internal
 * @param {!FileEntry} fileEntry
 * @returns {!Promise<!FileEntry>}
 */
wrm.data.Blob.prototype.writeIntoFileEntry = function(fileEntry) {
  if (this._isContentBlob()) {
    return wrm.data.Blob._doWriteBlobIntoFilEntry(fileEntry, this._content);
  } else {
    if (this._isContentFile() && this._content["localURL"]) {
      return wrm.data.Blob._doCopyFileIntoFilEntry(fileEntry, this._content["localURL"]);
    } else {
      return this.readBlob().then(function(blobContent) {
        return wrm.data.Blob._doWriteBlobIntoFilEntry(fileEntry, blobContent);
      });
    }
  }
};

/**
 * @private
 * @param {!FileEntry} fileEntry
 * @param {!Blob} sourceBlob
 * @returns {!Promise<!FileEntry>}
 */
wrm.data.Blob._doWriteBlobIntoFilEntry = function(fileEntry, sourceBlob) {
  
  /* Write the wrapped native BLOB to the supplied file entry */
  return new Promise(function(resolve, reject) {
    fileEntry.createWriter(function(writer) {
      writer.onwriteend = function() {
        resolve(fileEntry);
      };
      writer.onerror = function(event) {
        reject(new Error("Error writing to file: " + event));
      };
      writer.write(sourceBlob);
    }, function(e) {
      reject(new Error("Error opening file for writing: " + e));
    });
  });
};

/**
 * @private
 * @param {!FileEntry} fileEntry
 * @param {string} sourcePath
 * @returns {!Promise<!FileEntry>}
 */
wrm.data.Blob._doCopyFileIntoFilEntry = function(fileEntry, sourcePath) {
  return wrm.util.fs.lookupFileEntry(sourcePath).then(function(sourceFileEntry) {
    return new Promise(function(resolve, reject) {
      fileEntry.getParent(function(dirEntry) {
        sourceFileEntry.copyTo((dirEntry), fileEntry.name, function() {
          resolve(fileEntry);
        }, function(e) {
          reject(new Error("Error copying file: " + e));
        });
      }, function(e) {
        reject(new Error("Error retrieving parent directory: " + e));
      });
    });
  });
};

/** @override */
wrm.data.Blob.prototype.hashKey = function() {
  return "Blob:" + this._uniqueId;
};

/** @override */
wrm.data.Blob.prototype.equals = function(object) {
  if (!(object instanceof wrm.data.Blob)) {
    return false;
  }
  if (object === this) {
    return true;
  }
  
  /* If there is a content signature, use that for equality */
  var thisMetadata = this._metadata;
  var otherMetadata = object._metadata;
  if (thisMetadata.contentSignature !== null && otherMetadata.contentSignature !== null) {
    if (thisMetadata.fileName === otherMetadata.fileName && thisMetadata.contentSignature === otherMetadata.contentSignature) {
      return true;
    }
  }
  
  /* Do not make other attempts at comparing blobs */
  return false;
};

/** @override */
wrm.data.Blob.prototype.getValueType = function() {
  return wrm.data.Type.BLOB;
};

/** @override */
wrm.data.Blob.prototype.toString = function() {
  var s = [];
  s.push("Blob(");
  s.push(String(this.getSize()));
  s.push(" bytes, ");
  s.push(this.getContentType() || "unknown type");
  s.push(")");
  return s.join("");
};

/** @override */
wrm.data.Blob.prototype.toJSON = function() {
  throw new Error("Blob value not serializable to JSON");
};

/*
 * Utilities
 */

/**
 * @private
 * @return {?string}
 */
wrm.data.Blob.prototype._retrieveContentType = function() {
  var fileName = this.getMetadata().fileName;
  if (!fileName) {
    return null;
  }
  fileName = fileName.replace(/ /g, "_");
  var regex = /[.]([^.]+)$/;
  var m = regex.exec(fileName);
  if (m && m[0]) {
    var contentType = wrm.data.ContentType.retrieveContentTypeBySuffix(m[0]);
    return contentType ? contentType.getName() : null;
  }
  return null;
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.Blob.prototype._isContentFile = function() {
  return this._content instanceof File;
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.Blob.prototype._isContentBlob = function() {
  return !this._isContentFile();
};

/*
 * Factories
 */

/**
 * @param {!File} file
 * @param {string=} contentType
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 * @return {!wrm.data.Blob}
 */
wrm.data.Blob.fromFile = function(file, contentType, metadata) {
  return new wrm.data.Blob(file, contentType, metadata);
};

/**
 * @param {!Blob} blob
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 * @return {!wrm.data.Blob}
 */
wrm.data.Blob.fromBlob = function(blob, metadata) {
  return new wrm.data.Blob(blob, blob.type, metadata);
};

/**
 * @param {!Uint8Array|!ArrayBuffer} bytesArray
 * @param {string=} contentType
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 * @return {!wrm.data.Blob}
 */
wrm.data.Blob.fromBytes = function(bytesArray, contentType, metadata) {
  return new wrm.data.Blob(bytesArray, contentType, metadata);
};

/**
 * @param {string} dataUri
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 * @return {!wrm.data.Blob}
 */
wrm.data.Blob.fromDataUri = function(dataUri, metadata) {
  var m = wrm.data.Blob.fromDataUri._DATA_URI_RE.exec(dataUri);
  if (!m) {
    throw new Error("Invalid data URI");
  }
  if (m[2] !== "base64") {
    throw new Error("Only Base64-encoded URIs are supported");
  }
  return wrm.data.Blob.fromBase64(m[3], m[1], metadata);
};

/**
 * @private
 * @const
 * @type {!RegExp}
 */
wrm.data.Blob.fromDataUri._DATA_URI_RE = /^data:(.*?)(?:;(base64))?,(.*)$/;

/**
 * @param {string} base64String
 * @param {string=} contentType
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 * @return {!wrm.data.Blob}
 */
wrm.data.Blob.fromBase64 = function(base64String, contentType, metadata) {
  var bytes = wrm.data.Blob._parseBase64(base64String);
  return new wrm.data.Blob(bytes, contentType, metadata);
};

/**
 * @private
 * @param {string} base64
 * @return {!Uint8Array}
 */
wrm.data.Blob._parseBase64 = function(base64) {
  
  /*
   * Support functions for parsing a Base64 string are an adaptation of those available at
   * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Appendix.3A_Decode_a_Base64_string_to_Uint8Array_or_ArrayBuffer
   * . Note that simply using btoa() would not work because of invalid UTF-8 sequences
   */
  
  /**
   * @param {number} nChr
   * @return {number}
   */
  function b64ToUint6(nChr) {
    if (nChr > 64 && nChr < 91) {
      return nChr - 65;
    } else {
      if (nChr > 96 && nChr < 123) {
        return nChr - 71;
      } else {
        if (nChr > 47 && nChr < 58) {
          return nChr + 4;
        } else {
          if (nChr === 43) {
            return 62;
          } else {
            if (nChr === 47) {
              return 63;
            }
          }
        }
      }
    }
    return 0;
  }
  
  /**
   * @param {string} sBase64
   * @param {number=} nBlocksSize
   * @return {!Uint8Array}
   */
  function base64DecToArr(sBase64, nBlocksSize) {
    var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, "");
    var nInLen = sB64Enc.length;
    var nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;
    var taBytes = new Uint8Array(nOutLen);
    
    for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0;nInIdx < nInLen;nInIdx++) {
      nMod4 = nInIdx & 3;
      nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
      if (nMod4 === 3 || nInLen - nInIdx === 1) {
        for (nMod3 = 0;nMod3 < 3 && nOutIdx < nOutLen;nMod3++, nOutIdx++) {
          taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
        }
        nUint24 = 0;
      }
    }
    
    return taBytes;
  }
  
  return base64DecToArr(base64);
};




//== wrm/data/Date.js =========================================================



/**
 * @constructor
 * @implements wrm.data.Comparable
 * @implements wrm.data.TypedValue
 * @class classDescription
 * @param {number} year
 * @param {number} month
 * @param {number} day
 */
wrm.data.Date = function(year, month, day) {
  
  /**
   * @private
   * @type {!Date}
   */
  this._date = new Date(year, month, day);
  
};

/**
 * @return {number}
 */
wrm.data.Date.prototype.getYear = function() {
  return this._date.getFullYear();
};

/**
 * @return {number}
 */
wrm.data.Date.prototype.getMonth = function() {
  return this._date.getMonth();
};

/**
 * @return {number}
 */
wrm.data.Date.prototype.getDay = function() {
  return this._date.getDate();
};

/**
 * @return {!Date}
 */
wrm.data.Date.prototype.asDate = function() {
  return this._date;
};

/** @override */
wrm.data.Date.prototype.compareTo = function(object) {
  if (!(object instanceof wrm.data.Date)) {
    object = wrm.data.toDate(object);
  }
  
  if (object === this) {
    return 0;
  }
  
  var left = this._date.valueOf();
  var right = object._date.valueOf();
  
  return left - right;
};

/** @override */
wrm.data.Date.prototype.hashKey = function() {
  return String(this._date.valueOf());
};

/** @override */
wrm.data.Date.prototype.equals = function(object) {
  if (!(object instanceof wrm.data.Date)) {
    return false;
  }
  if (object === this) {
    return true;
  }
  return this._date.valueOf() === object._date.valueOf();
};

/** @override */
wrm.data.Date.prototype.getValueType = function() {
  return wrm.data.Type.DATE;
};

/** @override */
wrm.data.Date.prototype.toString = function() {
  var s = ("0000" + this.getYear()).slice(-4);
  s += "-" + ("00" + (this.getMonth() + 1)).slice(-2);
  s += "-" + ("00" + this.getDay()).slice(-2);
  return s;
};

/** @override */
wrm.data.Date.prototype.toJSON = function() {
  return this.toString();
};

/*
 * Factories
 */

/**
 * @param {string} s
 * @return {!wrm.data.Date}
 */
wrm.data.Date.fromString = function(s) {
  var regex = /^([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
  var m = regex.exec(s);
  if (!m) {
    throw new Error("Invalid date string: " + s);
  }
  
  var year = Number(m[1]);
  var month = Number(m[2]) - 1;
  var day = Number(m[3]);
  
  return new wrm.data.Date(year, month, day);
};

/**
 * @param {number} timestamp
 * @return {!wrm.data.Date}
 */
wrm.data.Date.fromTimestamp = function(timestamp) {
  return wrm.data.Date.fromDate(new Date(timestamp));
};

/**
 * @param {!Date} date
 * @return {!wrm.data.Date}
 */
wrm.data.Date.fromDate = function(date) {
  var year = date.getFullYear();
  var month = date.getMonth();
  var day = date.getDate();
  
  return new wrm.data.Date(year, month, day);
};




//== wrm/data/Time.js =========================================================



/**
 * @constructor
 * @implements wrm.data.Comparable
 * @implements wrm.data.TypedValue
 * @class classDescription
 * @param {number} hours
 * @param {number} minutes
 * @param {number=} seconds
 * @param {number=} milliseconds
 */
wrm.data.Time = function(hours, minutes, seconds, milliseconds) {
  
  /**
   * @private
   * @type {!Date}
   */
  this._date = new Date(1970, 0, 1, hours, minutes, seconds || 0, milliseconds || 0);
  
};

/**
 * @return {number}
 */
wrm.data.Time.prototype.getHours = function() {
  return this._date.getHours();
};

/**
 * @return {number}
 */
wrm.data.Time.prototype.getMinutes = function() {
  return this._date.getMinutes();
};

/**
 * @return {number}
 */
wrm.data.Time.prototype.getSeconds = function() {
  return this._date.getSeconds();
};

/**
 * @return {number}
 */
wrm.data.Time.prototype.getMilliseconds = function() {
  return this._date.getMilliseconds();
};

/**
 * @return {!Date}
 */
wrm.data.Time.prototype.asDate = function() {
  return this._date;
};

/** @override */
wrm.data.Time.prototype.compareTo = function(object) {
  if (!(object instanceof wrm.data.Time)) {
    object = wrm.data.toTime(object);
  }
  
  if (object === this) {
    return 0;
  }
  
  var left = this._date.valueOf();
  var right = object._date.valueOf();
  
  return left - right;
};

/** @override */
wrm.data.Time.prototype.hashKey = function() {
  return String(this._date.valueOf());
};

/** @override */
wrm.data.Time.prototype.equals = function(object) {
  if (!(object instanceof wrm.data.Time)) {
    return false;
  }
  if (object === this) {
    return true;
  }
  return this._date.valueOf() === object._date.valueOf();
};

/** @override */
wrm.data.Time.prototype.getValueType = function() {
  return wrm.data.Type.TIME;
};

/** @override */
wrm.data.Time.prototype.toString = function() {
  var s = ("00" + this.getHours()).slice(-2);
  s += ":" + ("00" + this.getMinutes()).slice(-2);
  s += ":" + ("00" + this.getSeconds()).slice(-2);
  s += "." + ("000" + this.getMilliseconds()).slice(-3);
  return s;
};

/** @override */
wrm.data.Time.prototype.toJSON = function() {
  return this.toString();
};

/*
 * Factories
 */

/**
 * @param {string} s
 * @return {!wrm.data.Time}
 */
wrm.data.Time.fromString = function(s) {
  var regex = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]|[0-9])(?::([0-5][0-9]|[0-9])(?:\.(\d{3}))?)?$/;
  var m = regex.exec(s);
  if (!m) {
    throw new Error("Invalid time string: " + s);
  }
  
  var hour = Number(m[1]);
  var minute = Number(m[2]);
  var second = Number(m[3] || "0");
  var millisecond = Number(m[4] || "0");
  
  return new wrm.data.Time(hour, minute, second, millisecond);
};

/**
 * @param {number} timestamp
 * @return {!wrm.data.Time}
 */
wrm.data.Time.fromTimestamp = function(timestamp) {
  var value = timestamp % 864E5;
  
  var hour = Math.floor(value / 36E5);
  value = value % 36E5;
  var minute = Math.floor(value / 6E4);
  value = value % 6E4;
  var second = Math.floor(value / 1E3);
  var millisecond = value % 1E3;
  
  return new wrm.data.Time(hour, minute, second, millisecond);
};

/**
 * @param {!Date} date
 * @return {!wrm.data.Time}
 */
wrm.data.Time.fromDate = function(date) {
  var hour = date.getHours();
  var minute = date.getMinutes();
  var second = date.getSeconds();
  var millisecond = date.getMilliseconds();
  
  return new wrm.data.Time(hour, minute, second, millisecond);
};




//== wrm/data/Decimal.js ======================================================



/**
 * @constructor
 * @implements wrm.data.Comparable
 * @implements wrm.data.TypedValue
 * @param {number|string|!wrm.data.Decimal} decimal
 */
wrm.data.Decimal = function(decimal) {
  
  /**
   * @private
   * @type {!Big}
   */
  this._decimal = this._create(decimal);
};

/**
 * @private
 * @param {number|string|!Big|!wrm.data.Decimal} n
 * @return {!Big}
 */
wrm.data.Decimal.prototype._create = function(n) {
  return new Big((n));
};

/** @override */
wrm.data.Decimal.prototype.compareTo = function(object) {
  if (!(object instanceof wrm.data.Decimal)) {
    object = wrm.data.toDecimal(object);
  }
  
  if (object === this) {
    return 0;
  }
  
  return this._doCompareTo((object));
};

/** @override */
wrm.data.Decimal.prototype.hashKey = function() {
  return this.toString();
};

/** @override */
wrm.data.Decimal.prototype.equals = function(object) {
  if (!(object instanceof wrm.data.Decimal)) {
    return false;
  }
  if (object === this) {
    return true;
  }
  return this._decimal.eq(object._decimal);
};

/** @override */
wrm.data.Decimal.prototype.getValueType = function() {
  return wrm.data.Type.DECIMAL;
};

/** @override */
wrm.data.Decimal.prototype.toString = function() {
  return this._decimal.toString();
};

/** @override */
wrm.data.Decimal.prototype.toJSON = function() {
  return this.toString();
};

/**
 * @param {number=} decimalPlaces
 * @return {string}
 */
wrm.data.Decimal.prototype.toExponential = function(decimalPlaces) {
  return this._decimal.toExponential(decimalPlaces);
};

/**
 * @param {number=} decimalPlaces
 * @return {string}
 */
wrm.data.Decimal.prototype.toFixed = function(decimalPlaces) {
  return this._decimal.toFixed(decimalPlaces);
};

/**
 * @param {number=} significantDigits
 * @return {string}
 */
wrm.data.Decimal.prototype.toPrecision = function(significantDigits) {
  return this._decimal.toPrecision(significantDigits);
};

/**
 * @return {number}
 */
wrm.data.Decimal.prototype.toNumber = function() {
  var s = this._decimal.toString();
  var n = Number(s);
  if (s === String(n)) {
    return n;
  }
  throw new Error("Decimal too large to be converted into number");
};

/**
 * @override
 * @param {{groupSeparator:string, decimalSeparator:string}=} options
 * @return {string}
 */
wrm.data.Decimal.prototype.toLocaleString = function(options) {
  options = options || {groupSeparator:"", decimalSeparator:"."};
  return this._computeLocalizedString(options.groupSeparator, options.decimalSeparator);
};

/*
 * Operations
 */

/**
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.abs = function() {
  return this._wrap(this._decimal.abs());
};

/**
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.divide = function(n) {
  return this._wrap(this._decimal.div(this._unwrap(n)));
};

/**
 * @param {number|string|!wrm.data.Decimal} n
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.minus = function(n) {
  return this._wrap(this._decimal.minus(this._unwrap(n)));
};

/**
 * @param {number|string|!wrm.data.Decimal} n
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.module = function(n) {
  return this._wrap(this._decimal.mod(this._unwrap(n)));
};

/**
 * @param {number|string|!wrm.data.Decimal} n
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.plus = function(n) {
  return this._wrap(this._decimal.plus(this._unwrap(n)));
};

/**
 * @param {number} n
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.power = function(n) {
  return this._wrap(this._decimal.pow(n));
};

/**
 * @param {number=} decimalPlaces
 * @param {number=} roundingMode
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.round = function(decimalPlaces, roundingMode) {
  return this._wrap(this._decimal.round(decimalPlaces, roundingMode));
};

/**
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.square = function() {
  return this._wrap(this._decimal.sqrt());
};

/**
 * @param {number|string|!wrm.data.Decimal} n
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.times = function(n) {
  return this._wrap(this._decimal.times(this._unwrap(n)));
};

/**
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype.inverse = function() {
  return this._wrap(this._decimal.times(-1));
};

/*
 * Factories
 */

/**
 * @param {string} s
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.fromString = function(s) {
  return new wrm.data.Decimal(s);
};

/**
 * @param {number} decimal
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.fromNumber = function(decimal) {
  return new wrm.data.Decimal(decimal);
};

/*
 * Utilities
 */

/**
 * @private
 * @param {!Big} n
 * @return {!wrm.data.Decimal}
 */
wrm.data.Decimal.prototype._wrap = function(n) {
  return new wrm.data.Decimal((n));
};

/**
 * @private
 * @param {number|string|!wrm.data.Decimal} n
 * @return {number|string|!Big}
 */
wrm.data.Decimal.prototype._unwrap = function(n) {
  if (n instanceof wrm.data.Decimal) {
    return n._decimal;
  }
  return n;
};

/**
 * @private
 * @param {!wrm.data.Decimal} n
 * @return {number}
 */
wrm.data.Decimal.prototype._doCompareTo = function(n) {
  return this._decimal.cmp(this._unwrap(n));
};

/**
 * @private
 * @param {string} groupSep
 * @param {string} decimalSep
 * @return {string}
 */
wrm.data.Decimal.prototype._computeLocalizedString = function(groupSep, decimalSep) {
  var isNegative = this._decimal.s === 1 ? false : true;
  var numStr = isNegative ? this._decimal.toString().substring(1) : this._decimal.toString();
  var formattedText = "";
  var parts = [];
  
  var fraction = numStr.split(".");
  var real = fraction[0];
  fraction = fraction[1] || "";
  var separatorCounter = 0;
  
  for (var i = real.length;i >= 0;i--) {
    if ((formattedText.length - separatorCounter) % 3 === 0 && formattedText.length !== 0) {
      formattedText += groupSep;
      separatorCounter++;
    }
    formattedText += real.charAt(i);
  }
  
  formattedText = formattedText.split("").reverse().join("");
  
  if (fraction !== "") {
    formattedText += decimalSep + fraction;
  }
  parts.push(isNegative ? "-" : "", formattedText);
  
  return parts.join("");
};




//== wrm/data/Type.js =========================================================


/**
 * @enum {string}
 */
wrm.data.Type = {BLOB:"blob", BOOLEAN:"boolean", DATE:"date", DECIMAL:"decimal", FLOAT:"float", INTEGER:"integer", PASSWORD:"password", STRING:"string", TEXT:"text", TIME:"time", TIMESTAMP:"timestamp", URL:"url"};

/** @const */
wrm.data.Type._KIND_NUMERIC = "N";

/** @const */
wrm.data.Type._KIND_TEXTUAL = "T";

/**
 * @private
 * @type {!Object.<wrm.data.Type,string>}
 */
wrm.data.Type._TYPE_KINDS = {};
/* Numeric Types */
wrm.data.Type._TYPE_KINDS[wrm.data.Type.DECIMAL] = wrm.data.Type._KIND_NUMERIC;
wrm.data.Type._TYPE_KINDS[wrm.data.Type.FLOAT] = wrm.data.Type._KIND_NUMERIC;
wrm.data.Type._TYPE_KINDS[wrm.data.Type.INTEGER] = wrm.data.Type._KIND_NUMERIC;
/* Textual Types */
wrm.data.Type._TYPE_KINDS[wrm.data.Type.PASSWORD] = wrm.data.Type._KIND_TEXTUAL;
wrm.data.Type._TYPE_KINDS[wrm.data.Type.STRING] = wrm.data.Type._KIND_TEXTUAL;
wrm.data.Type._TYPE_KINDS[wrm.data.Type.TEXT] = wrm.data.Type._KIND_TEXTUAL;
wrm.data.Type._TYPE_KINDS[wrm.data.Type.URL] = wrm.data.Type._KIND_TEXTUAL;

/**
 * @private
 * @type {!Object.<wrm.data.Type,boolean>}
 */
wrm.data.Type._TYPE_LOCALIZABLE = {};
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.BOOLEAN] = true;
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.DATE] = true;
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.DECIMAL] = true;
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.FLOAT] = true;
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.INTEGER] = true;
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.TIME] = true;
wrm.data.Type._TYPE_LOCALIZABLE[wrm.data.Type.TIMESTAMP] = true;

/**
 * @param {wrm.data.Type} type
 * @return {boolean}
 */
wrm.data.Type.isNumeric = function(type) {
  return wrm.data.Type._TYPE_KINDS[type] === wrm.data.Type._KIND_NUMERIC;
};

/**
 * @param {wrm.data.Type} type
 * @return {boolean}
 */
wrm.data.Type.isTextual = function(type) {
  return wrm.data.Type._TYPE_KINDS[type] === wrm.data.Type._KIND_TEXTUAL;
};

/**
 * @param {wrm.data.Type} type
 * @return {boolean}
 */
wrm.data.Type.isLocalizable = function(type) {
  return wrm.data.Type._TYPE_LOCALIZABLE[type] === true;
};




//== wrm/data/Converters.js ===================================================



/**
 * @package
 * @const
 * @type {!Object<wrm.data.Type,function(!*):!*>}
 */
wrm.data.Converters = {};

/*
 * BLOB
 */

/**
 * @package
 * @param {!*} value
 * @param {string=} contentType
 * @param {{fileName:(?string|undefined), contentSignature:(?string|undefined),
 *            availabilityStatus:(?wrm.data.AvailabilityStatus|undefined)}=} metadata
 * @return {!wrm.data.Blob}
 */
wrm.data.Converters[wrm.data.Type.BLOB] = wrm.data.Converters.BLOB_CONVERTER = function(value, contentType, metadata) {
  if (value instanceof wrm.data.Blob) {
    return value;
  }
  if (value instanceof Blob) {
    return wrm.data.Blob.fromBlob(value, metadata);
  }
  if (value instanceof File) {
    return wrm.data.Blob.fromFile(value, value.type, {fileName:value.name});
  }
  if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
    return wrm.data.Blob.fromBytes(value, contentType, metadata);
  }
  if (typeof value["byteLength"] === "number") {
    return wrm.data.Blob.fromBytes((value), contentType, metadata);
  }
  if (typeof value === "string") {
    if (value.indexOf(wrm.data.Converters._DATA_URI_SCHEME) === 0) {
      return wrm.data.Blob.fromDataUri(value, metadata);
    }
  }
  throw new Error("Value not convertible to blob");
};

/**
 * @private
 * @const
 */
wrm.data.Converters._DATA_URI_SCHEME = "data:";

/*
 * Date/time types
 */

/**
 * @package
 * @param {!*} value
 * @return {!wrm.data.Date}
 */
wrm.data.Converters[wrm.data.Type.DATE] = function(value) {
  if (value instanceof wrm.data.Date) {
    return value;
  }
  if (value instanceof Date) {
    return wrm.data.Date.fromDate(value);
  }
  if (typeof value === "number") {
    return wrm.data.Date.fromTimestamp(value);
  }
  return wrm.data.Date.fromString(String(value));
};

/**
 * @package
 * @param {!*} value
 * @return {!wrm.data.Time}
 */
wrm.data.Converters[wrm.data.Type.TIME] = function(value) {
  if (value instanceof wrm.data.Time) {
    return value;
  }
  if (value instanceof Date) {
    return wrm.data.Time.fromDate(value);
  }
  if (typeof value === "number") {
    return wrm.data.Time.fromTimestamp(value);
  }
  return wrm.data.Time.fromString(String(value));
};

/**
 * @package
 * @param {!*} value
 * @return {!wrm.data.DateTime}
 */
wrm.data.Converters[wrm.data.Type.TIMESTAMP] = function(value) {
  if (value instanceof wrm.data.DateTime) {
    return value;
  }
  if (value instanceof wrm.data.Date || value instanceof wrm.data.Time) {
    return wrm.data.DateTime.fromDate(value.asDate());
  }
  if (value instanceof Date) {
    return wrm.data.DateTime.fromDate(value);
  }
  if (typeof value === "number") {
    return wrm.data.DateTime.fromTimestamp(value);
  }
  return wrm.data.DateTime.fromString(String(value));
};

/*
 * Numeric types
 */

/**
 * @package
 * @param {!*} value
 * @return {!wrm.data.Decimal}
 */
wrm.data.Converters[wrm.data.Type.DECIMAL] = function(value) {
  if (value instanceof wrm.data.Decimal) {
    return value;
  }
  if (typeof value === "string") {
    return wrm.data.Decimal.fromString(value);
  }
  if (typeof value === "number") {
    return wrm.data.Decimal.fromNumber(value);
  }
  return wrm.data.Decimal.fromString(String(value));
};
/**
 * @package
 * @param {!*} value
 * @return {number}
 */
wrm.data.Converters[wrm.data.Type.FLOAT] = function(value) {
  return wrm.data.Converters._toNumber(value);
};

/**
 * @package
 * @param {!*} value
 * @return {number}
 */
wrm.data.Converters[wrm.data.Type.INTEGER] = function(value) {
  var n = wrm.data.Converters._toNumber(value);
  if (n % 1 !== 0) {
    throw new Error("Not an integer number: " + value);
  }
  return n;
};

/**
 * @private
 * @param {!*} value
 * @return {number}
 */
wrm.data.Converters._toNumber = function(value) {
  if (value instanceof wrm.data.Decimal) {
    return value.toNumber();
  }
  var n = Number(value);
  if (isNaN(n)) {
    throw new Error("Not a number: " + value);
  }
  if (value.length >= 16 && value !== String(n)) {
    throw new Error("Value too large to be converted into number: " + value);
  }
  return n;
};

/*
 * Textual types
 */

/**
 * @package
 * @param {!*} value
 * @return {string}
 */
wrm.data.Converters[wrm.data.Type.PASSWORD] = function(value) {
  return wrm.data.Converters._toString(value);
};

/**
 * @package
 * @param {!*} value
 * @return {string}
 */
wrm.data.Converters[wrm.data.Type.STRING] = function(value) {
  return wrm.data.Converters._toString(value);
};

/**
 * @package
 * @param {!*} value
 * @return {string}
 */
wrm.data.Converters[wrm.data.Type.TEXT] = function(value) {
  return wrm.data.Converters._toString(value);
};

/**
 * @package
 * @param {!*} value
 * @return {string}
 */
wrm.data.Converters[wrm.data.Type.URL] = function(value) {
  return wrm.data.Converters._toString(value);
};

/**
 * @private
 * @param {!*} value
 * @return {string}
 */
wrm.data.Converters._toString = function(value) {
  return String(value);
};

/*
 * Boolean
 */

/**
 * @package
 * @param {!*} value
 * @return {boolean}
 */
wrm.data.Converters[wrm.data.Type.BOOLEAN] = function(value) {
  if (value === true || value === "true") {
    return true;
  }
  if (value instanceof Boolean) {
    return !!value.valueOf();
  }
  if (typeof value === "number") {
    return value !== 0;
  }
  return false;
};




//== wrm/data/_data.js ========================================================



/**
 * @param {boolean} lateEvaluationEnabled
 */
wrm.data.setLateEvaluationEnabled = function(lateEvaluationEnabled) {
  wrm.data.lateEvaluationEnabled = lateEvaluationEnabled;
};

/**
 * @package
 * @type {boolean}
 */
wrm.data.lateEvaluationEnabled = false;

/*
 * Fixed-type Conversions
 */

/**
 * @param {*|null|undefined} value
 * @return {!wrm.data.Blob|null|undefined}
 */
wrm.data.toBlob = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.BLOB, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<!wrm.data.Blob|null|undefined>}
 */
wrm.data.toBlobArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.BLOB, value);
};

/**
 * @param {*|null|undefined} value
 * @return {boolean|null|undefined}
 */
wrm.data.toBoolean = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.BOOLEAN, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<boolean|null|undefined>}
 */
wrm.data.toBooleanArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.BOOLEAN, value);
};

/**
 * @param {*|null|undefined} value
 * @return {!wrm.data.Date|null|undefined}
 */
wrm.data.toDate = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.DATE, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<!wrm.data.Date|null|undefined>}
 */
wrm.data.toDateArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.DATE, value);
};

/**
 * @param {*|null|undefined} value
 * @return {!wrm.data.Decimal|null|undefined}
 */
wrm.data.toDecimal = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.DECIMAL, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<!wrm.data.Decimal|null|undefined>}
 */
wrm.data.toDecimalArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.DECIMAL, value);
};

/**
 * @param {*|null|undefined} value
 * @return {number|null|undefined}
 */
wrm.data.toFloat = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.FLOAT, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<number|null|undefined>}
 */
wrm.data.toFloatArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.FLOAT, value);
};

/**
 * @param {*|null|undefined} value
 * @return {number|null|undefined}
 */
wrm.data.toInteger = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.INTEGER, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<number|null|undefined>}
 */
wrm.data.toIntegerArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.INTEGER, value);
};

/**
 * @param {*|null|undefined} value
 * @return {string|null|undefined}
 */
wrm.data.toString = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.STRING, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<string|null|undefined>}
 */
wrm.data.toStringArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.STRING, value);
};

/**
 * @param {*|null|undefined} value
 * @return {string|null|undefined}
 */
wrm.data.toText = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.TEXT, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<string|null|undefined>}
 */
wrm.data.toTextArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.TEXT, value);
};

/**
 * @param {*|null|undefined} value
 * @return {!wrm.data.Time|null|undefined}
 */
wrm.data.toTime = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.TIME, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<!wrm.data.Time|null|undefined>}
 */
wrm.data.toTimeArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.TIME, value);
};

/**
 * @param {*|null|undefined} value
 * @return {!wrm.data.DateTime|null|undefined}
 */
wrm.data.toTimestamp = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.TIMESTAMP, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<!wrm.data.DateTime|null|undefined>}
 */
wrm.data.toTimestampArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.TIMESTAMP, value);
};

/**
 * @param {*|null|undefined} value
 * @return {string|null|undefined}
 */
wrm.data.toUrl = function(value) {
  return (wrm.data._convertToValue(wrm.data.Type.URL, value));
};

/**
 * @param {*|null|undefined} value
 * @return {!Array.<string|null|undefined>}
 */
wrm.data.toUrlArray = function(value) {
  return wrm.data._convertToArray(wrm.data.Type.URL, value);
};

/*
 * Variable-type Conversions
 */

/**
 * @param {!wrm.data.Type} type
 * @param {*|null|undefined} value
 */
wrm.data.toSingle = function(type, value) {
  return wrm.data._convertToValue(type, value);
};

/**
 * @param {!wrm.data.Type} type
 * @param {*|null|undefined} value
 */
wrm.data.toArray = function(type, value) {
  return wrm.data._convertToArray(type, value);
};

/*
 * No-type Conversions
 */

/**
 * @param {*|null|undefined} value
 */
wrm.data.toAnySingle = function(value) {
  return wrm.data._convertToValue(null, value);
};

/**
 * @param {*|null|undefined} value
 */
wrm.data.toAnyArray = function(value) {
  return wrm.data._convertToArray(null, value);
};

/**
 * @private
 * @param {?wrm.data.Type} type
 * @param {*|null|undefined} value
 * @return {*|null|undefined}
 */
wrm.data._convertToValue = function(type, value) {
  
  /* Convert empty and 1-element arrays */
  if (Array.isArray(value)) {
    var array = (value);
    if (array.length > 1) {
      throw new TypeError("Input array contains more than one value");
    } else {
      if (array.length === 1) {
        value = array[0];
      } else {
        value = undefined;
      }
    }
  }
  
  /* Handle null and undefined */
  if (value === null || value === undefined) {
    return value;
  }
  
  if (type) {
    if (!wrm.data.Type.isTextual(type) && value === "") {
      return null;
    }
    var converter = wrm.data.Converters[type];
    return wrm.data._invokeConverter(converter, value, type, -1);
  } else {
    return value;
  }
};

/**
 * @private
 * @param {?wrm.data.Type} type
 * @param {*|null|undefined} value
 * @return {!Array.<*|null|undefined>}
 */
wrm.data._convertToArray = function(type, value) {
  
  /* Convert single values and arrays into a new array */
  var array;
  if (!Array.isArray(value)) {
    if (value !== null && value !== undefined) {
      array = [value];
    } else {
      array = [];
    }
  } else {
    array = value.slice(0);
  }
  
  /* Convert each element */
  if (type) {
    var converter = wrm.data.Converters[type];
    
    for (var i = 0;i < array.length;i++) {
      var elementValue = array[i];
      
      /* Handle null and undefined */
      if (elementValue === null || elementValue === undefined) {
        array[i] = elementValue;
        continue;
      }
      
      array[i] = wrm.data._invokeConverter(converter, elementValue, type, i);
    }
  }
  
  return array;
};

/**
 * @private
 * @param {function(!*):!*} converter
 * @param {!*} value
 * @param {!wrm.data.Type} type
 * @param {number} arrayIndex
 * @return {!*}
 */
wrm.data._invokeConverter = function(converter, value, type, arrayIndex) {
  try {
    return converter(value);
  } catch (e) {
    if (arrayIndex >= 0) {
      throw new TypeError("Element at position " + arrayIndex + " not convertible to " + type + ": " + e.message);
    }
    throw new TypeError("Value not convertible to " + type + ": " + e.message);
  }
};

/**
 * @param {*} leftValue
 * @param {*} rightValue
 * @return {number}
 */
wrm.data.compare = function(leftValue, rightValue) {
  
  if ((leftValue === null || leftValue === undefined) && (rightValue === null || rightValue === undefined)) {
    return 0;
  } else {
    if ((leftValue !== null || leftValue !== undefined) && (rightValue === null || rightValue === undefined)) {
      return 1;
    } else {
      if ((leftValue === null || leftValue === undefined) && (rightValue !== null || rightValue !== undefined)) {
        return -1;
      }
    }
  }
  
  if (leftValue instanceof Object) {
    if (implementsInterface(leftValue, wrm.data.Comparable)) {
      return leftValue.compareTo(rightValue);
    } else {
      leftValue = wrm.data.toString(leftValue);
      rightValue = wrm.data.toString(rightValue);
    }
  }
  
  if (typeof leftValue === "string") {
    return wrm.data._compare(leftValue, wrm.data.toString(rightValue));
  } else {
    if (typeof leftValue === "number") {
      return leftValue - wrm.data.toFloat(rightValue);
    } else {
      return wrm.data._compare(wrm.data.toString(leftValue), wrm.data.toString(rightValue));
    }
  }
};

/**
 * @param {*} leftValue
 * @param {*} rightValue
 * @return {boolean}
 */
wrm.data.equal = function(leftValue, rightValue) {
  if (wrm.data._equals(leftValue, rightValue)) {
    return true;
  }
  
  if ((leftValue === null || rightValue === null) && (leftValue === undefined || rightValue === undefined)) {
    return false;
  }
  
  if (leftValue instanceof Object) {
    if (implementsInterface(leftValue, wrm.data.TypedValue)) {
      return leftValue.equals(wrm.data.toSingle(leftValue.getValueType(), rightValue));
    } else {
      return false;
    }
  }
  
  if (typeof leftValue === "string") {
    rightValue = wrm.data.toString(rightValue);
  } else {
    if (typeof leftValue === "number") {
      rightValue = wrm.data.toInteger(rightValue);
    } else {
      leftValue = wrm.data.toString(leftValue);
      rightValue = wrm.data.toString(rightValue);
    }
  }
  
  return wrm.data._equals(leftValue, rightValue);
  
};

/**
 * @private
 * @param {*} leftValue
 * @param {*} rightValue
 * @return {number}
 */
wrm.data._compare = function(leftValue, rightValue) {
  if (leftValue < rightValue) {
    return -1;
  } else {
    if (leftValue > rightValue) {
      return 1;
    }
  }
  return 0;
};

/**
 * @private
 * @param {*} leftValue
 * @param {*} rightValue
 * @return {boolean}
 */
wrm.data._equals = function(leftValue, rightValue) {
  return leftValue === rightValue;
};

/*
 * Simple data constructs
 */

/**
 * @enum {number}
 */
wrm.data.AvailabilityStatus = {FAILED:0, PENDING:1, AVAILABLE:2};

/*
 * Internal utilities
 */

/**
 * @internal
 * @param {!Object} object
 * @return {!Object}
 */
wrm.data.cloneObject = function(object) {
  return (JSON.parse(JSON.stringify(object)));
};




//== wrm/data/sync/BackEndServerStore.js ======================================

wrm.data.sync = {};


/**
 * @internal
 * @constructor
 * @implements {wrm.core.ServerStore}
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.core.BackEndService} backEndService
 */
wrm.data.sync.BackEndServerStore = function(entity, backEndService) {
  
  /** @private */
  this._entity = entity;
  
  /**
   * @private
   * @type {string}
   */
  this._serverName = (this._entity.getServerName());
  
  /** @private */
  this._backEndService = backEndService;
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.getEntity = function() {
  return this._entity;
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.isServerAvailable = function() {
  return this._backEndService.isAvailable();
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.isServerReadable = function() {
  return this._entity.isServerReadable();
};

/*
 * Data services
 */

/** @override */
wrm.data.sync.BackEndServerStore.prototype.retrieveEntityData = function(token, since) {
  return this._backEndService.retrieveEntityData(token, this._serverName, since);
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.retrieveEntityInstanceData = function(token, key) {
  return this._backEndService.retrieveEntityInstanceData(token, this._serverName, key);
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.retrieveEntityKeys = function(token) {
  return this._backEndService.retrieveEntityKeys(token, this._serverName);
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.createEntityInstance = function(token, record) {
  return this._backEndService.createEntityInstance(token, this._serverName, record);
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.updateEntityInstance = function(token, key, record) {
  return this._backEndService.updateEntityInstance(token, this._serverName, key, record);
};

/** @override */
wrm.data.sync.BackEndServerStore.prototype.deleteEntityInstance = function(token, key) {
  return this._backEndService.deleteEntityInstance(token, this._serverName, key);
};




//== wrm/data/sync/DataSyncError.js ===========================================


/**
 * @package
 * @constructor
 * @extends Error
 * @param {string=} message
 * @param {wrm.data.sync.DataSyncError.Reason=} reason
 */
wrm.data.sync.DataSyncError = makeCustomErrorConstructor("wrm.data.sync.DataSyncError", Error, function(message, reason) {
  
  /** @private */
  this._reason = reason || wrm.data.sync.DataSyncError.Reason.INTERNAL_ERROR;
});

/**
 * @package
 * @return {wrm.data.sync.DataSyncError.Reason}
 */
wrm.data.sync.DataSyncError.prototype.getReason = function() {
  return this._reason;
};

/**
 * @package
 * @enum {string}
 */
wrm.data.sync.DataSyncError.Reason = {LOGGED_OUT:"LOGGED_OUT", LOGGED_OUT_ACCESS_DENIED:"LOGGED_OUT_ACCESS_DENIED", NETWORK_ERROR:"NETWORK_ERROR", BACKEND_UNAVAILABLE:"BACKEND_UNAVAILABLE", FORBIDDEN:"FORBIDDEN", INTERNAL_ERROR:"INTERNAL_ERROR"};




//== wrm/nav/Input.js =========================================================


/**
 * @interface
 */
wrm.nav.Input = function() {
};




//== wrm/nav/InputImpl.js =====================================================



/**
 * @package
 * @constructor
 * @implements wrm.nav.Input
 */
wrm.nav.InputImpl = function() {
};




//== wrm/core/OperationContext.js =============================================


/**
 * @constructor
 * @extends wrm.core.ComponentContext
 * @param {!wrm.nav.Input} input
 * @param {!wrm.nav.State} state
 */
wrm.core.OperationContext = function(input, state) {
  wrm.core.ComponentContext.call(this, input);
  
  /* Publish some state operations */
  this.clearPastNavigationsHistory = state.clearReachedPanelsHistory.bind(state);
};

extendConstructor(wrm.core.OperationContext, wrm.core.ComponentContext);

/**
 * @return {undefined}
 */
wrm.core.OperationContext.prototype.clearPastNavigationsHistory = function() {
  throw new Error;
};




//== wrm/core/ViewComponentContext.js =========================================


/**
 * @constructor
 * @extends wrm.core.ComponentContext
 * @param {!wrm.nav.Input} input
 * @param {?wrm.core.View} view
 * @param {function(!Object,*)} markForViewTrackingFunction
 */
wrm.core.ViewComponentContext = function(input, view, markForViewTrackingFunction) {
  wrm.core.ComponentContext.call(this, input);
  
  /** @private */
  this._view = view;
  
  /** @private */
  this._markForViewTracking = markForViewTrackingFunction;
};

extendConstructor(wrm.core.ViewComponentContext, wrm.core.ComponentContext);

/**
 * @return {!wrm.core.View}
 */
wrm.core.ViewComponentContext.prototype.getView = function() {
  if (!this._view) {
    throw new Error("Component is not associated with any view");
  }
  return this._view;
};

/**
 * @param {!Object} object
 * @param {*} trackId
 */
wrm.core.ViewComponentContext.prototype.markForViewTracking = function(object, trackingId) {
  if (DEBUG && typeof object !== "object" || !object) {
    throw new Error("View tracking works only on non-null objects");
  }
  this._markForViewTracking(object, trackingId);
};

/**
 * @return {!wrm.core.RefreshMode}
 */
wrm.core.ViewComponentContext.prototype.getFormRefreshMode = function() {
  return this._formRefreshMode;
};

/**
 * @package
 * @param {!wrm.core.RefreshMode} formRefreshMode
 */
wrm.core.ViewComponentContext.prototype.setFormRefreshMode = function(formRefreshMode) {
  this._formRefreshMode = formRefreshMode;
};

/**
 * @param {string} inputName
 * @return {boolean}
 */
wrm.core.ViewComponentContext.prototype.isFreshInput = function(inputName) {
  return this._freshInputs[inputName] === true;
};

/**
 * @package
 * @param {!Array<string>} inputNames
 */
wrm.core.ViewComponentContext.prototype.setFreshInputs = function(inputNames) {
  this._freshInputs = {};
  for (var i = 0;i < inputNames.length;i++) {
    this._freshInputs[inputNames[i]] = true;
  }
};




//== wrm/nav/State.js =========================================================



/**
 * @constructor
 * @param {?string} contextualStartPrimaryPanelId
 * @param {!wrm.nav.Environ} environ
 */
wrm.nav.State = function(contextualStartPrimaryPanelId, environ) {
  
  /** @private */
  this._id = (wrm.nav.State._next_id++).toString(26);
  
  /** @private */
  this._contextualStartPrimaryPanelId = contextualStartPrimaryPanelId;
  
  /**
   * @private
   * @type {?string}
   */
  this._contextualStartPanelId = null;
  
  /**
   * @private
   * @type {?string}
   */
  this._startPanelId = null;
  
  /**
   * @private
   * @type {?wrm.nav.Event}
   */
  this._caughtEvent = null;
  
  /**
   * @private
   * @type {wrm.nav.NavFlow}
   */
  this._firstFlow = null;
  
  /**
   * @private
   * @type {!Array.<string>}
   */
  this._flowHistory = [];
  
  /**
   * @private
   * @type {!Object.<string,!Object.<string,boolean>>}
   */
  this._chainPropagatedParams = {};
  
  /**
   * @private
   * @type {boolean}
   */
  this._clearedPanelsHistory = false;
  
  /**
   * @private
   * @type {?string}
   */
  this._mergedPrimaryPanelId = null;
  
  /**
   * @private
   * @type {?string}
   */
  this._reachedPrimaryPanelId = null;
  
  /**
   * @private
   * @type {?string}
   */
  this._reachedPanelId = null;
  
  /**
   * @private
   * @type {?string}
   */
  this._reachedFence = null;
  
  /* Business data */
  
  /**
   * @private
   * @type {!Object.<string,!wrm.nav.InputImpl|!Object>}
   */
  this._map = {};
  
  /**
   * @private
   * @type {!Array.<!Object.<string,!wrm.nav.InputImpl|!Object>>}
   */
  this._savedMaps = [];
  
  /* Support */
  
  /** @private */
  this._environ = environ;
};

/**
 * @private
 * @type {number}
 */
wrm.nav.State._next_id = 0;

/*
 * Access to the state
 */

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getContextualStartPrimaryPanelId = function() {
  return this._contextualStartPrimaryPanelId;
};

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getContextualStartPanelId = function() {
  return this._contextualStartPanelId;
};

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getStartPanelId = function() {
  return this._startPanelId;
};

/**
 * @return {?wrm.nav.Event}
 */
wrm.nav.State.prototype.getCaughtEvent = function() {
  return this._caughtEvent;
};

/**
 * @return {wrm.nav.NavFlow}
 */
wrm.nav.State.prototype.getFirstFlow = function() {
  return this._firstFlow;
};

/**
 * @return {!Array.<string>}
 */
wrm.nav.State.prototype.getFlowHistory = function() {
  return this._flowHistory;
};

/**
 * @param {string} componentId
 * @return {!Object.<string,boolean>}
 */
wrm.nav.State.prototype.getChainPropagatedParams = function(componentId) {
  return this._chainPropagatedParams[componentId] || {};
};

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getMergedPrimaryPanelId = function() {
  return this._mergedPrimaryPanelId;
};

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getReachedPrimaryPanelId = function() {
  return this._reachedPrimaryPanelId;
};

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getReachedPanelId = function() {
  return this._reachedPanelId;
};

/**
 * @return {?string}
 */
wrm.nav.State.prototype.getReachedFence = function() {
  return this._reachedFence;
};

/**
 * @return {!Object.<string,!wrm.nav.Input>}
 */
wrm.nav.State.prototype.getComponentInputs = function() {
  return this._map;
};

/**
 * @param {string} componentId
 * @return {!wrm.nav.Input}
 */
wrm.nav.State.prototype.getComponentInput = function(componentId) {
  var input = this._map[componentId];
  if (!input) {
    this._map[componentId] = input = new wrm.nav.InputImpl;
  }
  return (input);
};

/**
 * @package
 * @param {string} componentId
 */
wrm.nav.State.prototype.discardComponentInput = function(componentId) {
  delete this._map[componentId];
};

/**
 * @package
 * @return {undefined}
 */
wrm.nav.State.prototype.discardComponentInputs = function() {
  this._map = {};
};

/**
 * @return {!Object}
 */
wrm.nav.State.prototype.getPassingData = function() {
  var data = this._map[wrm.core.PASSINGS_COMPONENT_ID];
  if (!data) {
    this._map[wrm.core.PASSINGS_COMPONENT_ID] = data = {};
  }
  return data;
};

/**
 * @param {string} viewComponentId
 * @return {?wrm.core.View}
 */
wrm.nav.State.prototype.getComponentView = function(viewComponentId) {
  return this._environ.retrieveView(this._getContextualPrimaryPanelId(), viewComponentId);
};

/**
 * @param {string} viewComponentId
 * @return {wrm.form.FormState}
 */
wrm.nav.State.prototype.getComponentFormState = function(viewComponentId) {
  return this._environ.retrieveFormState(this._getContextualPrimaryPanelId(), viewComponentId);
};

/**
 * @private
 * @return {string}
 */
wrm.nav.State.prototype._getContextualPrimaryPanelId = function() {
  var primaryPanelId = this._reachedPrimaryPanelId || this._contextualStartPrimaryPanelId;
  if (!primaryPanelId) {
    throw new Error("The navigation has no primary panel in context");
  }
  return primaryPanelId;
};

/** @override */
wrm.nav.State.prototype.toString = function() {
  return "(" + this._id + ")";
};

/*
 * Context factories
 */

/**
 * @param {string} componentId
 * @return {!wrm.core.ComponentContext}
 */
wrm.nav.State.prototype.createComponentContext = function(componentId) {
  var input = this.getComponentInput(componentId);
  return new wrm.core.ComponentContext(input);
};

/**
 * @param {string} viewComponentId
 * @return {!wrm.core.ViewComponentContext}
 */
wrm.nav.State.prototype.createViewComponentContext = function(viewComponentId) {
  var input = this.getComponentInput(viewComponentId);
  var view = this.getComponentView(viewComponentId);
  var markForViewTrackingFunction = this._environ.markObjectForViewTracking.bind(this._environ);
  return new wrm.core.ViewComponentContext(input, view, markForViewTrackingFunction);
};

/**
 * @param {string} operationId
 * @return {!wrm.core.OperationContext}
 */
wrm.nav.State.prototype.createOperationContext = function(operationId) {
  var input = this.getComponentInput(operationId);
  return new wrm.core.OperationContext(input, this);
};

/*
 * State mutation
 */

/**
 * @param {wrm.Service} service
 * @param {!wrm.nav.Event} event
 */
wrm.nav.State.prototype.catchEvent = function(service, event) {
  if (this._caughtEvent) {
    throw new Error("The current navigation has already caught its starting event");
  }
  if (service instanceof wrm.core.PanelService) {
    this._contextualStartPanelId = service.getId();
    this._startPanelId = service.getId();
  }
  this._caughtEvent = event;
};

/**
 * @param {!wrm.nav.NavFlow} navFlow
 */
wrm.nav.State.prototype.stepAhead = function(navFlow) {
  this._pushFlowOnHistory(navFlow.getId(), navFlow);
};

/**
 * @param {string} eventId
 */
wrm.nav.State.prototype.stepJustEvent = function(eventId) {
  this._pushFlowOnHistory(eventId + ".event");
};

/**
 * @return {undefined}
 */
wrm.nav.State.prototype.stepImplicitly = function() {
  this._pushFlowOnHistory("impl");
};

/**
 * @param {string} navFlowId
 * @param {!wrm.nav.NavFlow=} navFlow
 */
wrm.nav.State.prototype._pushFlowOnHistory = function(navFlowId, navFlow) {
  
  /* Record history only outside of islands */
  if (this._savedMaps.length > 0) {
    return;
  }
  
  /* Keep track of the full information about the first flow */
  if (this._flowHistory.length <= 0 && navFlow) {
    this._firstFlow = navFlow;
  }
  
  this._flowHistory.push(navFlowId);
};

/**
 * @param {string} componentId
 * @param {string} paramName
 */
wrm.nav.State.prototype.registerPropagation = function(componentId, paramName) {
  
  /* Record propagations only outside of islands and before reaching the panel (in chain) */
  if (this._reachedPanelId) {
    return;
  }
  if (this._savedMaps.length > 0) {
    return;
  }
  
  var set = this._chainPropagatedParams[componentId];
  if (!set) {
    this._chainPropagatedParams[componentId] = set = {};
  }
  set[paramName] = true;
};

/**
 * @return {undefined}
 */
wrm.nav.State.prototype.clearReachedPanelsHistory = function() {
  if (this._reachedPrimaryPanelId) {
    throw new Error("Already reached a panel");
  }
  this._clearedPanelsHistory = true;
};

/**
 * @param {!wrm.core.PanelService} primaryPanelService
 * @param {!wrm.core.PanelService} panelService
 * @param {boolean=} clearHistory
 * @return {!wrm.nav.Reuse}
 */
wrm.nav.State.prototype.reachPanel = function(primaryPanelService, panelService, clearHistory) {
  if (this._reachedPrimaryPanelId) {
    throw new Error("Already reached a panel");
  }
  if (this._savedMaps.length > 0) {
    throw new Error("Reaching a panel with unfinished islands");
  }
  this._reachedPrimaryPanelId = primaryPanelService.getId();
  this._reachedPanelId = panelService.getId();
  this._reachedFence = panelService.getFence();
  return this._environ.enterPanel(primaryPanelService.getId(), clearHistory || this._clearedPanelsHistory, this);
};

/**
 * @return {undefined}
 */
wrm.nav.State.prototype.pushIsland = function() {
  this._savedMaps.push(this._map);
  this._map = {};
};

/**
 * @return {undefined}
 */
wrm.nav.State.prototype.popIsland = function() {
  if (this._savedMaps.length <= 0) {
    throw new Error("Not inside an island");
  }
  this._map = this._savedMaps.pop();
};

/**
 * @param {!wrm.nav.Event} event
 */
wrm.nav.State.prototype.dispatchEvent = function(event) {
  try {
    this._environ.handleEvent(event);
  } catch (e) {
  }
};

/**
 * @param {string} type
 * @param {?string=} specifier
 * @return {function(!Object.<string,*>=):!Promise}
 */
wrm.nav.State.prototype.getEventNotifier = function(type, specifier) {
  return this._environ.retrieveEventNotifier(type, specifier);
};

/**
 * @param {!wrm.nav.State} baseState
 */
wrm.nav.State.prototype.mergeOnto = function(baseState) {
  var thisState = this;
  if (!baseState._reachedPrimaryPanelId) {
    throw new Error("Base state not at a panel");
  }
  if (this._mergedPrimaryPanelId) {
    throw new Error("Already merged onto another state");
  }
  
  this._mergedPrimaryPanelId = baseState._reachedPrimaryPanelId;
  
  /*
   * Shallow-copy component inputs that are available in the base state: in this way, unchanged inputs are "inherited" when merging
   * states. Note that a new falsy input WILL override an old one.
   */
  var newInputs = this._map;
  angular.forEach(baseState._map, function(baseInput, componentId) {
    var newInput = newInputs[componentId] || undefined;
    thisState._map[componentId] = angular.extend(new wrm.nav.InputImpl, baseInput, newInput);
  });
  angular.forEach(newInputs, function(newInput, componentId) {
    if (!thisState._map.hasOwnProperty(componentId)) {
      thisState._map[componentId] = angular.extend(new wrm.nav.InputImpl, newInput);
    }
  });
};

/*
 * Interactions
 */

wrm.nav.State.prototype.startTimerEvents = function(specifier, interval) {
  return this._environ.startTimerEvents(specifier, interval);
};
/**
 * @param {string} specifier
 */
wrm.nav.State.prototype.stopTimerEvents = function(specifier) {
  this._environ.stopTimerEvents(specifier);
};

/**
 * @template R
 * @param {!wrm.nav.Dialog<R>} dialog
 * @return {!Promise<{value:R, data:!Object}>}
 */
wrm.nav.State.prototype.presentDialog = function(dialog) {
  return this._environ.presentDialog(dialog);
};

/**
 * @param {!wrm.nav.Progress} progress
 */
wrm.nav.State.prototype.reportProgress = function(progress) {
  return this._environ.reportProgress(progress);
};

/*
 * State derivation
 */

wrm.nav.State.prototype.createBranch = function() {
  var newState = new wrm.nav.State(this._reachedPrimaryPanelId, this._environ);
  newState._contextualStartPanelId = this._reachedPanelId;
  
  /* Shallow-copy all component inputs */
  angular.forEach(this._map, function(input, componentId) {
    newState._map[componentId] = angular.extend(new wrm.nav.InputImpl, input);
  });
  
  return newState;
};




//== wrm/nav/_nav.js ==========================================================



/**
 * @name wrm.nav
 * @namespace
 */

/**
 * @internal
 * @const
 */
wrm.nav.SystemValues = {token:null, lastSynchronizationTimestamp:null, languageIsoCode:null, countryIsoCode:null};

/**
 * @internal
 * @enum {string}
 */
wrm.nav.SystemValueKey = {TOKEN:"$$TOKEN$$", LAST_SYNCHRONIZATION_TIMESTAMP:"$$LAST_SYNCHRONIZATION_TIMESTAMP$$", LANGUAGE_ISO_CODE:"$$LANGUAGE_ISO_CODE$$", COUNTRY_ISO_CODE:"$$COUNTRY_ISO_CODE$$", CURRENT_TIMESTAMP:"$$CURRENT_TIMESTAMP$$", CURRENT_DATE:"$$CURRENT_DATE$$"};

/**
 * @internal
 * @return {!wrm.nav.State}
 */
wrm.nav.newInternalState = function() {
  return new wrm.nav.State(null, new wrm.core.InternalEnviron);
};




//== wrm/data/sync/DataSyncUpdater.js =========================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractUpdateParticipant
 * @param {number} currentVersion
 * @param {!wrm.data.sync.DataSyncService} dataSyncService
 * @param {!wrm.core.SecurityService} securityService
 * @param {!wrm.core.BackEndService} backEndService
 * @param {!wrm.l10n.LocalizationService} l10nService
 * @param {!wrm.Log} log
 */
wrm.data.sync.DataSyncUpdater = function(currentVersion, dataSyncService, securityService, backEndService, l10nService, log) {
  wrm.core.AbstractUpdateParticipant.call(this);
  
  /** @private */
  this._currentVersion = currentVersion;
  
  /** @private */
  this._dataSyncService = dataSyncService;
  
  /** @private */
  this._securityService = securityService;
  
  /** @private */
  this._backEndService = backEndService;
  
  /** @private */
  this._l10nService = l10nService;
  
  /** @private */
  this._log = log;
};

extendConstructor(wrm.data.sync.DataSyncUpdater, wrm.core.AbstractUpdateParticipant);

/*
 * Update logic
 */

/** @override */
wrm.data.sync.DataSyncUpdater.prototype.getRequiredParticipantIds = function() {
  return [wrm.data.DataService.UPDATE_ID, wrm.core.BackEndService.UPDATE_ID];
};

/** @override */
wrm.data.sync.DataSyncUpdater.prototype.beginUpdate = function(context) {
  var VERSION_KEY = wrm.data.sync.DataSyncUpdater._ORIG_VERSION_SNAPSHOT_KEY;
  
  /* The original version is the saved one and will be null during the very first update check */
  var snapshot = context.getStableSnapshot();
  var originalVersion = snapshot.get(VERSION_KEY);
  if (originalVersion === null) {
    originalVersion = this._currentVersion;
    snapshot.set(VERSION_KEY, String(originalVersion));
  } else {
    originalVersion = Number(originalVersion);
  }
  var currentVersion = this._currentVersion;
  var updating = originalVersion !== currentVersion;
  context.setInfo(({updating:updating, originalVersion:originalVersion, currentVersion:currentVersion, outboundEntities:[], inboundEntities:[], outboundCleared:false, credentialsChanged:false, userEntityChanged:false}));
  
  /* From this point, working with the ORIGINAL ALGORITHM (if changing version) */
  if (updating) {
    this._switchCurrentVersion(originalVersion);
  }
};

/** @override */
wrm.data.sync.DataSyncUpdater.prototype.prepareForExtensionUpdate = function(context) {
  var thisUpdater = this;
  var dataSyncService = this._dataSyncService;
  var log = this._log;
  
  var info = (context.getInfo());
  var dataInfo = (context.getInfo(wrm.data.DataService.UPDATE_ID));
  
  /* Determine whether it will be required to perform synchronizations during the update because of changes in the database */
  var promise;
  if (dataInfo.isUpdating()) {
    promise = this._collectOriginalEntitiesWithOutboundChanges(dataInfo).then(function(outboundEntities) {
      Array.prototype.push.apply(info.outboundEntities, outboundEntities);
      Array.prototype.push.apply(info.inboundEntities, thisUpdater._collectAddedAndChangedCurrentEntities(dataInfo));
      
      /* Also check is the entity that manages user security is also being changed */
      info.inboundEntities.forEach(function(entity) {
        if (entity.getId() === wrm.Constants.USER_ENT_ID) {
          info.userEntityChanged = true;
        }
      }, this);
    });
  } else {
    promise = Promise.resolve();
  }
  
  /* Ensure to be able to synchronize if the update requires it */
  promise = promise.then(function() {
    if (info.outboundEntities.length > 0 || info.inboundEntities.length > 0) {
      return thisUpdater._ensureSynchronizationAvailability(context).then(function(mayProceed) {
        return mayProceed;
      });
    }
    return true;
  });
  
  /* If asked to, CLEAR ALL OUTBOUND CHANGES (this does not depend on whether we proceed!) */
  promise = promise.then(function(mayProceedWithSync) {
    if (info.outboundCleared) {
      return dataSyncService.clearOutgoingChanges().then(function() {
        return mayProceedWithSync;
      });
    }
    return mayProceedWithSync;
  });
  
  /* If needed, perform an OUTBOUND-ONLY synchronization of entities WITH CHANGES */
  return promise.then(function(mayProceedWithSync) {
    if (!mayProceedWithSync) {
      return;
    }
    
    if (info.outboundEntities.length > 0) {
      log.debug("Will synchronize now outbound changes found in", info.outboundEntities);
      
      /*
       * Run the synchronization using an INTERNAL STATE: this is because the navigation has to remain under the exclusive
       * control of this update participant
       */
      return dataSyncService.synchronize({entities:info.outboundEntities, inbound:false, outbound:true}, wrm.nav.newInternalState()).then(function(route) {
        if (route) {
          throw new Error("The synchronization requires user actino");
        }
      });
    }
  });
};

/** @override */
wrm.data.sync.DataSyncUpdater.prototype.performReductionUpdate = function(context) {
  var info = (context.getInfo());
  
  /* From this point, working with the CURRENT ALGORITHM (if changing version) */
  if (info.updating) {
    this._switchCurrentVersion(info.currentVersion);
  }
  
  /* If needed, set up to perform a FIRST synchronization of ADDED/CHANGED entities */
  if (info.inboundEntities.length > 0) {
    this._log.debug("Will re-synchronize next time all data of", info.inboundEntities);
    info.inboundEntities.forEach(function(entity) {
      this._dataSyncService.clearLastSynchronizationDateTime(entity);
    }, this);
  }
};

/** @override */
wrm.data.sync.DataSyncUpdater.prototype.finishUpdate = function(context) {
  var VERSION_KEY = wrm.data.sync.DataSyncUpdater._ORIG_VERSION_SNAPSHOT_KEY;
  var securityService = this._securityService;
  var log = this._log;
  
  var state = context.getState();
  var info = (context.getInfo());
  
  /* If changing version, it is now over: save the new version */
  if (info.updating) {
    var snapshot = context.getStableSnapshot();
    snapshot.set(VERSION_KEY, String(info.currentVersion));
  }
  
  /* From this point, the state is STABLE */
  var didUpdate = info.updating || info.outboundEntities.length > 0 || info.inboundEntities.length > 0;
  
  /* If changed credentials during the update, re-access */
  if (info.credentialsChanged || info.userEntityChanged) {
    return securityService.accessAgain(false, state).then(function(route) {
      if (route) {
        log.debug("Post-update access requires user action");
      }
      return didUpdate;
    }, function(e) {
      log.error("Post-update access failed", e);
    });
  }
  return didUpdate;
};

/**
 * @private
 * @param {!wrm.data.DataServiceUpdateState} dataInfo
 * @return {!Promise<!Array<!wrm.data.meta.Entity>>}
 */
wrm.data.sync.DataSyncUpdater.prototype._collectOriginalEntitiesWithOutboundChanges = function(dataInfo) {
  var dataSyncService = this._dataSyncService;
  
  /* Collect entities, filtering only those that are server-mapped */
  var metadata = dataInfo.getOriginalMetadata();
  var allMappedEntities = metadata.getEntities().filter(function(entity) {
    return this._dataSyncService.hasServerStore(entity);
  }, this);
  
  /* Filter only entities that have outbound changes */
  var entitiesWithChanges = [];
  return allMappedEntities.reduce(function(chain, entity) {
    return chain.then(function() {
      return dataSyncService.hasOutboundChanges(entity);
    }).then(function(hasChanges) {
      if (hasChanges) {
        entitiesWithChanges.push(entity);
      }
    });
  }, Promise.resolve()).then(function() {
    return entitiesWithChanges;
  });
};

/**
 * @private
 * @param {!wrm.data.DataServiceUpdateState} dataInfo
 * @return {!Array<!wrm.data.meta.Entity>}
 */
wrm.data.sync.DataSyncUpdater.prototype._collectAddedAndChangedCurrentEntities = function(dataInfo) {
  
  /* Collect all add/change entity differences */
  var diff = dataInfo.getExtendedMetadataDiff();
  var entityDiffs = [];
  entityDiffs = entityDiffs.concat(diff.getAddedEntities());
  entityDiffs = entityDiffs.concat(diff.getChangedEntities());
  
  /* Collect actual entities, filtering only those that are server-mapped */
  var metadata = dataInfo.getCurrentMetadata();
  return entityDiffs.map(function(entityDiff) {
    return metadata.getEntity(entityDiff.getId());
  }).filter(function(entity) {
    return this._dataSyncService.hasServerStore(entity);
  }, this);
};

/**
 * @private
 * @param {number} version
 */
wrm.data.sync.DataSyncUpdater.prototype._switchCurrentVersion = function(version) {
  this._log.debug("Now using synchronization version", version);
  this._currentVersion = version;
};

/**
 * @private
 * @typedef {{updating:boolean, originalVersion:number, currentVersion:number, outboundEntities:!Array<!wrm.data.meta.Entity>,
 *          inboundEntities:!Array<!wrm.data.meta.Entity>, outboundCleared:boolean, credentialsChanged:boolean,
 *          userEntityChanged:boolean}}
 */
wrm.data.sync.DataSyncUpdater._UpdateInfo;

/**
 * @private
 * @const
 */
wrm.data.sync.DataSyncUpdater._ORIG_VERSION_SNAPSHOT_KEY = "version";

/*
 * Synchronization availability UX
 */

/**
 * @private
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise<boolean>}
 */
wrm.data.sync.DataSyncUpdater.prototype._ensureSynchronizationAvailability = function(context) {
  var thisUpgrader = this;
  
  /*
   * For the synchronization to be possible the back-end has to be reachable (network active) and the token must be available and
   * fresh. Ensure that the two conditions are both valid, involving the user with dialogs.
   */
  return this._ensureBackEndReachability(context).then(function(ok) {
    if (!ok) {
      return false;
    }
    return thisUpgrader._ensureTokenAvailability(context);
  });
};

/**
 * @private
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise<boolean>} <code>true</code> if the back-end is expected to be available.
 */
wrm.data.sync.DataSyncUpdater.prototype._ensureBackEndReachability = function(context) {
  var thisUpdater = this;
  var log = this._log;
  
  /* Check for reachability */
  if (this._backEndService.isReachable()) {
    return Promise.resolve(true);
  }
  
  /* Back-end unreachable: assume this is a network problem and ask the user */
  log.debug("Back-end not reachable: prompting the user for network availability");
  return this._presentNetworkConfirmationDialog(context.getState()).then(function(shouldRetry) {
    
    /* Retry if asked to */
    if (shouldRetry) {
      return thisUpdater._ensureBackEndReachability(context);
    }
    
    /* Not retrying: cancel the update */
    context.cancel();
    return false;
  });
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<boolean>}
 */
wrm.data.sync.DataSyncUpdater.prototype._presentNetworkConfirmationDialog = function(state) {
  var l10nService = this._l10nService;
  
  var message = l10nService.formatMessage("update.networkDialog.message");
  var dialog = new wrm.nav.Dialog(message, wrm.nav.Dialog.Flavor.NEGATIVE, [{label:l10nService.formatMessage("dialog.button.Retry"), value:0}, {label:l10nService.formatMessage("dialog.button.Exit"), value:1, "default":true}]);
  
  return state.presentDialog(dialog).then(function(result) {
    return result.value === 0;
  });
};

/**
 * @private
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise<boolean>} <code>true</code> if the synchronization is expected to be possible.
 */
wrm.data.sync.DataSyncUpdater.prototype._ensureTokenAvailability = function(context) {
  var thisUpdater = this;
  var securityService = this._securityService;
  var log = this._log;
  
  /* Determine the state of the stored auth credentials */
  var authComplete;
  var authUsername;
  return securityService.areAuthCredentialsComplete().then(function(complete) {
    authComplete = complete;
    return securityService.retrieveAuthUsername().then(function(username) {
      authUsername = username;
    });
  }).then(function() {
    
    /* Check for EMPTY credentials */
    if (!authComplete && !authUsername) {
      log.debug("Creadentials are not present");
      return false;
    }
    var defaultUsername = (authUsername);
    
    /*
     * If the credentials are COMPLETE, attempt to renew the token; if failing because of an authentication error, consider the
     * complete credentials as they were partial (because of invalidity)
     */
    if (authComplete) {
      return securityService.renewToken().then(function() {
        log.debug("Credentials are valid");
        return true;
      }, function(e) {
        if (!(e instanceof wrm.core.AuthenticationError)) {
          throw e;
        }
        
        /* Let the user correct the credentials and retry */
        log.debug("Credentials are invalid: prompting the user for them");
        return thisUpdater._stabilizeCredentials(defaultUsername, context).then(function(ok) {
          if (ok) {
            return thisUpdater._ensureTokenAvailability(context);
          }
          return false;
        });
      });
    }
    
    /* The credentials are PARTIAL: let the user complete them and retry */
    log.debug("Credentials are incomplete: prompting the user for them");
    return thisUpdater._stabilizeCredentials(defaultUsername, context).then(function(ok) {
      if (ok) {
        return thisUpdater._ensureTokenAvailability(context);
      }
      return false;
    });
  });
};

/**
 * @private
 * @param {string} username
 * @param {!wrm.core.UpdateContext} context
 * @return {!Promise<boolean>} <code>true</code> if the credentials are expected to EVENTUALLY become stable.
 */
wrm.data.sync.DataSyncUpdater.prototype._stabilizeCredentials = function(username, context) {
  var securityService = this._securityService;
  var thisUpdater = this;
  var state = context.getState();
  var info = (context.getInfo());
  
  /* First prompt the user for complete credentials */
  return this._presentLoginDialog(username, state).then(function(enteredCreds) {
    
    /* If chosen to EXIT, cancel the update and do not do anything */
    if (!enteredCreds) {
      context.cancel();
      return false;
    }
    
    /* If chosen to RESET, get a confirmation */
    if (enteredCreds.username === null && enteredCreds.password === null) {
      return Promise.resolve(info.outboundEntities.length <= 0 || thisUpdater._presentResetConfirmationDialog(state)).then(function(resetAllowed) {
        if (resetAllowed) {
          return securityService.clearUser(true).then(function() {
            info.outboundEntities = [];
            info.outboundCleared = true;
            return true;
          });
        }
        return true;
      });
    }
    
    /* Chosen OK, set the new credentials */
    return securityService.setAuthCredentials(enteredCreds.username || "", enteredCreds.password || "").then(function() {
      info.credentialsChanged = true;
      return true;
    });
  });
};

/**
 * @private
 * @param {string} username
 * @param {!wrm.nav.State} state
 * @return {!Promise<?{username:?string, password:?string}>}
 */
wrm.data.sync.DataSyncUpdater.prototype._presentLoginDialog = function(username, state) {
  var l10nService = this._l10nService;
  
  var message = l10nService.formatMessage("update.loginDialog.message");
  var dialog = new wrm.nav.LoginDialog(message, username, true, [{label:l10nService.formatMessage("dialog.button.OK"), value:0}, {label:l10nService.formatMessage("dialog.button.Reset"), value:1}, {label:l10nService.formatMessage("dialog.button.Exit"), value:2, "default":true}]);
  
  return state.presentDialog(dialog).then(function(result) {
    switch(result.value) {
      case 0:
        return {username:result.data["username"], password:result.data["password"]};
      case 1:
        return {username:null, password:null};
      case 2:
      ;
      default:
        return null;
    }
  });
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<boolean>}
 */
wrm.data.sync.DataSyncUpdater.prototype._presentResetConfirmationDialog = function(state) {
  var l10nService = this._l10nService;
  
  var message = l10nService.formatMessage("update.resetDialog.message");
  var dialog = new wrm.nav.Dialog(message, wrm.nav.Dialog.Flavor.CAUTIONAL, [{label:l10nService.formatMessage("dialog.button.Reset"), value:0}, {label:l10nService.formatMessage("dialog.button.Cancel"), value:1, "default":true}]);
  
  return state.presentDialog(dialog).then(function(result) {
    return result.value === 0;
  });
};




//== wrm/data/ChangeListener.js ===============================================


/**
 * @interface Interface of an object that can listen for changes in persistent data as they occur.
 */
wrm.data.ChangeListener = function() {
};

/**
 * Returns a change listener instance specific for the specified entity.
 * 
 * @param {!wrm.data.meta.Entity} entity Entity affected by the change.
 */
wrm.data.ChangeListener.prototype.getEntityListener = ABSTRACT_METHOD;

/**
 * Returns a change listener instance specific for the specified association.
 * 
 * @param {!wrm.data.meta.Association} assoc Association affected by the change.
 */
wrm.data.ChangeListener.prototype.getAssociationListener = ABSTRACT_METHOD;




//== wrm/data/XDChangeTrackerAdapter.js =======================================


/**
 * @package
 * @constructor
 * @implements xdata.Query.ChangeTracker
 */
wrm.data.XDChangeTrackerAdapter = function() {
  
  /**
   * @type {!Object<string,string>|!Array<string>}
   */
  this.tracked;
  
  /**
   * @type {!Object<string,string>|!Array<string>|undefined}
   */
  this.trackedOld;
};

/** @override */
wrm.data.XDChangeTrackerAdapter.prototype.afterInsert = function(values) {
};

/** @override */
wrm.data.XDChangeTrackerAdapter.prototype.afterUpdate = function(values, valuesOld) {
};

/** @override */
wrm.data.XDChangeTrackerAdapter.prototype.afterDelete = function(values) {
};




//== wrm/data/sync/BlobCache.js ===============================================


/**
 * @package
 * @constructor
 * @class Cache for tracking the existence of BLOB values and retrieving them by "borrowing" from other instances.
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.BlobCache = function(dataRunner) {
  
  /**
   * @private
   * @type {!Object.<string,{entity:!wrm.data.meta.Entity, attr:!wrm.data.meta.Attribute, key:*}>}
   */
  this._cache = {};
  
  /** @private */
  this._dataRunner = dataRunner;
};

/**
 * @package
 * @param {string} serverFileId
 * @return {!Promise.<!wrm.data.Blob>|!Promise.<null>}
 */
wrm.data.sync.BlobCache.prototype.retrieve = function(serverFileId) {
  var info = this._cache[serverFileId];
  if (!info) {
    return Promise.resolve(null);
  }
  
  /* Retrieve the BLOB value from the entity */
  return this._dataRunner.execute(function(dataContext) {
    return dataContext.selectOne(info.entity.getId(), {output:info.attr.getId(), outputConfig:{useNames:true}, filter:info.entity.getKeyAttribute().getId()}, [info.key]);
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} object
 */
wrm.data.sync.BlobCache.prototype.register = function(entity, object) {
  var keyAttr = entity.getKeyAttribute();
  var key = keyAttr && object[keyAttr.getName()];
  if (!key) {
    return;
  }
  
  var serverFileIds = this._extractCachableBlobAttribute(entity, object);
  if (serverFileIds.length < 0) {
    return;
  }
  
  for (var i = 0;i < serverFileIds.length;i++) {
    var blobAttrInfo = serverFileIds[i];
    this._cache[blobAttrInfo.serverFileId] = {entity:entity, attr:blobAttrInfo.attr, key:key};
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} object
 */
wrm.data.sync.BlobCache.prototype.unregister = function(entity, object) {
  var serverFileIds = this._extractCachableBlobAttribute(entity, object);
  if (serverFileIds.length < 0) {
    return;
  }
  
  var cache = this._cache;
  return serverFileIds.forEach(function(blobAttrInfo) {
    delete cache[blobAttrInfo.serverFileId];
  });
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} object
 * @return {!Array.<{serverFileId:string, attr:!wrm.data.meta.Attribute}>}
 */
wrm.data.sync.BlobCache.prototype._extractCachableBlobAttribute = function(entity, object) {
  var result = [];
  entity.getAttributes().forEach(function(attr) {
    if (attr.getType() !== wrm.data.Type.BLOB) {
      return;
    }
    
    /* Extract the server file id */
    var serverFileIdAttr = attr.getMetaAttribute("serverFileId");
    var serverFileId = serverFileIdAttr && object[serverFileIdAttr.getName()];
    if (!serverFileId) {
      return;
    }
    
    result.push({serverFileId:serverFileId, attr:attr});
  });
  return result;
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.sync.BlobCache.prototype.clear = function() {
  this._cache = {};
};

/*
 * Change listener
 */

/**
 * @package
 * @return {!wrm.data.ChangeListener}
 */
wrm.data.sync.BlobCache.prototype.createChangeListener = function() {
  return new wrm.data.sync.BlobCache._ChangeListener(this);
};

/**
 * @private
 * @constructor
 * @implements wrm.data.ChangeListener
 * @param {!wrm.data.sync.BlobCache} blobCache
 */
wrm.data.sync.BlobCache._ChangeListener = function(blobCache) {
  
  /** @private */
  this._blobCache = blobCache;
};

/** @override */
wrm.data.sync.BlobCache._ChangeListener.prototype.getEntityListener = function(entity) {
  return new wrm.data.sync.BlobCache._ChangeListener.BlobChangeListener(entity, this._blobCache);
};

/** @override */
wrm.data.sync.BlobCache._ChangeListener.prototype.getAssociationListener = function(entity) {
  return null;
};

/**
 * @private
 * @constructor
 * @extends wrm.data.XDChangeTrackerAdapter
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.sync.BlobCache} blobCache
 */
wrm.data.sync.BlobCache._ChangeListener.BlobChangeListener = function(entity, blobCache) {
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._blobCache = blobCache;
  
  this.tracked = [entity.getKeyAttribute().getName()];
  if (entity.getServerKeyAttribute()) {
    this.tracked.push(entity.getServerKeyAttribute().getName());
  }
  
  this.trackedOld = [entity.getKeyAttribute().getName()];
  if (entity.getServerKeyAttribute()) {
    this.trackedOld.push(entity.getServerKeyAttribute().getName());
  }
};

/** @override */
wrm.data.sync.BlobCache._ChangeListener.BlobChangeListener.prototype.afterInsert = function(newInstance) {
  this._blobCache.register(this._entity, newInstance);
};

/** @override */
wrm.data.sync.BlobCache._ChangeListener.BlobChangeListener.prototype.afterUpdate = function(oldInstance, newInstance) {
  this._blobCache.register(this._entity, newInstance);
};

/** @override */
wrm.data.sync.BlobCache._ChangeListener.BlobChangeListener.prototype.afterDelete = function(oldInstance) {
};




//== wrm/data/meta/MigrationWay.js ============================================

wrm.data.meta = {};

/**
 * @enum {number}
 */
wrm.data.meta.MigrationWay = {LEAVING:-1, STAYING:0, ARRIVING:+1};




//== wrm/data/meta/Element.js =================================================



/**
 * @constructor
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.Element = function(id, descr, metadata) {
  
  /** @private */
  this._id = id;
  
  /**
   * @private
   * @type {string}
   */
  this._name = descr["name"];
  
  /**
   * @private
   * @type {?string}
   */
  this._serverName = descr["serverName"] || null;
  
  /**
   * @private
   * @type {boolean}
   */
  this._serverReadable = !!descr["serverName"] && descr["serverReadable"] !== false;
  
  /* Compute migration information */
  var migrationInfo = this._createMigrationInfo(descr);
  
  /** @private */
  this._migrationWay = migrationInfo.way;
  
  /** @private */
  this._migrationTempId = migrationInfo.tempId;
  
  /** @private */
  this._metadata = metadata;
  
  /** @private */
  this._descr = descr;
};

/**
 * @private
 * @param {!Object} descr
 * @return {{way:!wrm.data.meta.MigrationWay, tempId:?string}}
 */
wrm.data.meta.Element.prototype._createMigrationInfo = function(descr) {
  var way = !!descr["migrationWay"] ? wrm.util.obj.castEnumValue(wrm.data.meta.MigrationWay, descr["migrationWay"]) : wrm.data.meta.MigrationWay.STAYING;
  var tempId = descr["migrationTempId"] || null;
  
  /* Check consistency */
  if (way !== wrm.data.meta.MigrationWay.STAYING) {
    if (!tempId) {
      throw new Error("Missing migration id for non-staying element");
    }
  } else {
    if (tempId) {
      throw new Error("Unexpected migration id for staying element");
    }
  }
  
  return {way:way, tempId:tempId};
};

/**
 * @const
 * @return {undefined}
 */
wrm.data.meta.Element.prototype.init = function() {
  if (this._descr) {
    this.doInit(this._descr);
    this._descr = null;
  }
};

/**
 * @protected
 * @param {!Object} descr
 */
wrm.data.meta.Element.prototype.doInit = function(descr) {
};

/**
 * @const
 * @return {string}
 */
wrm.data.meta.Element.prototype.getId = function() {
  return this._id;
};

/**
 * @return {string}
 */
wrm.data.meta.Element.prototype.getName = function() {
  return this._name;
};

/**
 * @return {?string}
 */
wrm.data.meta.Element.prototype.getServerName = function() {
  return this._serverName;
};

/**
 * @return {boolean}
 */
wrm.data.meta.Element.prototype.isServerReadable = function() {
  return this._serverReadable;
};

/**
 * @const
 * @return {!wrm.data.meta.MigrationWay}
 */
wrm.data.meta.Element.prototype.getMigrationWay = function() {
  return this._migrationWay;
};

/**
 * @const
 * @return {?string}
 */
wrm.data.meta.Element.prototype.getMigrationTempId = function() {
  return this._migrationTempId;
};

/**
 * @internal
 * @const
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.meta.Element.prototype.getMetadata = function() {
  return this._metadata;
};

/** @override */
wrm.data.meta.Element.prototype.toString = function() {
  return this.getName() + " (" + this.getId() + ")";
};




//== wrm/data/meta/Property.js ================================================



/**
 * @constructor
 * @extends wrm.data.meta.Element
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.Property = function(id, descr, entity, metadata) {
  wrm.data.meta.Element.call(this, id, descr, metadata);
  
  /** @private */
  this._entity = entity;
};

extendConstructor(wrm.data.meta.Property, wrm.data.meta.Element);

/**
 * @return {!wrm.data.meta.Entity}}
 */
wrm.data.meta.Property.prototype.getEntity = function() {
  return this._entity;
};




//== wrm/data/meta/Attribute.js ===============================================



/**
 * @constructor
 * @extends wrm.data.meta.Property
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.Attribute = function(id, descr, entity, metadata) {
  wrm.data.meta.Property.call(this, id, descr, entity, metadata);
  
  /**
   * @private
   * @type {!wrm.data.Type}
   */
  this._type = wrm.util.obj.castEnumValue(wrm.data.Type, descr["type"]);
  
  /**
   * @private
   * @type {boolean}
   */
  this._key = descr["key"] || false;
  
  /**
   * @private
   * @type {boolean}
   */
  this._serverKey = descr["serverKey"] || false;
  
  /**
   * @private
   * @type {boolean}
   */
  this._indexed = descr["indexed"] || false;
  
  /**
   * @private
   * @type {boolean}
   */
  this._onFileSystem = descr["onFileSystem"] || false;
  
};

extendConstructor(wrm.data.meta.Attribute, wrm.data.meta.Property);

/**
 * @return {!wrm.data.Type}
 */
wrm.data.meta.Attribute.prototype.getType = function() {
  return this._type;
};

/**
 * @return {boolean}
 */
wrm.data.meta.Attribute.prototype.isKey = function() {
  return this._key;
};

/**
 * @return {boolean}
 */
wrm.data.meta.Attribute.prototype.isServerKey = function() {
  return this._serverKey;
};

/**
 * @return {boolean}
 */
wrm.data.meta.Attribute.prototype.isIndexed = function() {
  return this._indexed;
};

/**
 * @return {boolean}
 */
wrm.data.meta.Attribute.prototype.isOnFileSystem = function() {
  return this._onFileSystem;
};




//== wrm/data/meta/MetaAttribute.js ===========================================



/**
 * @constructor
 * @extends wrm.data.meta.Attribute
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.MetaAttribute = function(id, descr, entity, metadata) {
  wrm.data.meta.Attribute.call(this, id, descr, entity, metadata);
  
  /** @private */
  this._newId = descr["newId"];
  
  /* Register with the parent metadata */
  entity.registerAttribute(this);
};

extendConstructor(wrm.data.meta.MetaAttribute, wrm.data.meta.Attribute);

/**
 * @internal
 * @return {string}
 */
wrm.data.meta.MetaAttribute.prototype.getNewId = function() {
  return this._newId;
};




//== wrm/data/meta/AuxAttribute.js ============================================



/**
 * @constructor
 * @extends wrm.data.meta.Attribute
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.AuxEntity} entity
 * @param {boolean} cloakedLocal
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.AuxAttribute = function(id, descr, entity, cloakedLocal, metadata) {
  wrm.data.meta.Attribute.call(this, id, descr, entity, metadata);
  
  /* Register with the parent metadata */
  entity.registerAttribute(this, true, cloakedLocal);
};

extendConstructor(wrm.data.meta.AuxAttribute, wrm.data.meta.Attribute);




//== wrm/data/meta/RegularAttribute.js ========================================



/**
 * @constructor
 * @extends wrm.data.meta.Attribute
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.RegularAttribute = function(id, descr, entity, auxEntity, metadata) {
  wrm.data.meta.Attribute.call(this, id, descr, entity, metadata);
  
  /**
   * @private
   * @type {boolean}
   */
  this._createTimestamp = descr["createTS"] || false;
  
  /**
   * @private
   * @type {boolean}
   */
  this._updateTimestamp = descr["updateTS"] || false;
  
  /** @private */
  this._trackerAttribute = this._createTrackerAttribute(descr["trackerName"] || null, auxEntity);
  
  /** @private */
  this._dirtyAttribute = this._createDirtyAttribute(descr["dirtyName"] || null, auxEntity);
  
  /** @private */
  this._metaAttributes = this._createMetaAttributes(descr["meta"] || {}, entity);
  
  /* Register with the parent metadata */
  entity.registerAttribute(this);
};

extendConstructor(wrm.data.meta.RegularAttribute, wrm.data.meta.Attribute);

/**
 * @private
 * @param {?string} tAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularAttribute.prototype._createTrackerAttribute = function(tAttrName, auxEntity) {
  if (!tAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for attribute " + this);
  }
  
  /* Create an attribute descriptor based on this attribute */
  var tAttrId = "_track_" + this.getId();
  var tAttrDescr = {};
  tAttrDescr["name"] = tAttrName;
  tAttrDescr["type"] = this.getType();
  
  return new wrm.data.meta.AuxAttribute(tAttrId, tAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?string} dAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularAttribute.prototype._createDirtyAttribute = function(dAttrName, auxEntity) {
  if (!dAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for attribute " + this);
  }
  
  /* Create an attribute descriptor */
  var dAttrId = "_dirty_" + this.getId();
  var dAttrDescr = {};
  dAttrDescr["name"] = dAttrName;
  dAttrDescr["type"] = wrm.data.Type.BOOLEAN;
  
  return new wrm.data.meta.AuxAttribute(dAttrId, dAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Object.<string,!wrm.data.meta.MetaAttribute>}
 */
wrm.data.meta.RegularAttribute.prototype._createMetaAttributes = function(descr, entity) {
  var result = {};
  
  var attrId = this.getId();
  var metadata = this.getMetadata();
  Object.keys(descr).forEach(function(family) {
    var maDescr = descr[family];
    
    /* Create a descriptor based on this attribute */
    var maAttrId = "_meta_" + family + "_" + attrId;
    var maAttrDescr = {};
    maAttrDescr["name"] = maDescr["name"];
    maAttrDescr["type"] = maDescr["type"];
    maAttrDescr["newId"] = attrId + "#" + family.replace(/^serverFileId$/, "remoteFileId");
    
    result[family] = new wrm.data.meta.MetaAttribute(maAttrId, maAttrDescr, entity, metadata);
  });
  
  return result;
};

/**
 * @return {boolean}
 */
wrm.data.meta.RegularAttribute.prototype.isCreateTimestamp = function() {
  return this._createTimestamp;
};

/**
 * @return {boolean}
 */
wrm.data.meta.RegularAttribute.prototype.isUpdateTimestamp = function() {
  return this._updateTimestamp;
};

/**
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularAttribute.prototype.getTrackerAuxiliaryAttribute = function() {
  return this._trackerAttribute;
};

/**
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularAttribute.prototype.getDirtyAuxiliaryAttribute = function() {
  return this._dirtyAttribute;
};

/**
 * @param {string} family
 * @return {?wrm.data.meta.MetaAttribute}
 */
wrm.data.meta.RegularAttribute.prototype.getMetaAttribute = function(family) {
  return this._metaAttributes[family] || null;
};




//== wrm/data/meta/Role.js ====================================================



/**
 * @constructor
 * @extends wrm.data.meta.Property
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.Role = function(id, descr, entity, metadata) {
  wrm.data.meta.Property.call(this, id, descr, entity, metadata);
  
  /**
   * @private
   * @type {!wrm.data.meta.Association}
   */
  this._assoc;
  
  /**
   * @private
   * @type {boolean}
   */
  this._many = this._createCardinalityMany(descr);
  
  /**
   * @private
   * @type {string}
   */
  this._inverseRoleId = descr["inverse"];
  
  /**
   * @private
   * @type {?wrm.data.meta.Role}
   */
  this._inverseRole = null;
  
  /**
   * @private
   * @type {?string}
   */
  this._foreignKeyName = descr["foreignKeyName"] || null;
};

extendConstructor(wrm.data.meta.Role, wrm.data.meta.Property);

/**
 * @private
 * @param {!Object} descr
 * @return {boolean}
 */
wrm.data.meta.Role.prototype._createCardinalityMany = function(descr) {
  var many = descr["many"];
  if (typeof many === "boolean") {
    return many;
  }
  return !descr["foreignKeyName"];
};

/**
 * @package
 * @param {!wrm.data.meta.Association} assoc
 */
wrm.data.meta.Role.prototype.initAssociation = function(assoc) {
  if (this._assoc) {
    throw new Error("Association already initialized");
  }
  this._assoc = assoc;
};

/**
 * @package
 * @param {!wrm.data.meta.Role} inverseRole
 */
wrm.data.meta.Role.prototype.initInverseRole = function(inverseRole) {
  if (this._inverseRole) {
    throw new Error("Inverse role already initialized");
  }
  if (inverseRole._inverseRole) {
    throw new Error("Inverse role already initialized on the inverse being set");
  }
  this._inverseRole = inverseRole;
  inverseRole._inverseRole = this;
};

/**
 * @return {boolean}
 */
wrm.data.meta.Role.prototype.isMany = function() {
  return this._many;
};

/**
 * @return {!wrm.data.meta.Association}
 */
wrm.data.meta.Role.prototype.getAssociation = function() {
  return this._assoc;
};

/**
 * @return {!wrm.data.meta.Role}
 */
wrm.data.meta.Role.prototype.getInverseRole = function() {
  var inverseRole = this._inverseRole;
  if (!inverseRole) {
    this._inverseRole = inverseRole = this.getMetadata().getRole(this._inverseRoleId);
  }
  return inverseRole;
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.meta.Role.prototype.getInverseEntity = function() {
  return this.getInverseRole().getEntity();
};

/**
 * @return {boolean}
 */
wrm.data.meta.Role.prototype.isForeignKey = function() {
  return !!this._foreignKeyName;
};

/**
 * @return {?string}
 */
wrm.data.meta.Role.prototype.getForeignKeyName = function() {
  return this._foreignKeyName;
};




//== wrm/data/meta/AuxRole.js =================================================



/**
 * @constructor
 * @extends wrm.data.meta.Role
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {boolean} cloakedLocal
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.AuxRole = function(id, descr, entity, cloakedLocal, metadata) {
  wrm.data.meta.Role.call(this, id, descr, entity, metadata);
  
  /* Register with the parent metadata */
  entity.registerRole(this, true, cloakedLocal);
};

extendConstructor(wrm.data.meta.AuxRole, wrm.data.meta.Role);




//== wrm/data/meta/RegularRole.js =============================================



/**
 * @constructor
 * @extends wrm.data.meta.Role
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.RegularRole = function(id, descr, entity, auxEntity, metadata) {
  wrm.data.meta.Role.call(this, id, descr, entity, metadata);
  
  /** @private */
  this._auxEntity = auxEntity;
  
  /** @private */
  this._addTimestampAttriubte = this._createAddTimestampAttribute(descr["addTimestampName"] || null, auxEntity);
  
  /** @private */
  this._removeTimestampAttriubte = this._createRemoveTimestampAttribute(descr["removeTimestampName"] || null, auxEntity);
  
  /**
   * @private
   * @type {?wrm.data.meta.AuxAttribute}
   */
  this._serverTrackerAttriubte;
  
  /** @private */
  this._bridgeHeadRole = this._createBridgeHeadRole(descr["bridgeHeadRole"] || null);
  
  /* Register with the parent metadata */
  entity.registerRole(this);
};

extendConstructor(wrm.data.meta.RegularRole, wrm.data.meta.Role);

/**
 * @private
 * @param {?string} stAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularRole.prototype._createServerTrackerAttribute = function(stAttrName, auxEntity) {
  if (!stAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for role " + this);
  }
  
  /* Create an attribute descriptor based on the pointed entity */
  var stAttrId = "_track_" + this.getId();
  var stAttrDescr = {};
  stAttrDescr["name"] = stAttrName;
  stAttrDescr["type"] = this.getInverseEntity().getServerKeyAttribute().getType();
  
  return new wrm.data.meta.AuxAttribute(stAttrId, stAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?string} atAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularRole.prototype._createAddTimestampAttribute = function(atAttrName, auxEntity) {
  if (!atAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for role " + this);
  }
  
  /* Create an attribute descriptor */
  var atAttrId = "_addts_" + this.getId();
  var atAttrDescr = {};
  atAttrDescr["name"] = atAttrName;
  atAttrDescr["type"] = wrm.data.Type.TIMESTAMP;
  
  return new wrm.data.meta.AuxAttribute(atAttrId, atAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?string} rtAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularRole.prototype._createRemoveTimestampAttribute = function(rtAttrName, auxEntity) {
  if (!rtAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for role " + this);
  }
  
  /* Create an attribute descriptor */
  var rtAttrId = "_remts_" + this.getId();
  var rtAttrDescr = {};
  rtAttrDescr["name"] = rtAttrName;
  rtAttrDescr["type"] = wrm.data.Type.TIMESTAMP;
  
  return new wrm.data.meta.AuxAttribute(rtAttrId, rtAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?Object} descr
 * @return {?wrm.data.meta.AuxRole}
 */
wrm.data.meta.RegularRole.prototype._createBridgeHeadRole = function(descr) {
  if (descr) {
    return new wrm.data.meta.AuxRole("_brdgh_" + this.getId(), descr, this.getEntity(), true, this.getMetadata());
  }
  return null;
};

/**
 * @protected
 * @override
 */
wrm.data.meta.RegularRole.prototype.doInit = function(descr) {
  wrm.data.meta.RegularRole._super.doInit.call(this, descr);
  this._serverTrackerAttriubte = this._createServerTrackerAttribute(descr["serverTrackerName"] || null, this._auxEntity);
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.RegularRole.prototype.getAddTimestampAuxiliaryAttribute = function() {
  return this._addTimestampAttriubte;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.RegularRole.prototype.getRemoveTimestampAuxiliaryAttribute = function() {
  return this._removeTimestampAttriubte;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.RegularRole.prototype.getServerTrackerAuxiliaryAttribute = function() {
  return this._serverTrackerAttriubte;
};

/**
 * @return {?wrm.data.meta.AuxRole}
 */
wrm.data.meta.RegularRole.prototype.getBridgeHeadRole = function() {
  return this._bridgeHeadRole;
};




//== wrm/data/meta/Entity.js ==================================================



/**
 * @constructor
 * @extends wrm.data.meta.Element
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.Entity = function(id, descr, metadata) {
  wrm.data.meta.Element.call(this, id, descr, metadata);
  
  /**
   * @private
   * @type {string}
   */
  this._setName = descr["setName"];
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Attribute>}
   */
  this._attributesById = {};
  
  /**
   * @private
   * @type {?Array<!wrm.data.meta.Attribute>}
   */
  this._attributesList = null;
  
  /**
   * @private
   * @type {?wrm.data.meta.Attribute}
   */
  this._keyAttribute = null;
  
  /**
   * @private
   * @type {?wrm.data.meta.Attribute}
   */
  this._serverKeyAttribute = null;
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Attribute>}
   */
  this._metaAttributesById = {};
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Role>}
   */
  this._rolesById = {};
  
  /**
   * @private
   * @type {?Array<!wrm.data.meta.Role>}
   */
  this._rolesList = null;
  
  /**
   * @private
   * @type {?Array.<!wrm.data.meta.Association>}
   */
  this._assocs = null;
  
  /**
   * @private
   * @type {!Array.<!wrm.data.meta.Role>}
   */
  this._foreignKeyRoles = [];
  
};

extendConstructor(wrm.data.meta.Entity, wrm.data.meta.Element);

/**
 * @protected
 * @param {!Object} descr
 * @param {?wrm.data.meta.AuxEntity=} auxEntity
 */
wrm.data.meta.Entity.prototype.createAttributes = function(descr, auxEntity) {
  var md = this.getMetadata();
  angular.forEach(descr, function(attributeDescr, attributeId) {
    new wrm.data.meta.RegularAttribute(attributeId, attributeDescr, this, auxEntity || null, md);
  }, this);
};

/**
 * @protected
 * @param {!Object} descr
 * @param {?wrm.data.meta.AuxEntity=} auxEntity
 */
wrm.data.meta.Entity.prototype.createRoles = function(descr, auxEntity) {
  var md = this.getMetadata();
  angular.forEach(descr, function(roleDescr, roleId) {
    new wrm.data.meta.RegularRole(roleId, roleDescr, this, auxEntity || null, md);
  }, this);
};

/**
 * @protected
 * @override
 */
wrm.data.meta.Entity.prototype.doInit = function(descr) {
  wrm.data.meta.Entity._super.doInit.call(this, descr);
  
  /* Initialize properties */
  this.getProperties().forEach(function(property) {
    property.init();
  });
};

/**
 * @return {string}
 */
wrm.data.meta.Entity.prototype.getSetName = function() {
  return this._setName;
};

/**
 * @return {!Array.<!wrm.data.meta.Property>}
 */
wrm.data.meta.Entity.prototype.getProperties = function() {
  return this.getAttributes().concat(this.getRoles());
};

/**
 * @param {string} propertyId
 * @param {boolean=} includeMetaAttributes
 * @return {!wrm.data.meta.Property}
 */
wrm.data.meta.Entity.prototype.getProperty = function(propertyId, includeMetaAttributes) {
  var result = this._attributesById[propertyId] || this._rolesById[propertyId];
  if (!result && includeMetaAttributes) {
    result = this._metaAttributesById[propertyId];
  }
  if (!result) {
    throw new Error("Unknown property '" + propertyId + "' in entity " + this);
  }
  return result;
};

/**
 * @return {!Array.<!wrm.data.meta.Attribute>}
 */
wrm.data.meta.Entity.prototype.getAttributes = function() {
  if (!this._attributesList) {
    this._attributesList = Object.keys(this._attributesById).map(function(attrId) {
      return this._attributesById[attrId];
    }, this);
  }
  return this._attributesList;
};

/**
 * @param {string=} family
 * @return {!Array.<!wrm.data.meta.Attribute>}
 */
wrm.data.meta.Entity.prototype.getMetaAttributes = function(family) {
  var result = [];
  angular.forEach(this._metaAttributesById, function(attribute) {
    result.push(attribute);
  });
  return result;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.Entity.prototype.getKeyAttribute = function() {
  return this._keyAttribute;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.Entity.prototype.getServerKeyAttribute = function() {
  return this._serverKeyAttribute;
};

/**
 * @param {string} attributeId
 * @param {boolean=} includeMetaAttributes
 * @return {!wrm.data.meta.Attribute}
 */
wrm.data.meta.Entity.prototype.getAttribute = function(attributeId, includeMetaAttributes) {
  var result = this._attributesById[attributeId];
  if (!result && includeMetaAttributes) {
    result = this._metaAttributesById[attributeId];
  }
  if (!result) {
    throw new Error("Unknown attribute '" + attributeId + "' in entity " + this);
  }
  return result;
};

/**
 * @return {!Array.<!wrm.data.meta.Role>}
 */
wrm.data.meta.Entity.prototype.getRoles = function() {
  if (!this._rolesList) {
    this._rolesList = Object.keys(this._rolesById).map(function(roleId) {
      return this._rolesById[roleId];
    }, this);
  }
  return this._rolesList;
};

/**
 * @param {string} roleId
 * @return {!wrm.data.meta.Role}
 */
wrm.data.meta.Entity.prototype.getRole = function(roleId) {
  var result = this._rolesById[roleId];
  if (!result) {
    throw new Error("Unknown role '" + roleId + "' in entity " + this);
  }
  return result;
};

/**
 * @return {!Array.<!wrm.data.meta.Role>}
 */
wrm.data.meta.Entity.prototype.getForeignKeyRoles = function() {
  return this._foreignKeyRoles;
};

/**
 * @return {!Array.<!wrm.data.meta.Association>}
 */
wrm.data.meta.Entity.prototype.getAssociations = function() {
  var assocs = this._assocs;
  if (assocs) {
    return assocs;
  }
  
  /* Find associations from the roles attached to this entity */
  var assocsSet = {};
  assocs = [];
  this.getRoles().forEach(function(role) {
    var assoc = role.getAssociation();
    var assocId = assoc.getId();
    if (assocsSet[assocId] === true) {
      return;
    }
    assocsSet[assocId] = true;
    assocs.push(assoc);
  });
  
  this._assocs = assocs;
  return assocs;
};

/*
 * Internal registration/retrieval
 */

/**
 * @package
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {boolean=} cloakedGlobal
 * @param {boolean=} cloakedLocal
 */
wrm.data.meta.Entity.prototype.registerAttribute = function(attribute, cloakedGlobal, cloakedLocal) {
  
  /* Check consistency first (for atomicity) */
  if (attribute.isKey() && this._keyAttribute) {
    throw new Error("Entity already has a key attribute");
  }
  if (attribute.isServerKey() && this._serverKeyAttribute) {
    throw new Error("Entity already has a server key attribute");
  }
  
  if (attribute instanceof wrm.data.meta.MetaAttribute) {
    this._doRegisterElement(this._metaAttributesById, attribute, cloakedLocal);
  } else {
    this._doRegisterElement(this._attributesById, attribute, cloakedLocal);
    this._attributesList = null;
  }
  
  if (attribute.isKey()) {
    this._keyAttribute = attribute;
  }
  if (attribute.isServerKey()) {
    this._serverKeyAttribute = attribute;
  }
  
  this.getMetadata().registerAttribute(attribute, cloakedGlobal);
};

/**
 * @package
 * @param {!wrm.data.meta.Role} role
 * @param {boolean=} cloakedGlobal
 * @param {boolean=} cloakedLocal
 */
wrm.data.meta.Entity.prototype.registerRole = function(role, cloakedGlobal, cloakedLocal) {
  this._doRegisterElement(this._rolesById, role, cloakedLocal);
  
  this._rolesList = null;
  this._assocs = null;
  
  if (role.isForeignKey()) {
    this._foreignKeyRoles.push(role);
  }
  
  this.getMetadata().registerRole(role, cloakedGlobal);
};

/**
 * @private
 * @template E
 * @param {!Object.<string,E>} map
 * @param {!E} element
 * @param {boolean=} cloaked
 */
wrm.data.meta.Entity.prototype._doRegisterElement = function(map, element, cloaked) {
  if (!cloaked) {
    map[element.getId()] = element;
  }
  if (this._initd) {
    element.init();
  }
};




//== wrm/data/meta/AuxEntity.js ===============================================



/**
 * @constructor
 * @extends wrm.data.meta.Entity
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.AuxEntity = function(id, descr, metadata) {
  wrm.data.meta.Entity.call(this, id, descr, metadata);
  
  /* Init */
  this.createAttributes(descr["attributes"] || {});
  this.createRoles(descr["roles"] || {});
  
  /* Register with the parent metadata */
  metadata.registerEntity(this);
};

extendConstructor(wrm.data.meta.AuxEntity, wrm.data.meta.Entity);




//== wrm/data/meta/RegularEntity.js ===========================================



/**
 * @constructor
 * @extends wrm.data.meta.Entity
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.RegularEntity = function(id, descr, metadata) {
  wrm.data.meta.Entity.call(this, id, descr, metadata);
  
  /**
   * @private
   * @type {?wrm.data.meta.Attribute}
   */
  this._createTimestampAttribute = null;
  
  /**
   * @private
   * @type {?wrm.data.meta.Attribute}
   */
  this._updateTimestampAttribute = null;
  
  /** @private */
  this._auxEntity = this._createAuxEntity(descr["auxEntity"] || null);
  
  /** @private */
  this._dirtyAttribute = this._createDirtyAttribute(descr["dirtyName"] || null, this._auxEntity);
  
  /** @private */
  this._deleteTimestampAttribute = this._createDeleteTimestampAttribute(descr["deleteTimestampName"] || null, this._auxEntity);
  
  /* Init */
  this.createAttributes(descr["attributes"] || {}, this._auxEntity);
  this.createRoles(descr["roles"] || {}, this._auxEntity);
  
  /* Check consistency */
  if (this.getId() !== wrm.Constants.USER_ENT_ID && this.getServerName() && !this.getServerKeyAttribute()) {
    throw new Error("Server-mapped entity " + this + " has no server key attribute");
  }
  
  /* Register with the parent metadata */
  metadata.registerEntity(this);
};

extendConstructor(wrm.data.meta.RegularEntity, wrm.data.meta.Entity);

/**
 * @private
 * @param {?Object} descr
 * @return {?wrm.data.meta.AuxEntity}
 */
wrm.data.meta.RegularEntity.prototype._createAuxEntity = function(descr) {
  if (descr) {
    return new wrm.data.meta.AuxEntity("_aux_" + this.getId(), descr, this.getMetadata());
  }
  return null;
};

/**
 * @private
 * @param {?string} dAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularEntity.prototype._createDirtyAttribute = function(dAttrName, auxEntity) {
  if (!dAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for entity " + this);
  }
  
  /* Create an attribute descriptor */
  var dAttrId = this.getId() + "_dirty";
  var dAttrDescr = {};
  dAttrDescr["name"] = dAttrName;
  dAttrDescr["type"] = wrm.data.Type.BOOLEAN;
  
  return new wrm.data.meta.AuxAttribute(dAttrId, dAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?string} dtAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularEntity.prototype._createDeleteTimestampAttribute = function(dtAttrName, auxEntity) {
  if (!dtAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for entity " + this);
  }
  
  /* Create an attribute descriptor */
  var dtAttrId = this.getId() + "_deletedAt";
  var dtAttrDescr = {};
  dtAttrDescr["name"] = dtAttrName;
  dtAttrDescr["type"] = wrm.data.Type.TIMESTAMP;
  
  return new wrm.data.meta.AuxAttribute(dtAttrId, dtAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.RegularEntity.prototype.getCreateTimestampAttribute = function() {
  return this._createTimestampAttribute;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.RegularEntity.prototype.getUpdateTimestampAttribute = function() {
  return this._updateTimestampAttribute;
};

/**
 * @return {?wrm.data.meta.AuxEntity}
 */
wrm.data.meta.RegularEntity.prototype.getAuxiliaryEntity = function() {
  return this._auxEntity;
};

/**
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularEntity.prototype.getDirtyAuxiliaryAttribute = function() {
  return this._dirtyAttribute;
};

/**
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.RegularEntity.prototype.getDeleteTimestampAuxiliaryAttribute = function() {
  return this._deleteTimestampAttribute;
};

/*
 * Internal registration/retrieval
 */

/** @override */
wrm.data.meta.RegularEntity.prototype.registerAttribute = function(attribute) {
  var createTimestamp = false, updateTimestamp = false;
  if (attribute instanceof wrm.data.meta.RegularAttribute) {
    createTimestamp = attribute.isCreateTimestamp();
    updateTimestamp = attribute.isUpdateTimestamp();
  }
  
  /* Check consistency first (for atomicity) */
  if (createTimestamp && this._createTimestampAttribute) {
    throw new Error("Entity already has a create timestamp attribute");
  }
  if (updateTimestamp && this._updateTimestampAttribute) {
    throw new Error("Entity already has an update timestamp attribute");
  }
  
  wrm.data.meta.RegularEntity._super.registerAttribute.call(this, attribute);
  
  if (createTimestamp) {
    this._createTimestampAttribute = attribute;
  }
  if (updateTimestamp) {
    this._updateTimestampAttribute = attribute;
  }
};




//== wrm/data/meta/Association.js =============================================



/**
 * @constructor
 * @extends wrm.data.meta.Element
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.Association = function(id, descr, metadata) {
  wrm.data.meta.Element.call(this, id, descr, metadata);
  
  /**
   * @private
   * @type {!wrm.data.meta.Role}
   */
  this._role1;
  
  /**
   * @private
   * @type {!wrm.data.meta.Role}
   */
  this._role2;
};

extendConstructor(wrm.data.meta.Association, wrm.data.meta.Element);

/**
 * @package
 * @param {!wrm.data.meta.Role} role1
 * @param {!wrm.data.meta.Role} role2
 */
wrm.data.meta.Association.prototype.initRoles = function(role1, role2) {
  if (this._role1 || this._role2) {
    throw new Error("Roles already initialized");
  }
  this._role1 = role1;
  role1.initAssociation(this);
  this._role2 = role2;
  role2.initAssociation(this);
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.meta.Association.prototype.getEntity1 = function() {
  return this._role1.getEntity();
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.meta.Association.prototype.getEntity2 = function() {
  return this._role2.getEntity();
};

/**
 * @param {string} entityId
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.meta.Association.prototype.getEntity = function(entityId) {
  if (entityId === this._role1.getEntity().getId()) {
    return this._role1.getEntity();
  } else {
    if (entityId === this._role2.getEntity().getId()) {
      return this._role2.getEntity();
    }
  }
  throw new Error("Unknown entity '" + entityId + "' connected to association " + this);
};

/**
 * @return {!wrm.data.meta.Role}
 */
wrm.data.meta.Association.prototype.getRole1 = function() {
  return this._role1;
};

/**
 * @return {!wrm.data.meta.Role}
 */
wrm.data.meta.Association.prototype.getRole2 = function() {
  return this._role2;
};




//== wrm/data/meta/AuxAssociation.js ==========================================



/**
 * @constructor
 * @extends wrm.data.meta.Association
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.AuxAssociation = function(id, descr, metadata) {
  wrm.data.meta.Association.call(this, id, descr, metadata);
  
  /* Register with the parent metadata */
  metadata.registerAssociation(this, true);
};

extendConstructor(wrm.data.meta.AuxAssociation, wrm.data.meta.Association);




//== wrm/data/meta/RegularAssociation.js ======================================



/**
 * @constructor
 * @extends wrm.data.meta.Association
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.RegularAssociation = function(id, descr, metadata) {
  wrm.data.meta.Association.call(this, id, descr, metadata);
  
  /**
   * @private
   * @type {?wrm.data.meta.BridgeEntity}
   */
  this._bridgeEntity;
  
  /**
   * @private
   * @type {?wrm.data.meta.AuxAssociation}
   */
  this._hemiAssoc1;
  
  /**
   * @private
   * @type {?wrm.data.meta.AuxAssociation}
   */
  this._hemiAssoc2;
  
  /* Register with the parent metadata */
  metadata.registerAssociation(this);
};

extendConstructor(wrm.data.meta.RegularAssociation, wrm.data.meta.Association);

/**
 * @protected
 * @override
 */
wrm.data.meta.RegularAssociation.prototype.doInit = function(descr) {
  wrm.data.meta.RegularAssociation._super.doInit.call(this, descr);
  
  /* Find the endpoint roles */
  var md = this.getMetadata();
  var roleIds = descr["roles"] || [];
  var role1 = roleIds[0] && md.getRole(roleIds[0]);
  if (!role1) {
    throw new Error("Missing or invalid role 1 '" + roleIds[0] + "'");
  }
  var role2 = roleIds[1] && md.getRole(roleIds[1]);
  if (!role2) {
    throw new Error("Missing or invalid role 2 '" + roleIds[1] + "'");
  }
  this.initRoles(role1, role2);
  
  this._bridgeEntity = this._createBridgeEntity(descr["bridgeEntity"] || null, role1, role2);
  
  var hemiAssocs = this._createHemiAssociations(this._bridgeEntity);
  this._hemiAssoc1 = hemiAssocs && hemiAssocs[0];
  this._hemiAssoc2 = hemiAssocs && hemiAssocs[1];
};

/**
 * @private
 * @param {?Object} descr
 * @param {!wrm.data.meta.Role} role1
 * @param {!wrm.data.meta.Role} role2
 * @return {?wrm.data.meta.BridgeEntity}
 */
wrm.data.meta.RegularAssociation.prototype._createBridgeEntity = function(descr, role1, role2) {
  if (descr) {
    return new wrm.data.meta.BridgeEntity("_brdg_" + this.getId(), descr, role1, role2, this.getMetadata());
  }
  return null;
};

/**
 * @private
 * @param {?wrm.data.meta.BridgeEntity} bEntity
 * @return {?Array.<!wrm.data.meta.AuxAssociation>}
 */
wrm.data.meta.RegularAssociation.prototype._createHemiAssociations = function(bEntity) {
  if (!bEntity) {
    return null;
  }
  
  var assocId = this.getId();
  var assocName = this.getName();
  var bRole1 = bEntity.getRole1();
  var bRole2 = bEntity.getRole2();
  var md = this.getMetadata();
  
  var hemiAssoc1 = new wrm.data.meta.AuxAssociation(assocId + "_1", {"name":assocName + "_half_1"}, md);
  hemiAssoc1.initRoles(bRole1.getInverseRole(), bRole1);
  
  var hemiAssoc2 = new wrm.data.meta.AuxAssociation(assocId + "_2", {"name":assocName + "_half_2"}, md);
  hemiAssoc2.initRoles(bRole2, bRole2.getInverseRole());
  
  return [hemiAssoc1, hemiAssoc2];
};

/**
 * @return {?wrm.data.meta.BridgeEntity}
 */
wrm.data.meta.RegularAssociation.prototype.getBridgeEntity = function() {
  return this._bridgeEntity;
};

/**
 * @return {?wrm.data.meta.AuxAssociation}
 */
wrm.data.meta.RegularAssociation.prototype.getHemiAssociation1 = function() {
  return this._hemiAssoc1;
};

/**
 * @return {?wrm.data.meta.AuxAssociation}
 */
wrm.data.meta.RegularAssociation.prototype.getHemiAssociation2 = function() {
  return this._hemiAssoc2;
};




//== wrm/util/Semaphore.js ====================================================


/**
 * @internal
 * @constructor
 * @class A semaphore that holds a fixed amount of permits.
 *        <p>
 *        Clients need to first {@link #acquire} a permit and {@link #release} it when done. When there are no permits available, the
 *        callers get a promise that is resolved when their turn comes. Waiting clients are served with FIFO policy.
 * @param {number} permits Number of permits available in the semaphore. Must be at least 1.
 */
wrm.util.Semaphore = function(permits) {
  if (permits < 1) {
    throw new Error("Must supply at least 1 permit");
  }
  
  /** @private */
  this._total = permits;
  
  /** @private */
  this._free = permits;
  
  /** @private {!Array<function()>} */
  this._queue = [];
};

/**
 * @return {!Promise}
 */
wrm.util.Semaphore.prototype.acquire = function() {
  var $jscomp$this = this;
  
  /* Let the caller proceed if a permit is already available */
  if (this._free > 0) {
    this._free--;
    return Promise.resolve();
  }
  
  /* No permits available: queue the caller */
  return new Promise(function(resolve) {
    $jscomp$this._queue.push(resolve);
  });
};

/**
 * @return {undefined}
 * @throws {!Error} if attempting to release when no permit is acquired.
 */
wrm.util.Semaphore.prototype.release = function() {
  
  /* Serve the first waiting caller. If no one is waiting, increase the number of available permits */
  if (this._queue.length > 0) {
    var resolve = this._queue.shift();
    resolve();
  } else {
    if (this._free < this._total) {
      this._free++;
    } else {
      throw new Error("No permits to release");
    }
  }
};




//== wrm/data/sync/EntityOrchestrator.js ======================================



/**
 * @package
 * @class Regulates the synchronization of multiple entities, ensuring that they run in the most appropriate order.
 * @param {!Array<!wrm.data.meta.RegularEntity>} entities
 * @param {boolean} preserveOrder
 * @param {number} maxParallelSynchronizations
 * @constructor
 */
wrm.data.sync.EntityOrchestrator = function(entities, preserveOrder, maxParallelSynchronizations) {
  
  /** @private {!Object<string, function()>} */
  this._functions = {};
  
  /** @private {!Object<string, !Promise>} */
  this._promises = {};
  
  /** @private {!Object<string, !Object<string, boolean>>} */
  this._requiredEntityIds = {};
  
  /** @private {!Object<string, boolean>} */
  this._registeredEntityIdsSet = {};
  
  /** @private */
  this._semaphore = new wrm.util.Semaphore(maxParallelSynchronizations);
  
  /** @private {!Object<string, !Promise>} */
  this._startPromises = {};
  
  /** @private */
  this._entities = entities;
  
  if (preserveOrder) {
    this._initPreservingOrder(entities);
  } else {
    this._init(entities);
  }
  
};

/**
 * Initialize computing the dependences sorting.
 * 
 * @private
 * @param {!Array<!wrm.data.meta.Entity>} entities
 */
wrm.data.sync.EntityOrchestrator.prototype._init = function(entities) {
  
  /* retrieve involved mapped associations */
  var assocs = [];
  var assocsSet = {};
  entities.forEach(function(entity) {
    
    entity.getRoles().forEach(function(role) {
      var assoc = role.getAssociation();
      var assocId = assoc.getId();
      if (assocsSet[assocId] === true) {
        return;
      }
      assocsSet[assocId] = true;
      if (!role.getServerName() && !role.getInverseRole().getServerName()) {
        return;
      }
      var inverseEntity = role.getInverseEntity();
      if (entity === inverseEntity) {
        return;
      }
      if (entities.indexOf(inverseEntity) < 0) {
        return;
      }
      assocs.push(assoc);
      
    }, this);
    
  }, this);
  
  /* register dependences */
  assocs.forEach(function(assoc) {
    
    /* compare */
    var c = this._compare(assoc);
    if (c === 0) {
      return;
    }
    
    /* register dependence */
    if (c === -1) {
      this._registerDependence(assoc.getEntity1(), assoc.getEntity2());
    } else {
      this._registerDependence(assoc.getEntity2(), assoc.getEntity1());
    }
    
  }, this);
  
  /* remove deadlocks */
  this._removeDeadlocks();
};

/**
 * Initialize preserving the given order.
 * 
 * @private
 * @param {!Array<!wrm.data.meta.RegularEntity>} entities
 */
wrm.data.sync.EntityOrchestrator.prototype._initPreservingOrder = function(entities) {
  var lastEntity = null;
  entities.forEach(function(entity) {
    if (lastEntity) {
      
      /* force dependence */
      this._registerDependence(entity, lastEntity);
    }
    lastEntity = entity;
  }, this);
};

/**
 * Returns -1 if entity1 depends on entity2, 1 if entity2 depends on entity1, 0 otherwise.
 * 
 * @private
 * @param {!wrm.data.meta.RegularAssociation} assoc
 * @return {number}
 */
wrm.data.sync.EntityOrchestrator.prototype._compare = function(assoc) {
  var role1 = assoc.getRole1();
  var role2 = assoc.getRole2();
  var isMapped1 = role1.getServerName() !== null;
  var isMapped2 = role2.getServerName() !== null;
  if (isMapped1 && !isMapped2) {
    return -1;
  }
  if (!isMapped1 && isMapped2) {
    return 1;
  }
  /* isMapped1 && isMapped2 always! */
  var isForeignKey1 = role1.isForeignKey();
  var isForeignKey2 = role2.isForeignKey();
  if (isForeignKey1 && !isForeignKey2) {
    return -1;
  }
  if (!isForeignKey1 && isForeignKey2) {
    return 1;
  }
  return 0;
};

/**
 * Remove deadlocks
 * 
 * @private
 */
wrm.data.sync.EntityOrchestrator.prototype._removeDeadlocks = function() {
  Object.keys(this._requiredEntityIds).forEach(function(entityId) {
    this._doRemoveDeadlocks(entityId, entityId, {});
  }, this);
};

/**
 * Remove deadlocks starting from a given entityId
 * 
 * @private
 * @param {string} entityId
 * @param {string} fromEntityId
 * @param {!Object<string, boolean>} visited
 */
wrm.data.sync.EntityOrchestrator.prototype._doRemoveDeadlocks = function(entityId, fromEntityId, visited) {
  if (visited[fromEntityId] === true) {
    return;
  }
  visited[fromEntityId] = true;
  var rqEntityIds = this._requiredEntityIds[fromEntityId];
  if (!rqEntityIds) {
    return;
  }
  delete rqEntityIds[entityId];
  Object.keys(rqEntityIds).forEach(function(requiredEntityId) {
    this._doRemoveDeadlocks(entityId, requiredEntityId, visited);
  }, this);
};

/**
 * Register entity1 requires entity2.
 * 
 * @private
 * @param {!wrm.data.meta.RegularEntity} entity1
 * @param {!wrm.data.meta.RegularEntity} entity2
 */
wrm.data.sync.EntityOrchestrator.prototype._registerDependence = function(entity1, entity2) {
  var entity1Id = entity1.getId();
  var entity2Id = entity2.getId();
  
  /* save entity1 requires entity2 */
  var rqEntityIds = this._requiredEntityIds[entity1Id];
  if (!rqEntityIds) {
    this._requiredEntityIds[entity1Id] = rqEntityIds = {};
  }
  rqEntityIds[entity2Id] = true;
  
  /* prepare promises and functions for these 2 entities */
  if (this._registeredEntityIdsSet[entity1Id] !== true) {
    this._registeredEntityIdsSet[entity1Id] = true;
    this._preparePromise(entity1);
  }
  if (this._registeredEntityIdsSet[entity2Id] !== true) {
    this._registeredEntityIdsSet[entity2Id] = true;
    this._preparePromise(entity2);
  }
};

/**
 * @private
 * @param {!wrm.data.meta.RegularEntity} entity
 */
wrm.data.sync.EntityOrchestrator.prototype._preparePromise = function(entity) {
  var entityId = entity.getId();
  if (DEBUG && this._promises[entityId]) {
    throw new Error("Promise already created for entity id " + entityId);
  }
  this._promises[entityId] = new Promise(function(resolve, reject) {
    this._functions[entityId] = resolve;
  }.bind(this));
};

/**
 * @return {!Array<!wrm.data.meta.Entity>} entities
 */
wrm.data.sync.EntityOrchestrator.prototype.getEntities = function() {
  return this._entities;
};

/**
 * @return {!Array<!wrm.data.meta.Entity>}
 */
wrm.data.sync.EntityOrchestrator.prototype.getSortedEntities = function() {
  var $jscomp$this = this;
  var metadata = this._entities[0].getMetadata();
  
  /* Collect all entity ids and build a map for inverse retrieval */
  var entityIds = this._entities.map(function(entity) {
    return entity.getId();
  });
  
  /* Compute topologically-sorted entities (as a list of ids) */
  var sortedEntityIds = wrm.util.sortTopologically(entityIds, function(entityId) {
    var entity = metadata.getEntity(entityId);
    return $jscomp$this.getRequiredEntities(entity).map(function(entity) {
      return entity.getId();
    });
  });
  
  /* Return the sorted list as entities */
  return sortedEntityIds.map(function(id) {
    return metadata.getEntity(id);
  });
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Promise}
 */
wrm.data.sync.EntityOrchestrator.prototype.notifySynchronizationStarted = function(entity) {
  var entityId = entity.getId();
  var promise = this._startPromises[entityId];
  if (!promise) {
    this._startPromises[entityId] = promise = this._createStartPromise(entity);
  }
  return promise;
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Promise}
 */
wrm.data.sync.EntityOrchestrator.prototype._createStartPromise = function(entity) {
  var $jscomp$this = this;
  
  /* Create a promise that waits for required entities to be synchronized */
  var promise;
  var requiredEntityIdsSet = this._requiredEntityIds[entity.getId()];
  var requiredEntityIds = requiredEntityIdsSet ? Object.keys(requiredEntityIdsSet) : [];
  if (requiredEntityIds.length <= 0) {
    promise = Promise.resolve();
  } else {
    promise = Promise.map(requiredEntityIds, function(id) {
      return $jscomp$this._promises[id];
    });
  }
  
  /* Concatenate the waiting for a permit by the semaphore */
  promise = promise.then(function() {
    return $jscomp$this._semaphore.acquire();
  });
  
  return promise;
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Array<!wrm.data.meta.Entity>}
 */
wrm.data.sync.EntityOrchestrator.prototype.getRequiredEntities = function(entity) {
  var requiredEntityIds = this._requiredEntityIds[entity.getId()];
  if (!requiredEntityIds) {
    return [];
  }
  var metadata = entity.getMetadata();
  return Object.keys(requiredEntityIds).map(function(id) {
    return metadata.getEntity(id);
  }, this);
};

/**
 * @param {!wrm.data.meta.Entity} entity
 */
wrm.data.sync.EntityOrchestrator.prototype.notifySynchronizationFinished = function(entity) {
  var fn = this._functions[entity.getId()];
  if (fn) {
    fn();
  }
  this._semaphore.release();
};




//== wrm/data/DataContext.js ==================================================


/**
 * @interface
 */
wrm.data.DataContext = function() {
};

/**
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.DataContext.prototype.getMetadata = function() {
};

/**
 * @return {!wrm.data.QueryFactory}
 */
wrm.data.DataContext.prototype.getQueryFactory = function() {
};

/**
 * @param {!wrm.data.meta.Property} property
 * @param {*|null|undefined} value
 * @return {*|null|undefined}
 */
wrm.data.DataContext.prototype.castToSingleValue = ABSTRACT_METHOD;

/**
 * @param {!wrm.data.meta.Property} property
 * @param {*|null|undefined} value
 * @return {!Array.<*|null|undefined>}
 */
wrm.data.DataContext.prototype.castToArrayValue = ABSTRACT_METHOD;

/**
 * @param {!wrm.data.ChangeListener} changeListener
 */
wrm.data.DataContext.prototype.addChangeListener = ABSTRACT_METHOD;

/**
 * @param {!wrm.data.ChangeListener} changeListener
 */
wrm.data.DataContext.prototype.removeChangeListener = ABSTRACT_METHOD;

/**
 * @return {undefined}
 */
wrm.data.DataContext.prototype.disableChangeTracking = ABSTRACT_METHOD;

/**
 * @return {boolean}
 */
wrm.data.DataContext.prototype.isChangeTrackingEnabled = ABSTRACT_METHOD;

/**
 * @param {...string} families
 */
wrm.data.DataContext.prototype.setExposedMetaAttributes = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.DataContext.prototype.select = ABSTRACT_METHOD;

/**
 * @deprecated
 * @param {string} entityId
 * @param {{ output: (!Object.<string,string>|!Array.<string>|string|undefined), distinct: (boolean|undefined), include:
 *            (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined), order:
 *            (!Array.<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined), limit:
 *            ({begin:number,count:number}|number|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<!Array.<!Object|*>>}
 */
wrm.data.DataContext.prototype.selectOld = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<?Object|*>}
 */
wrm.data.DataContext.prototype.selectOne = ABSTRACT_METHOD;
/**
 * @deprecated
 * @param {string} entityId
 * @param {{ output: (!Object.<string,string>|!Array.<string>|string|undefined), distinct: (boolean|undefined), include:
 *            (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined), order:
 *            (!Array.<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined), limit:
 *            ({begin:number,count:number}|number|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<?Object|*>}
 */
wrm.data.DataContext.prototype.selectOneOld = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {!Array.<!Object>|!Object} insert
 * @param {!Object=} parameters
 * @return {!Promise.<!Array.<!*>>}
 */
wrm.data.DataContext.prototype.insert = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array.<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<!Array.<!*>>}
 */
wrm.data.DataContext.prototype.update = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array.<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<undefined>}
 */
wrm.data.DataContext.prototype.updateNoResult = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<undefined>}
 */
wrm.data.DataContext.prototype["delete"] = ABSTRACT_METHOD;
/**
 * @deprecated
 * @param {string} entityId
 * @param {{ include: (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=}
 *            options
 * @param {!Object=} parameters
 * @return {!Promise.<number>}
 */
wrm.data.DataContext.prototype.deleteOld = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.DataContext.prototype.deleteGetChanged = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.DataContext.prototype.deleteGetCount = ABSTRACT_METHOD;




//== wrm/data/AbstractAtomNode.js =============================================


/**
 * @package
 * @constructor
 * @implements wrm.data.Condition.Node
 * @param {boolean} binary
 * @param {boolean} arrayTest
 * @param {!wrm.data.PropertyRef} propertyRef
 * @param {?{inputName:string, value:(*|undefined)}} rightOperand
 * @param {boolean} rightValueConj
 * @param {?boolean} impliedResult
 * @param {boolean} evaluateRequired
 */
wrm.data.AbstractAtomNode = function(binary, arrayTest, propertyRef, rightOperand, rightValueConj, impliedResult, evaluateRequired) {
  
  /** @private */
  this._arrayTest = arrayTest;
  
  /** @private */
  this._property = propertyRef.getProperty();
  
  /* Function for building a JavaScript property access expression */
  function buildPropertyAccess(objExpr, propertyName) {
    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(propertyName)) {
      return objExpr + "." + propertyName;
    } else {
      if (!isNaN(Number(propertyName))) {
        return objExpr + "[" + propertyName + "]";
      } else {
        return objExpr + "[" + buildLiteralString(propertyName) + "]";
      }
    }
  }
  
  /* Function for building a JavaScript literal string */
  function buildLiteralString(s) {
    return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
  }
  
  /* The right expression is the input (which may be a constant), accessed from 'this' */
  var inputName, inputValue, rightExpr;
  if (binary) {
    inputName = rightOperand.inputName;
    inputValue = rightOperand.value;
    rightExpr = buildPropertyAccess("this", inputName);
  } else {
    inputName = null;
    inputValue = undefined;
    rightExpr = null;
  }
  
  /**
   * @private
   * @type {!wrm.data.PropertyRef}
   */
  this._propertyRef = propertyRef;
  
  /**
   * @private
   * @type {?string}
   */
  this._rightExpr = rightExpr;
  
  /**
   * @private
   * @type {?string}
   */
  this._inputName = inputName;
  
  /**
   * @private
   * @type {*|undefined}
   */
  this._inputValue = inputValue;
  
  /** @private */
  this._rightValueConj = rightValueConj;
  
  /** @private */
  this._impliedResult = impliedResult;
  
  /** @private */
  this._evaluateRequired = evaluateRequired;
};

/** @override */
wrm.data.AbstractAtomNode.prototype.compile = function(context) {
  var impliedResult = this._impliedResult;
  
  /* Retrieve the counters for keeping track of expected and found inputs */    /** @type {{expected:number, found:number}} */
  var inputCounters = impliedResult === null ? context.requiredInputs : context.impliedInputs;
  inputCounters.expected++;
  
  /*
   * Extract the input value (which may be a constant) and convert it. In some cases there is nothing to extract (such as with unary
   * predicates), and in that case the input name is null.
   */
  if (this._inputName) {
    var inputValue = this._extractInputValue(context);
    
    /* Handle missing inputs and implied results */
    if (inputValue === undefined || inputValue === null || angular.isArray(inputValue) && inputValue.length <= 0) {
      if (impliedResult === null) {
        return {predicate:null, evaluator:null};
      } else {
        return {predicate:String(impliedResult), evaluator:impliedResult ? wrm.data.AbstractAtomNode._TRUE_EVALUATOR : wrm.data.AbstractAtomNode._FALSE_EVALUATOR};
      }
    }
    
    context.actualInputs[this._inputName] = inputValue;
  }
  inputCounters.found++;
  
  /* Compile an evaluator if required */
  var evaluator = null;
  if (context.compileEvaluator) {
    evaluator = this._createEvaluator(context);
  } else {
    if (this._evaluateRequired) {
      throw new wrm.data.AbstractAtomNode.EvaluationRequiredError;
    }
  }
  
  /* If requiring an evaluator, return a neutral predicate, so that the evaluator will have a chance to process the resulting row */
  if (this._evaluateRequired) {
    return {predicate:String(context.verity), evaluator:evaluator};
  }
  
  /* Create a standard predicate and return it along with the evaluator */
  var predicate = this._createPredicate(context);
  return {predicate:predicate, evaluator:evaluator};
};

/**
 * @private
 * @param {!wrm.data.Condition.CompileContext} context
 * @return {*|undefined}
 */
wrm.data.AbstractAtomNode.prototype._extractInputValue = function(context) {
  if (DEBUG && !this._inputName) {
    throw new Error("No input expected");
  }
  
  /* Use either the constant input value or extract one from the the external inputs */
  var inputValue = this._inputValue;
  if (inputValue === undefined) {
    inputValue = context.inputs[this._inputName];
  }
  
  /* Convert the input value to match the property */
  inputValue = context.dataContext.castToArrayValue(this._property, inputValue);
  if (!this._arrayTest && inputValue.length <= 1) {
    inputValue = context.dataContext.castToSingleValue(this._property, inputValue);
  }
  
  return this.prepareInputValue(inputValue);
};

/**
 * @protected
 * @template T
 * @param {T} inputValue
 * @return {T}
 */
wrm.data.AbstractAtomNode.prototype.prepareInputValue = function(inputValue) {
  return inputValue;
};

/**
 * @private
 * @param {!wrm.data.Condition.CompileContext} context
 * @return {string}
 */
wrm.data.AbstractAtomNode.prototype._createPredicate = function(context) {
  var leftExpr = "it." + this._propertyRef.getResolvedReference();
  var rightExpr = this._rightExpr;
  var rightValue = this._inputName !== null ? context.actualInputs[this._inputName] : undefined;
  
  if (!this._arrayTest && rightExpr && rightValue && angular.isArray(rightValue)) {
    
    /* Array input value and scalar test: construct a predicate with the correct number of parts */
    return "(" + rightValue.map(function(rightValueElem, i) {
      var falsyRightValueElem = !rightValueElem;
      return this.createPredicatePiece(leftExpr, rightExpr + "[" + i + "]", falsyRightValueElem);
    }, this).join(") " + (this._rightValueConj ? "\x26\x26" : "||") + " (") + ")";
    
  } else {
    
    /* Scalar input value or array test: construct a single-part predicate */
    var falsyRightValue = this._inputName !== null ? !rightValue : false;
    return this.createPredicatePiece(leftExpr, rightExpr, falsyRightValue);
  }
};

/**
 * @protected
 * @param {string} leftExpr
 * @param {?string} rightExpr
 * @param {boolean} falsyRightValue
 * @return {string}
 */
wrm.data.AbstractAtomNode.prototype.createPredicatePiece = ABSTRACT_METHOD;

/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.data.AbstractAtomNode.EvaluationRequiredError = makeCustomErrorConstructor("wrm.data.AbstractAtomNode.EvaluationRequiredError");

/**
 * @private
 * @type {function(!Object):!Promise.<boolean>}
 */
wrm.data.AbstractAtomNode._TRUE_EVALUATOR = function(object) {
  return Promise.resolve(true);
};

/**
 * @private
 * @type {function(!Object):!Promise.<boolean>}
 */
wrm.data.AbstractAtomNode._FALSE_EVALUATOR = function(object) {
  return Promise.resolve(false);
};

/**
 * @private
 * @param {!wrm.data.Condition.CompileContext} context
 * @return {wrm.data.Condition.Evaluator}
 */
wrm.data.AbstractAtomNode.prototype._createEvaluator = function(context) {
  var evaluateFn = this.evaluate.bind(this);
  var rightValue = this._inputName !== null ? context.actualInputs[this._inputName] : undefined;
  var rightValueArrayConj = !this._arrayTest ? this._rightValueConj : null;
  var evaluator = new wrm.data.JDPropertyEvaluator(evaluateFn, this._propertyRef, rightValue, rightValueArrayConj);
  return evaluator.evaluate.bind(evaluator);
};

/**
 * @protected
 * @param {*} leftValue
 * @param {*|undefined} rightValue
 * @param {!wrm.data.DataContext} dataContext
 * @return {boolean|!Promise.<boolean>}
 */
wrm.data.AbstractAtomNode.prototype.evaluate = ABSTRACT_METHOD;




//== wrm/data/AbstractCompoundNode.js =========================================


/**
 * @package
 * @constructor
 * @implements wrm.data.Condition.Node
 * @param {!Array.<!wrm.data.Condition.Node>} operands
 */
wrm.data.AbstractCompoundNode = function(operands) {
  
  /** @private */
  this._operands = operands;
};

/** @override */
wrm.data.AbstractCompoundNode.prototype.compile = function(context) {
  
  /* Compute the new verity boolean value */
  var oldVerity = context.verity;
  context.verity = this.propagateVerity(context.verity);
  
  var predicates = [], evaluators = [];
  try {
    
    /* Compile operands. Exit immediately if an operand cannot compute its predicate */
    this._operands.forEach(function(operand) {
      var result = operand.compile(context);
      if (!result.predicate) {
        return {predicate:null, evaluator:null};
      }
      
      predicates.push(result.predicate);
      evaluators.push(result.evaluator);
    });
    
  } finally {
    
    /* Restore verity */
    context.verity = oldVerity;
  }
  
  /* Build the merged result */
  return {predicate:this.mergePredicates(predicates), evaluator:context.compileEvaluator ? this._mergeEvaluators(evaluators) : null};
};

/**
 * @protected
 * @param {!Array.<string>} predicates
 */
wrm.data.AbstractCompoundNode.prototype.mergePredicates = ABSTRACT_METHOD;

/**
 * @protected
 * @param {boolean} verity
 * @return {boolean}
 */
wrm.data.AbstractCompoundNode.prototype.propagateVerity = function(verity) {
  return verity;
};

/**
 * @private
 * @return {wrm.data.Condition.Evaluator}
 */
wrm.data.AbstractCompoundNode.prototype._mergeEvaluators = function(operandEvaluators) {
  var evaluateFn = this.evaluate.bind(this);
  
  return function(it, dataContext) {
    return Promise.resolve(evaluateFn(operandEvaluators, it, dataContext));
  };
};

/**
 * @protected
 * @param {!Array.<wrm.data.Condition.Evaluator>} operandEvaluators
 * @param {!Object} object
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<boolean>}
 */
wrm.data.AbstractCompoundNode.prototype.evaluate = ABSTRACT_METHOD;




//== wrm/data/ConditionNodes.js ===============================================



/**
 * @package
 * @const
 */
wrm.data.ConditionNodes = {};

/**
 * @package
 * @const
 * @type {!Object.<string,function(new:wrm.data.Condition.Node,!wrm.data.PropertyRef,?{inputName:string,value:(*|undefined)},boolean,?boolean)>}
 */
wrm.data.ConditionNodes.Atoms = {};

/**
 * @package
 * @const
 * @type {!Object.<string,function(new:wrm.data.Condition.Node,!Array.<!wrm.data.Condition.Node>)>}
 */
wrm.data.ConditionNodes.Compounds = {};

/*
 * Unary atom operator nodes
 */

/**
 * @package
 * @typedef {{ fragmentTemplate:string, isEvaluateRequired:((function(!wrm.data.PropertyRef):boolean)|undefined),
 *          evaluate:(function(?*,(?*|undefined),!wrm.data.DataContext):(boolean|!Promise.<boolean>)) }}
 */
wrm.data.ConditionNodes.UnaryAtomOperatorConfig;

/**
 * @package
 * @param {!Object.<string,wrm.data.ConditionNodes.UnaryAtomOperatorConfig>} configs
 */
wrm.data.ConditionNodes.registerUnaryAtomOperators = function(configs) {
  Object.keys(configs).forEach(function(name) {
    var config = configs[name];
    wrm.data.ConditionNodes.Atoms[name] = wrm.data.ConditionNodes._newUnaryAtomCtor(config);
  });
};

/**
 * @private
 * @param {wrm.data.ConditionNodes.UnaryAtomOperatorConfig} config
 * @return {function(new:wrm.data.Condition.Node,!wrm.data.PropertyRef,?{inputName:string,value:(*|undefined)},boolean,?boolean)}
 */
wrm.data.ConditionNodes._newUnaryAtomCtor = function(config) {
  var fragmentTemplate = config.fragmentTemplate;
  var isEvaluateRequired = wrm.data.ConditionNodes._createIsEvaluateRequiredFunction(config.isEvaluateRequired);
  var evaluate = config.evaluate;
  
  /**
   * @constructor
   * @extends wrm.data.AbstractAtomNode
   * @param {!wrm.data.PropertyRef} propertyRef
   * @param {?{inputName:string, value:(*|undefined)}} rightOperand
   * @param {boolean} rightValueConj
   * @param {?boolean} impliedResult
   */
  var ctor = function(propertyRef, rightOperand, rightValueConj, impliedResult) {
    wrm.data.AbstractAtomNode.call(this, false, false, propertyRef, rightOperand, rightValueConj, impliedResult, isEvaluateRequired(propertyRef));
  };
  
  extendConstructor(ctor, wrm.data.AbstractAtomNode);
  
  /** @override */
  ctor.prototype.createPredicatePiece = function(leftExpr, rightExpr, falsyRightValue) {
    return fragmentTemplate.replace(/\$([0])/g, function(match, operandIndex) {
      return leftExpr;
    });
  };
  
  /** @override */
  ctor.prototype.evaluate = evaluate;
  
  /* Flag the constructor to indicate whether it is binary */
  ctor["binary"] = false;
  
  return ctor;
};

/*
 * Binary atom operator nodes
 */

/**
 * @package
 * @typedef {{ fragmentTemplate:string, mapExpression:(string|undefined), arrayTest:(boolean|undefined),
 *          prepareRightValue:(function((?*|undefined)):(?*|undefined)|undefined),
 *          isEvaluateRequired:(function(!wrm.data.PropertyRef):boolean|undefined),
 *          evaluate:function(?*,(?*|undefined),!wrm.data.DataContext):(boolean|!Promise.<boolean>) }}
 */
wrm.data.ConditionNodes.BinaryAtomOperatorConfig;

/**
 * @package
 * @param {!Object.<string,wrm.data.ConditionNodes.BinaryAtomOperatorConfig>} configs
 */
wrm.data.ConditionNodes.registerBinaryAtomOperators = function(configs) {
  Object.keys(configs).forEach(function(name) {
    var config = configs[name];
    wrm.data.ConditionNodes.Atoms[name] = wrm.data.ConditionNodes._newBinaryAtomCtor(config);
  });
};

/**
 * @private
 * @param {wrm.data.ConditionNodes.BinaryAtomOperatorConfig} config
 * @return {function(new:wrm.data.Condition.Node,!wrm.data.PropertyRef,?{inputName:string,value:(*|undefined)},boolean,?boolean)}
 */
wrm.data.ConditionNodes._newBinaryAtomCtor = function(config) {
  var fragmentTemplate = config.fragmentTemplate;
  var mapExpression = config.mapExpression;
  var prepareRightValue = config.prepareRightValue;
  var isEvaluateRequired = wrm.data.ConditionNodes._createIsEvaluateRequiredFunction(config.isEvaluateRequired);
  var evaluate = config.evaluate;
  
  /**
   * @constructor
   * @extends wrm.data.AbstractAtomNode
   * @param {!wrm.data.PropertyRef} propertyRef
   * @param {?{inputName:string, value:(*|undefined)}} rightOperand
   * @param {boolean} rightValueConj
   * @param {?boolean} impliedResult
   */
  var ctor = function(propertyRef, rightOperand, rightValueConj, impliedResult) {
    wrm.data.AbstractAtomNode.call(this, true, config.arrayTest || false, propertyRef, rightOperand, rightValueConj, impliedResult, isEvaluateRequired(propertyRef));
  };
  
  extendConstructor(ctor, wrm.data.AbstractAtomNode);
  
  /** @override */
  ctor.prototype.createPredicatePiece = function(leftExpr, rightExpr, falsyRightValue) {
    return fragmentTemplate.replace(/\$([01])/g, function(match, operandIndex) {
      var left = operandIndex === "0";
      var expr = left ? leftExpr : rightExpr;
      
      /* Apply the map expression only to truthy right values (due to a JayData bug - see #8214) */
      if (mapExpression && (left || !falsyRightValue)) {
        expr = expr + mapExpression;
      }
      
      return expr;
    });
  };
  
  if (prepareRightValue) {
    
    /** @override */
    ctor.prototype.prepareInputValue = prepareRightValue;
  }
  
  /** @override */
  ctor.prototype.evaluate = function(leftValue, rightValue, dataContext) {
    
    /* All binary operators should fail against null */
    if (leftValue === null) {
      return false;
    }
    
    return evaluate(leftValue, rightValue, dataContext);
  };
  
  /* Flag the constructor to indicate whether it is binary */
  ctor["binary"] = true;
  
  return ctor;
};

/*
 * Unary compound operator nodes
 */

/**
 * @package
 * @typedef {{ predicatePrefix:string, propagateVerity:((function(boolean):boolean)|undefined),
 *          evaluate:(function(!Array.<wrm.data.Condition.Evaluator>,!Object,!wrm.data.DataContext):(!Promise.<boolean>)) }}
 */
wrm.data.ConditionNodes.UnaryCompoundOperatorConfig;

/**
 * @package
 * @param {!Object.<string,wrm.data.ConditionNodes.UnaryCompoundOperatorConfig>} configs
 */
wrm.data.ConditionNodes.registerUnaryCompoundOperators = function(configs) {
  Object.keys(configs).forEach(function(name) {
    var config = configs[name];
    wrm.data.ConditionNodes.Compounds[name] = wrm.data.ConditionNodes._newUnaryCompoundCtor(config);
  });
};

/**
 * @private
 * @param {wrm.data.ConditionNodes.UnaryCompoundOperatorConfig} config
 * @return {function(new:wrm.data.Condition.Node,!Array.<!wrm.data.Condition.Node>)}
 */
wrm.data.ConditionNodes._newUnaryCompoundCtor = function(config) {
  var predicatePrefix = config.predicatePrefix;
  var propagateVerity = config.propagateVerity;
  
  /**
   * @constructor
   * @extends wrm.data.AbstractCompoundNode
   * @param {!Array.<!wrm.data.Condition.Node>} operands
   */
  var ctor = function(operands) {
    wrm.data.AbstractCompoundNode.call(this, operands);
  };
  
  extendConstructor(ctor, wrm.data.AbstractCompoundNode);
  
  /** @override */
  ctor.prototype.mergePredicates = function(predicates) {
    return predicatePrefix + "(" + predicates[0] + ")";
  };
  
  if (propagateVerity) {
    /** @override */
    ctor.prototype.propagateVerity = function(verity) {
      return propagateVerity(verity);
    };
  }
  
  /** @override */
  ctor.prototype.evaluate = config.evaluate;
  
  return ctor;
};

/*
 * Binary compound operator nodes
 */

/**
 * @package
 * @typedef {{ predicateInfix:string, propagateVerity:((function(boolean):boolean)|undefined),
 *          evaluate:(function(!Array.<wrm.data.Condition.Evaluator>,!Object,!wrm.data.DataContext):(!Promise.<boolean>)) }}
 */
wrm.data.ConditionNodes.BinaryCompoundOperatorConfig;

/**
 * @package
 * @param {!Object.<string,wrm.data.ConditionNodes.BinaryCompoundOperatorConfig>} configs
 */
wrm.data.ConditionNodes.registerBinaryCompoundOperators = function(configs) {
  Object.keys(configs).forEach(function(name) {
    var config = configs[name];
    wrm.data.ConditionNodes.Compounds[name] = wrm.data.ConditionNodes._newBinaryCompoundCtor(config);
  });
};

/**
 * @private
 * @param {wrm.data.ConditionNodes.BinaryCompoundOperatorConfig} config
 * @return {function(new:wrm.data.Condition.Node,!Array.<!wrm.data.Condition.Node>)}
 */
wrm.data.ConditionNodes._newBinaryCompoundCtor = function(config) {
  var predicateInfix = config.predicateInfix;
  var propagateVerity = config.propagateVerity;
  
  /**
   * @constructor
   * @extends wrm.data.AbstractCompoundNode
   * @param {!Array.<!wrm.data.Condition.Node>} operands
   */
  var ctor = function(operands) {
    wrm.data.AbstractCompoundNode.call(this, operands);
  };
  
  extendConstructor(ctor, wrm.data.AbstractCompoundNode);
  
  /** @override */
  ctor.prototype.mergePredicates = function(predicates) {
    return predicates.map(function(p) {
      return "(" + p + ")";
    }).join(predicateInfix);
  };
  
  if (propagateVerity) {
    /** @override */
    ctor.prototype.propagateVerity = function(verity) {
      return propagateVerity(verity);
    };
  }
  
  /** @override */
  ctor.prototype.evaluate = config.evaluate;
  
  return ctor;
};

/*
 * Utilities
 */

/**
 * @private
 * @param {(function(!wrm.data.PropertyRef):boolean)=} optionalFunction
 * @return {(function(!wrm.data.PropertyRef):boolean)}
 */
wrm.data.ConditionNodes._createIsEvaluateRequiredFunction = function(optionalFunction) {
  return function(propertyRef) {
    if (wrm.data.lateEvaluationEnabled) {
      return true;
    }
    if (optionalFunction && optionalFunction(propertyRef)) {
      return true;
    }
    return false;
  };
};




//== wrm/data/PropertyRef.js ==================================================



/**
 * @constructor
 * @param {!wrm.data.meta.Entity} baseEntity
 * @param {!Array.<!wrm.data.meta.Property>} properties
 * @param {?string} metaAttrFamily
 */
wrm.data.PropertyRef = function(baseEntity, properties, metaAttrFamily) {
  
  /** @private */
  this._baseEntity = baseEntity;
  
  /** @private */
  this._properties = properties;
  
  /** @private */
  this._metaAttrFamily = metaAttrFamily;
  
  /* Resolve the property chain */
  var info = wrm.data.PropertyRef._resolveProperties(baseEntity, properties, metaAttrFamily);
  
  /** @private */
  this._property = info.property;
  
  /** @private */
  this._roles = info.roles;
  
  /** @private */
  this._resolvedReference = info.resolvedReference;
  
  /** @private */
  this._resolvedRoleReference = info.resolvedRoleReference;
  
  /**
   * @private
   * @type {!wrm.data.PropertyRef|undefined}
   */
  this._physicalRef = undefined;
  
  /**
   * @private
   * @type {?wrm.data.PropertyRef|undefined}
   */
  this._lastRoleRef = undefined;
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} baseEntity
 * @param {!Array.<!wrm.data.meta.Property>} properties
 * @param {?string} metaAttrFamily
 * @return {{property:!wrm.data.meta.Property, resolvedReference:string, roles:!Array.<!wrm.data.meta.Role>,
 *         resolvedRoleReference:?string}}
 */
wrm.data.PropertyRef._resolveProperties = function(baseEntity, properties, metaAttrFamily) {
  if (properties.length <= 0) {
    throw new Error("Empty chain of referenced properties");
  }
  
  /* Collect names, also checking that the chain of properties is consistent */
  var names = [];
  var currentEntity = baseEntity, lastProperty = null;
  for (var i = 0;i < properties.length;i++) {
    lastProperty = properties[i];
    names.push(lastProperty.getName());
    if (lastProperty instanceof wrm.data.meta.Role) {
      currentEntity = lastProperty.getInverseEntity();
    } else {
      currentEntity = null;
      if (i < properties.length - 1) {
        throw new Error("Found attribute not at the end of the chain of referenced properties");
      }
    }
  }
  
  /* The included role name is made up of all names, minus the optional trailing attribute */
  var isRole = !!currentEntity;
  var roles = isRole ? properties : properties.slice(0, properties.length - 1);
  var roleNames = isRole ? names : names.slice(0, names.length - 1);
  
  /* The meta-attribute family refers, by its name, to a field of the physical attribute */
  var fieldReferenceSuffix = metaAttrFamily !== null ? "#" + metaAttrFamily : "";
  
  return {property:(lastProperty), resolvedReference:names.join(".") + fieldReferenceSuffix, roles:roles, resolvedRoleReference:roleNames.length > 0 ? roleNames.join(".") : null};
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.PropertyRef.prototype.getBaseEntity = function() {
  return this._baseEntity;
};

/**
 * @return {!wrm.data.meta.Property}
 */
wrm.data.PropertyRef.prototype.getProperty = function() {
  return this._property;
};

/**
 * @return {!Array.<!wrm.data.meta.Role>}
 */
wrm.data.PropertyRef.prototype.getRoles = function() {
  return this._roles;
};

/**
 * @package
 * @return {string}
 */
wrm.data.PropertyRef.prototype.getResolvedReference = function() {
  return this._resolvedReference;
};

/**
 * @package
 * @return {?string}
 */
wrm.data.PropertyRef.prototype.getResolvedRoleReference = function() {
  return this._resolvedRoleReference;
};

/**
 * @package
 * @return {?wrm.data.PropertyRef}
 */
wrm.data.PropertyRef.prototype.getLastRoleRef = function() {
  if (this._lastRoleRef === undefined) {
    if (this._roles.length > 0) {
      this._lastRoleRef = new wrm.data.PropertyRef(this._baseEntity, this._roles, null);
    } else {
      this._lastRoleRef = null;
    }
  }
  return this._lastRoleRef;
};

/**
 * @package
 * @return {!wrm.data.PropertyRef}
 */
wrm.data.PropertyRef.prototype.getPhysicalRef = function() {
  if (this._physicalRef === undefined) {
    
    /* Replace roles leading to bridged associations with their bridge-head role */
    var physicalProperties = [];
    this._properties.forEach(function(property) {
      var bridgeHeadRole = property instanceof wrm.data.meta.RegularRole ? property.getBridgeHeadRole() : null;
      if (bridgeHeadRole) {
        var nearBridgeRole = bridgeHeadRole.getInverseRole();
        var bridgeEntity = nearBridgeRole.getEntity();
        var farBridgeRole = nearBridgeRole === bridgeEntity.getRole1() ? bridgeEntity.getRole2() : bridgeEntity.getRole1();
        physicalProperties.push(bridgeHeadRole);
        physicalProperties.push(farBridgeRole);
      } else {
        physicalProperties.push(property);
      }
    });
    
    this._physicalRef = new wrm.data.PropertyRef(this._baseEntity, physicalProperties, this._metaAttrFamily);
  }
  return this._physicalRef;
};

/** @override */
wrm.data.PropertyRef.prototype.toString = function() {
  return "[" + this._baseEntity.getName() + "]." + this._resolvedReference;
};

/**
 * @param {!wrm.data.meta.Entity} baseEntity
 * @param {string} idExpression
 * @param {boolean=} includeMetaAttributes
 */
wrm.data.PropertyRef.of = function(baseEntity, idExpression, includeMetaAttributes) {
  var ids = idExpression.split("."), metaAttrFamily;
  if (!ids[0]) {
    throw new Error("Empty entity property id expresison '" + idExpression + "'");
  }
  var lastId = ids[ids.length - 1], sharpIndex = lastId.indexOf("#");
  if (sharpIndex > 0) {
    ids[ids.length - 1] = lastId.substring(0, sharpIndex);
    metaAttrFamily = lastId.substring(sharpIndex + 1);
  } else {
    metaAttrFamily = null;
  }
  
  /* Translate each id into a property */
  var properties = [];
  var currentEntity = baseEntity, lastProperty = null;
  for (var i = 0;i < ids.length;i++) {
    lastProperty = currentEntity.getProperty(ids[i], includeMetaAttributes);
    properties.push(lastProperty);
    
    /* Roles bring in a new entity, while attributes leave all entity contexts */
    if (lastProperty instanceof wrm.data.meta.Role) {
      currentEntity = lastProperty.getInverseEntity();
    } else {
      currentEntity = null;
      if (i < ids.length - 1) {
        throw new Error("Found attribute not at the end of id expression '" + idExpression + "'");
      }
    }
  }
  
  /* Check the validity of specifying a meta-attribute family */
  if (metaAttrFamily !== null) {
    if (!(lastProperty instanceof wrm.data.meta.Attribute)) {
      throw new Error("Found meta-attribute reference after a non-attribute");
    }
  }
  
  return new wrm.data.PropertyRef(baseEntity, properties, metaAttrFamily);
};




//== wrm/data/meta/Metadata.js ================================================



/**
 * @constructor
 * @param {!Object} descr
 */
wrm.data.meta.Metadata = function(descr) {
  
  /* Check for presence of the version (cannot afford to miss it) */
  if (typeof descr["version"] !== "number") {
    throw new Error("Invalid metadata version");
  }
  
  /**
   * @private
   * @type {!Object}
   */
  this._descriptor = wrm.data.cloneObject(descr);
  
  /**
   * @private
   * @type {number}
   */
  this._version = descr["version"];
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Entity>}
   */
  this._entitiesById = {};
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Attribute>}
   */
  this._attributesById = {};
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Role>}
   */
  this._rolesById = {};
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Association>}
   */
  this._assocsById = {};
  
  /** @private */
  this._initd = false;
  
  /* Initialize */
  this._createEntities(descr["entities"] || {});
  this._createAssociations(descr["associations"] || {});
  this._init();
};

/**
 * @private
 * @param {!Object} descr
 */
wrm.data.meta.Metadata.prototype._createEntities = function(descr) {
  angular.forEach(descr, function(entityDescr, entityId) {
    new wrm.data.meta.RegularEntity(entityId, entityDescr, this);
  }, this);
};

/**
 * @private
 * @param {!Object} descr
 */
wrm.data.meta.Metadata.prototype._createAssociations = function(descr) {
  angular.forEach(descr, function(assocDescr, assocId) {
    new wrm.data.meta.RegularAssociation(assocId, assocDescr, this);
  }, this);
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.meta.Metadata.prototype._init = function() {
  this._initd = true;
  this.getEntities().forEach(function(entity) {
    entity.init();
  });
  this.getAssociations().forEach(function(assoc) {
    assoc.init();
  });
};

/**
 * @internal
 * @return {!Object}
 */
wrm.data.meta.Metadata.prototype.getDescriptor = function() {
  return this._descriptor;
};

/**
 * @return {number}
 */
wrm.data.meta.Metadata.prototype.getVersion = function() {
  return this._version;
};

/**
 * @return {!Array.<!wrm.data.meta.Entity>}
 */
wrm.data.meta.Metadata.prototype.getEntities = function() {
  var result = [];
  angular.forEach(this._entitiesById, function(entity) {
    result.push(entity);
  });
  return result;
};

/**
 * @param {string} entityId
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.meta.Metadata.prototype.getEntity = function(entityId) {
  var result = this._entitiesById[entityId];
  if (!result) {
    throw new Error("Unknown entity '" + entityId + "'");
  }
  return result;
};

/**
 * @return {!Array.<!wrm.data.meta.Association>}
 */
wrm.data.meta.Metadata.prototype.getAssociations = function() {
  var result = [];
  angular.forEach(this._assocsById, function(assoc) {
    result.push(assoc);
  });
  return result;
};

/**
 * @param {string} assocId
 * @return {!wrm.data.meta.Association}
 */
wrm.data.meta.Metadata.prototype.getAssociation = function(assocId) {
  var result = this._assocsById[assocId];
  if (!result) {
    throw new Error("Unknown association '" + assocId + "'");
  }
  return result;
};

/**
 * @param {string} attributeId
 * @return {!wrm.data.meta.Attribute}
 */
wrm.data.meta.Metadata.prototype.getAttribute = function(attributeId) {
  var result = this._attributesById[attributeId];
  if (!result) {
    throw new Error("Unknown attribute '" + attributeId + "'");
  }
  return result;
};

/**
 * @param {string} roleId
 * @return {!wrm.data.meta.Role}
 */
wrm.data.meta.Metadata.prototype.getRole = function(roleId) {
  var result = this._rolesById[roleId];
  if (!result) {
    throw new Error("Unknown role '" + roleId + "'");
  }
  return result;
};

/*
 * Internal registration/retrieval
 */

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {boolean=} cloaked
 */
wrm.data.meta.Metadata.prototype.registerEntity = function(entity, cloaked) {
  this._doRegisterElement(this._entitiesById, entity, cloaked);
};

/**
 * @package
 * @param {!wrm.data.meta.Association} assoc
 * @param {boolean=} cloaked
 */
wrm.data.meta.Metadata.prototype.registerAssociation = function(assoc, cloaked) {
  this._doRegisterElement(this._assocsById, assoc, cloaked);
};

/**
 * @package
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {boolean=} cloaked
 */
wrm.data.meta.Metadata.prototype.registerAttribute = function(attribute, cloaked) {
  this._doRegisterElement(this._attributesById, attribute, cloaked);
};

/**
 * @package
 * @param {!wrm.data.meta.Role} role
 * @param {boolean=} cloaked
 */
wrm.data.meta.Metadata.prototype.registerRole = function(role, cloaked) {
  this._doRegisterElement(this._rolesById, role, cloaked);
};

/**
 * @private
 * @template E
 * @param {!Object.<string,E>} map
 * @param {!E} element
 * @param {boolean=} cloaked
 */
wrm.data.meta.Metadata.prototype._doRegisterElement = function(map, element, cloaked) {
  if (!cloaked) {
    map[element.getId()] = element;
  }
  if (this._initd) {
    element.init();
  }
};

/*
 * Special metadata sets
 */

/**
 * @internal
 * @const
 */
wrm.data.meta.Metadata.EMPTY = new wrm.data.meta.Metadata({"version":-1});




//== wrm/data/Condition.js ====================================================



/**
 * @constructor
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {?wrm.data.Condition.Expression=} expression
 */
wrm.data.Condition = function(metadata, entityId, expression) {
  
  /** @private */
  this._entity = metadata.getEntity(entityId);
  
  /** @private */
  this._implicitInputsCount = 0;
  
  /** @private */
  this._constantInputsCount = 0;
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.PropertyRef>}
   */
  this._includeRoleRefs = {};
  
  /** @private {!Array<string>} */
  this._explicitInputNames = [];
  
  /**
   * @private
   * @type {?wrm.data.Condition.Node}
   */
  this._tree = expression ? this._buildNode(expression) : null;
  
  /* Extract expression-wide configuration */
  var config = expression && expression["config"] || {};
  
  /**
   * @private
   * @type {boolean}
   */
  this._oneImpliedInputRequired = config["oneImpliedInputRequired"] || false;
  
  /** @private */
  this._compileEvaluator = false;
  
  /**
   * @private
   * @type {?number|string}
   */
  this._onlyKeyConditionInputName = this._retrieveOnlyKeyConditionInputName(expression);
};

/**
 * @typedef {{ oneImpliedInputRequired:boolean }}
 */
wrm.data.Condition.Config;

/**
 * @typedef {{ and: !Array.<!wrm.data.Condition.Expression>, config:(!wrm.data.Condition.Config|undefined) } | { or:
 *          !Array.<!wrm.data.Condition.Expression>, config:(!wrm.data.Condition.Config|undefined) } | { not:
 *          !wrm.data.Condition.Expression, config:(!wrm.data.Condition.Config|undefined) } | !Array.<!wrm.data.Condition.Expression> |
 *          ({ property:string, operator:(string|undefined), value:(*|undefined), valueOp:(string|undefined),
 *          valueInput:(string|undefined), implied:(boolean|undefined), config:(!wrm.data.Condition.Config|undefined) } | string)}
 */
wrm.data.Condition.Expression;

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object} inputValues
 * @return {{predicate:?string, evaluator:?(function(!Object,!wrm.data.DataContext):!Promise.<boolean>), inputs:!Object,
 *         notApplicable:boolean}}
 */
wrm.data.Condition.prototype.createFilter = function(dataContext, inputValues) {
  
  /* Degenerate case of no condition: return an empty applicable filter */
  if (!this._tree) {
    return {predicate:null, evaluator:null, inputs:{}, notApplicable:false};
  }
  
  /* Compile the expression tree against the actual input values */
  var context = new wrm.data.Condition.CompileContext(dataContext, inputValues, this._compileEvaluator);
  var result;
  try {
    result = this._tree.compile(context);
  } catch (e) {
    if (e instanceof wrm.data.AbstractAtomNode.EvaluationRequiredError) {
      this._compileEvaluator = true;
      return this.createFilter(dataContext, inputValues);
    }
    throw e;
  }
  
  var requiredInputs = context.requiredInputs;
  var impliedInputs = context.impliedInputs;
  
  /* The entire filter is not applicable inputs are not enough according to configuration */
  if (requiredInputs.expected > 0 && requiredInputs.found < requiredInputs.expected || this._oneImpliedInputRequired && (impliedInputs.expected > 0 && impliedInputs.found === 0)) {
    return {predicate:null, evaluator:null, inputs:{}, notApplicable:true};
  }
  
  /*
   * Degenerate case of a tree consisting only of implied conditions, all without input and without the requirement of having all
   * implied inputs. It is OK for the client to have passed no inputs, but the absence of required conditions would produce a
   * non-working filter (e.g. false || false). To avoid that, explicitly return an applicable empty filter.
   */
  if (requiredInputs.expected === 0 && !this._oneImpliedInputRequired && impliedInputs.found === 0) {
    return {predicate:null, evaluator:null, inputs:{}, notApplicable:false};
  }
  
  /* The filter is applicable: return the result of compilation */
  return {predicate:result.predicate, evaluator:result.evaluator, inputs:context.actualInputs, notApplicable:false};
};

/**
 * @return {!Array<string>}
 */
wrm.data.Condition.prototype.getExplicitInputNames = function() {
  return this._explicitInputNames;
};

/**
 * @package
 * @return {!Array.<!wrm.data.PropertyRef>}
 */
wrm.data.Condition.prototype.getIncludedRoleRefs = function() {
  var includedRoles = this._includeRoleRefs;
  return Object.keys(includedRoles).map(function(key) {
    return includedRoles[key];
  });
};

/**
 * @package
 * @return {?number|string}
 */
wrm.data.Condition.prototype.getOnlyKeyConditionInputName = function() {
  return this._onlyKeyConditionInputName;
};

/*
 * Expression tree building
 */

/**
 * @package
 * @interface
 */
wrm.data.Condition.Node = function() {
};

/**
 * @param {!wrm.data.Condition.CompileContext} context
 * @return {{predicate:?string, evaluator:?wrm.data.Condition.Evaluator}}
 */
wrm.data.Condition.Node.prototype.compile = ABSTRACT_METHOD;

/**
 * @private
 * @const
 * @type {string}
 */
wrm.data.Condition._DEFAULT_COMPOUND_OP = "and";

/**
 * @private
 * @const
 * @type {string}
 */
wrm.data.Condition._DEFAULT_ATOM_OP = "eq";

/**
 * @private
 * @const
 * @type {!Object.<string,string>}
 */
wrm.data.Condition._TEXTUAL_OPERATOR_CONVERSION = {"e":"n", "!e":"!n"};

/**
 * @private
 * @param {!wrm.data.Condition.Expression} expression
 * @return {!wrm.data.Condition.Node}
 */
wrm.data.Condition.prototype._buildNode = function(expression) {
  
  /* Treat arrays as default compounds (if at least 2-long) or terms */
  if (angular.isArray(expression)) {
    if (expression.length > 1) {
      return this._buildCompoundNode(wrm.data.Condition._DEFAULT_COMPOUND_OP, (expression));
    } else {
      if (expression.length === 1) {
        return this._buildAtomNode(expression[0]);
      } else {
        throw new Error("Invalid 0-length array in expression");
      }
    }
  }
  
  /* Attempt to treat the expression as a compound */
  for (var operator in wrm.data.ConditionNodes.Compounds) {
    if (wrm.data.ConditionNodes.Compounds.hasOwnProperty(operator) && expression[operator]) {
      return this._buildCompoundNode(operator, expression[operator]);
    }
  }
  
  /* Not a compound: treat as a term */
  return this._buildAtomNode(expression);
};

/**
 * @private
 * @param {string} operator
 * @param {!wrm.data.Condition.Expression|!Array.<!wrm.data.Condition.Expression>} operands
 * @return {!wrm.data.Condition.Node}
 */
wrm.data.Condition.prototype._buildCompoundNode = function(operator, operands) {
  if (!angular.isArray(operands)) {
    operands = [operands];
  }
  
  /* Obtain the node constructor */
  var nodeCtor = wrm.data.ConditionNodes.Compounds[operator];
  if (!nodeCtor) {
    throw new Error("Invalid operator '" + operator + "'");
  }
  
  /* Build nodes for each operand */
  var operandNodes = [];
  operands.forEach(function(operand) {
    operandNodes.push(this._buildNode(operand));
  }, this);
  
  return new nodeCtor(operandNodes);
};

/**
 * @private
 * @param {!wrm.data.Condition.Expression} term
 * @return {!wrm.data.Condition.Node}
 */
wrm.data.Condition.prototype._buildAtomNode = function(term) {
  
  /* Treat a primitive value as a term using the default operator */
  if (typeof term !== "object") {
    term = ({property:term});
  }
  
  /* Resolve the left operand property reference and keep track of included role paths */
  var propertyRef = wrm.data.PropertyRef.of(this._entity, term.property, true);
  var includedRoleRef = propertyRef.getLastRoleRef();
  if (includedRoleRef) {
    this._includeRoleRefs[includedRoleRef.getResolvedReference()] = includedRoleRef;
  }
  
  /* Compute the operator to use (specific for internal value operation or generic) */
  var operator = term.operator || wrm.data.Condition._DEFAULT_ATOM_OP;
  if (!wrm.data.Type.isTextual(propertyRef.getProperty().getType())) {
    if (operator.indexOf(".ic") !== -1) {
      throw new Error("Ignore case operator used on non textual attribute");
    }
    operator = wrm.data.Condition._TEXTUAL_OPERATOR_CONVERSION[operator] || operator;
  }
  var specificOperator = operator + (term.valueOp === "and" ? "[and]" : "[or]");
  
  /* Obtain the node constructor */
  var nodeCtor = wrm.data.ConditionNodes.Atoms[specificOperator];
  if (!nodeCtor) {
    nodeCtor = wrm.data.ConditionNodes.Atoms[operator];
  }
  if (!nodeCtor) {
    throw new Error("Invalid value operator '" + operator + "'");
  }
  
  /* Resolve the right operand, which may be an input name, a literal value; the operand is missing in case of unary operators */
  var rightOperand;
  if (nodeCtor["binary"]) {
    var inputName, inputValue;
    if (term.value !== null && term.value !== undefined) {
      inputName = "_k" + this._constantInputsCount++;
      inputValue = term.value;
    } else {
      if (term.valueInput === null || term.valueInput === undefined) {
        inputName = String(this._implicitInputsCount++);
      } else {
        inputName = term.valueInput;
        this._explicitInputNames.push(inputName);
      }
      inputValue = undefined;
    }
    rightOperand = {inputName:inputName, value:inputValue};
  } else {
    rightOperand = null;
  }
  
  /* Determine the internal boolean mode to use for the right operand value should it be an array */
  var rightValueConj = term.valueOp === "and";
  
  /* Determine the implied result (null meaning 'required') */
  var impliedResult = term.implied !== undefined ? !!term.implied : null;
  
  return new nodeCtor(propertyRef.getPhysicalRef(), rightOperand, rightValueConj, impliedResult);
};

/*
 * Expression tree compilation
 */

/**
 * @package
 * @constructor
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object} inputValues
 * @param {boolean} compileEvaluator
 */
wrm.data.Condition.CompileContext = function(dataContext, inputValues, compileEvaluator) {
  
  /** @type {!Object} */
  this.inputs = inputValues;
  
  /** @type {!wrm.data.DataContext} */
  this.dataContext = dataContext;
  
  /** @type {boolean} */
  this.compileEvaluator = compileEvaluator;
  
  /** @type {boolean} */
  this.verity = true;
  
  /** @type {!Object} */
  this.actualInputs = {};
  
  /** @type {boolean} */
  this.requiredConditionTested = false;
  
  /** @type {{expected:number, found:number}} */
  this.requiredInputs = {expected:0, found:0};
  
  /** @type {{expected:number, found:number}} */
  this.impliedInputs = {expected:0, found:0};
};

/**
 * @package
 * @typedef {function(!Object,!wrm.data.DataContext):!Promise.<boolean>}
 */
wrm.data.Condition.Evaluator;

/*
 * Expression tree analysis
 */

/**
 * @private
 * @param {?wrm.data.Condition.Expression=} expression
 * @return {?number|string}
 */
wrm.data.Condition.prototype._retrieveOnlyKeyConditionInputName = function(expression) {
  if (typeof expression === "string" && expression === this._entity.getKeyAttribute().getId()) {
    return 0;
  }
  
  return null;
};




//== wrm/data/Purger.js =======================================================



/**
 * @constructor
 */
wrm.data.Purger = function() {
  
  /** @private */
  this._nextRuleId = 0;
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Entity>}
   */
  this._entitiesByRuleIds = {};
  
  /**
   * @private
   * @type {!Object.<string,!Array.<!wrm.data.Condition.Expression>>}
   */
  this._conditionsByEntityId = {};
  
  /**
   * @private
   * @type {!Object.<string,!wrm.data.meta.Entity>}
   */
  this._touchedEntities = {};
};
/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<?>} conditionExpressionss
 * @return {string}
 */
wrm.data.Purger.prototype.registerRule = function(entity, conditionExpressionss) {
  var entityId = entity.getId();
  var ruleId = String(this._nextRuleId++);
  
  this._entitiesByRuleIds[ruleId] = entity;
  
  var list = this._conditionsByEntityId[entityId];
  if (!list) {
    this._conditionsByEntityId[entityId] = list = [];
  }
  list.push.apply(list, conditionExpressionss);
  
  return ruleId;
};

/**
 * @param {string} ruleId
 */
wrm.data.Purger.prototype.touch = function(ruleId) {
  var entity = this._entitiesByRuleIds[ruleId];
  if (entity) {
    this._touchedEntities[entity.getId()] = entity;
  }
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 */
wrm.data.Purger.prototype.purge = function(dataContext, pm) {
  var $jscomp$this = this;
  var conditionsByEntityId = this._conditionsByEntityId;
  
  var touchedEntities = this._touchedEntities;
  this._touchedEntities = [];
  
  /* Purge each touched entity */
  var entityIds = Object.keys(touchedEntities);
  pm.resize(entityIds.length);
  return entityIds.reduce(function(chain, entityId) {
    var entity = touchedEntities[entityId];
    var conditions = conditionsByEntityId[entityId];
    if (!entity || !conditions || conditions.length <= 0) {
      pm.worked(1);
      return chain;
    }
    
    return chain.then(function() {
      return $jscomp$this._purgeEntity(dataContext, entity, conditions);
    }).tap(function() {
      pm.worked(1);
    });
  }, Promise.resolve());
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<!wrm.data.Condition.Expression>} conditions
 * @return {!Promise}
 */
wrm.data.Purger.prototype._purgeEntity = function(dataContext, entity, conditions) {
  
  /* Delete all instances matching ALL conditions */
  return Promise.resolve().then(function() {
    dataContext.disableChangeTracking();
    return dataContext.deleteGetChanged(entity.getId(), {filter:conditions});
  });
};




//== wrm/data/sync/_sync.js ===================================================


/**
 * @name wrm.data.sync
 * @namespace
 */

/**
 * @package
 * @param {!Array.<*>} keys
 * @return {number}
 */
wrm.data.sync.computeKeysHash = function(keys) {
  
  /* Function for enforcing signed 32-bit overflow */
  function oflw32(n) {
    return n & 4294967295;
  }
  
  /* Function for getting an hash code of a string */
  function computeStringHashCode(s) {
    var hashCode = 0;
    for (var i = 0;i < s.length;i++) {
      hashCode = oflw32(oflw32(31 * hashCode) + s.charCodeAt(i));
    }
    return hashCode;
  }
  
  /* With no keys, return a special hash */
  if (keys.length <= 0) {
    return -1;
  }
  
  /* Make a XOR of all keys hash codes */
  var result = 0;
  for (var i = 0;i < keys.length;i++) {
    result ^= computeStringHashCode(String(keys[i]));
  }
  
  return result;
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} serverKey
 * @param {boolean=} includeUnconfirmed
 * @return {!Promise<*>|!Promise<null>}
 */
wrm.data.sync.findKey = function(dataContext, entity, serverKey, includeUnconfirmed) {
  var query = wrm.data.sync._retrieveFindKeyQuery(dataContext.getQueryFactory(), entity, includeUnconfirmed);
  return query.queryOne(dataContext, [serverKey]);
};

/**
 * @private
 * @const {!Object<string,!wrm.data.SelectQuery>}
 */
wrm.data.sync._FIND_KEY_QUERY_CACHE = {};

/**
 * @private
 * @param {!wrm.data.QueryFactory} queryFactory
 * @param {!wrm.data.meta.Entity} entity
 * @param {boolean=} includeUnconfirmed
 * @return {!wrm.data.SelectQuery}
 */
wrm.data.sync._retrieveFindKeyQuery = function(queryFactory, entity, includeUnconfirmed) {
  var CACHE = wrm.data.sync._FIND_KEY_QUERY_CACHE;
  var cacheKey = String(entity.getMetadata().getVersion()) + "," + entity.getId() + "," + String(!!includeUnconfirmed);
  var query = CACHE[cacheKey];
  if (query !== undefined) {
    return query;
  }
  
  /* Create a new query */
  query = function create() {
    var keyAttr = entity.getKeyAttribute();
    var serverKeyAttr = entity.getServerKeyAttribute();
    var createTsAttr = entity.getCreateTimestampAttribute();
    
    /* Filter by server key and exclude just-created objects */        /** @type {!Array.<wrm.data.Condition.Expression>} */
    var filter = [];
    filter.push({property:serverKeyAttr.getId()});
    if (!includeUnconfirmed && createTsAttr) {
      filter.push({property:createTsAttr.getId(), operator:"n"});
    }
    
    return queryFactory.prepareSelect(entity.getId(), {output:keyAttr.getId(), outputConfig:{useNames:true}, filter:filter});
  }();
  
  CACHE[cacheKey] = query;
  return query;
};

/**
 * @private
 * @const
 */
wrm.data.sync._FIND_ALL_KEYS_CHUNK = 600;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array<*>} serverKeys
 * @param {number} concurrency
 * @param {boolean=} includeUnconfirmed
 * @return {!Promise<!Array<{key:?*, serverKey:*}>>}
 */
wrm.data.sync.findAllKeys = function(dataContext, entity, serverKeys, concurrency, includeUnconfirmed) {
  var query = wrm.data.sync._retrieveFindAllKeysQuery(dataContext.getQueryFactory(), entity, includeUnconfirmed);
  return Promise.map(wrm.util.obj.sliceList(serverKeys, wrm.data.sync._FIND_ALL_KEYS_CHUNK), function(severKeysChunk) {
    return query.query(dataContext, [severKeysChunk]);
  }, {concurrency:concurrency}).then(function(resultChunks) {
    return Array.prototype.concat.apply([], resultChunks);
  });
};

/**
 * @private
 * @const {!Object<string,!wrm.data.SelectQuery>}
 */
wrm.data.sync._FIND_ALL_KEYS_QUERY_CACHE = {};

/**
 * @private
 * @param {!wrm.data.QueryFactory} queryFactory
 * @param {!wrm.data.meta.Entity} entity
 * @param {boolean=} includeUnconfirmed
 * @return {!wrm.data.SelectQuery}
 */
wrm.data.sync._retrieveFindAllKeysQuery = function(queryFactory, entity, includeUnconfirmed) {
  var CACHE = wrm.data.sync._FIND_ALL_KEYS_QUERY_CACHE;
  var cacheKey = String(entity.getMetadata().getVersion()) + "," + entity.getId() + "," + String(!!includeUnconfirmed);
  var query = CACHE[cacheKey];
  if (query !== undefined) {
    return query;
  }
  
  /* Create a new query */
  query = function create() {
    var keyAttr = entity.getKeyAttribute();
    var serverKeyAttr = entity.getServerKeyAttribute();
    var createTsAttr = entity.getCreateTimestampAttribute();
    
    /* Filter by server key and exclude just-created objects */        /** @type {!Array.<wrm.data.Condition.Expression>} */
    var filter = [];
    filter.push({property:serverKeyAttr.getId()});
    if (!includeUnconfirmed && createTsAttr) {
      filter.push({property:createTsAttr.getId(), operator:"n"});
    }
    
    return queryFactory.prepareSelect(entity.getId(), {output:{"key":keyAttr.getId(), "serverKey":serverKeyAttr.getId()}, outputConfig:{useNames:true}, filter:filter});
  }();
  
  CACHE[cacheKey] = query;
  return query;
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {boolean=} includeUnconfirmed
 * @return {!Promise.<*>|!Promise.<null>}
 */
wrm.data.sync.findServerKey = function(dataContext, entity, key, includeUnconfirmed) {
  var query = wrm.data.sync._retrieveFindServerKeyQuery(dataContext.getQueryFactory(), entity, includeUnconfirmed);
  return query.queryOne(dataContext, [key]);
};

/**
 * @private
 * @const {!Object<string,!wrm.data.SelectQuery>}
 */
wrm.data.sync._FIND_SERVER_KEY_QUERY_CACHE = {};

/**
 * @private
 * @param {!wrm.data.QueryFactory} queryFactory
 * @param {!wrm.data.meta.Entity} entity
 * @param {boolean=} includeUnconfirmed
 * @return {!wrm.data.SelectQuery}
 */
wrm.data.sync._retrieveFindServerKeyQuery = function(queryFactory, entity, includeUnconfirmed) {
  var CACHE = wrm.data.sync._FIND_SERVER_KEY_QUERY_CACHE;
  var cacheKey = String(entity.getMetadata().getVersion()) + "," + entity.getId() + "," + String(!!includeUnconfirmed);
  var query = CACHE[cacheKey];
  if (query !== undefined) {
    return query;
  }
  
  /* Create a new query */
  query = function create() {
    var keyAttr = entity.getKeyAttribute();
    var serverKeyAttr = entity.getServerKeyAttribute();
    var createTsAttr = entity.getCreateTimestampAttribute();
    
    /* Filter by key and exclude just-created objects */        /** @type {!Array.<wrm.data.Condition.Expression>} */
    var filter = [];
    filter.push({property:keyAttr.getId()});
    if (!includeUnconfirmed && createTsAttr) {
      filter.push({property:createTsAttr.getId(), operator:"n"});
    }
    
    return queryFactory.prepareSelect(entity.getId(), {output:serverKeyAttr.getId(), outputConfig:{useNames:true}, filter:filter});
  }();
  
  CACHE[cacheKey] = query;
  return query;
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {!wrm.data.meta.Role} role
 * @param {boolean=} includeUnconfirmed
 * @return {!Promise.<!Array.<*>>}
 */
wrm.data.sync.findFarServerKeys = function(dataContext, entity, key, role, includeUnconfirmed) {
  var query = wrm.data.sync._retrieveFindFarServerKeysQuery(dataContext.getQueryFactory(), entity, role, includeUnconfirmed);
  if (query) {
    return query.query(dataContext, [key]);
  }
  return Promise.resolve([]);
};

/**
 * @private
 * @const {!Object<string,?wrm.data.SelectQuery>}
 */
wrm.data.sync._FIND_FAR_SERVER_KEYS_QUERY_CACHE = {};

/**
 * @private
 * @param {!wrm.data.QueryFactory} queryFactory
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.meta.Role} role
 * @param {boolean=} includeUnconfirmed
 * @return {?wrm.data.SelectQuery}
 */
wrm.data.sync._retrieveFindFarServerKeysQuery = function(queryFactory, entity, role, includeUnconfirmed) {
  var CACHE = wrm.data.sync._FIND_FAR_SERVER_KEYS_QUERY_CACHE;
  var cacheKey = String(entity.getMetadata().getVersion()) + "," + entity.getId() + "," + role.getId() + "," + String(!!includeUnconfirmed);
  var query = CACHE[cacheKey];
  if (query !== undefined) {
    return query;
  }
  
  /* Create a new query */
  query = function create() {
    var keyAttr = entity.getKeyAttribute();
    var farEntity = role.getInverseEntity();
    var farRole = role.getInverseRole();
    var farServerKeyAttr = farEntity.getServerKeyAttribute();
    if (!farServerKeyAttr) {
      return null;
    }
    
    var createTsAttr = farEntity.getCreateTimestampAttribute();
    
    /* Filter by key and exclude just-created objects */        /** @type {!Array.<wrm.data.Condition.Expression>} */
    var filter = [];
    filter.push({property:farRole.getId() + "." + keyAttr.getId()});
    if (!includeUnconfirmed && createTsAttr) {
      filter.push({property:createTsAttr.getId(), operator:"n"});
    }
    
    return queryFactory.prepareSelect(farEntity.getId(), {output:farServerKeyAttr.getId(), outputConfig:{useNames:true}, filter:filter});
  }();
  
  CACHE[cacheKey] = query;
  return query;
};




//== wrm/data/sync/AbstractTupleStore.js ======================================



/**
 * Implementation of a low-level storage for tuples representing the instances of an association and for the history of changes that
 * have occurred to them.
 * 
 * @package
 * @constructor
 */
wrm.data.sync.AbstractTupleStore = function() {
  
  /** @protected */
  this.selectConcurrency = +Infinity;
};

/**
 * @package
 * @param {number} selectConcurrency
 */
wrm.data.sync.AbstractTupleStore.prototype.setSelectConcurrency = function(selectConcurrency) {
  this.selectConcurrency = selectConcurrency;
};

/**
 * @package
 * @typedef {{key1:(?*|undefined), key2:(?*|undefined), serverKey1:(?*|undefined), serverKey2:(?*|undefined)}}
 */
wrm.data.sync.AbstractTupleStore.Filter;

/**
 * @package
 * @typedef {{key1:(?*|!Array<*>|undefined), key2:(?*|!Array<*>|undefined), serverKey1:(?*|!Array<*>|undefined),
 *          serverKey2:(?*|!Array<*>|undefined)}}
 */
wrm.data.sync.AbstractTupleStore.BulkFilter;

/**
 * @package
 * @typedef {{key1:(?*), key2:(?*), serverKey1:(?*), serverKey2:(?*)}}
 */
wrm.data.sync.AbstractTupleStore.Values;

/**
 * @package
 * @enum {string}
 */
wrm.data.sync.AbstractTupleStore.TrackType = {ADDITION:"A", REMOVAL:"R"};

/**
 * @package
 * @return {number}
 */
wrm.data.sync.AbstractTupleStore.prototype.getPreferredLookupServerKeyIndex = ABSTRACT_METHOD;

/**
 * @package
 * @return {boolean}
 */
wrm.data.sync.AbstractTupleStore.prototype.isUpdateRequired = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} resolved
 * @param {wrm.data.sync.AbstractTupleStore.BulkFilter} bulkFilter
 * @return {!Promise<!Array<wrm.data.sync.AbstractTupleStore.Values>>}
 */
wrm.data.sync.AbstractTupleStore.prototype.select = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} resolved
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 * @return {!Promise}
 */
wrm.data.sync.AbstractTupleStore.prototype.insert = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} resolved
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 * @param {wrm.data.sync.AbstractTupleStore.Filter} filter
 * @return {!Promise.<boolean>}
 */
wrm.data.sync.AbstractTupleStore.prototype.update = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} resolved
 * @param {wrm.data.sync.AbstractTupleStore.Filter} filter
 * @return {!Promise.<boolean>}
 */
wrm.data.sync.AbstractTupleStore.prototype["delete"] = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AbstractTupleStore.Filter} filter
 * @return {!Promise.<!Array.<wrm.data.sync.AbstractTupleStore.Values>>}
 */
wrm.data.sync.AbstractTupleStore.prototype.selectTracks = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 * @param {?wrm.data.DateTime} timestamp
 * @return {!Promise}
 */
wrm.data.sync.AbstractTupleStore.prototype.insertTrack = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 * @param {?wrm.data.DateTime|undefined} timestamp
 * @param {wrm.data.sync.AbstractTupleStore.Filter} filter
 * @return {!Promise.<boolean>}
 */
wrm.data.sync.AbstractTupleStore.prototype.updateTracks = ABSTRACT_METHOD;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AbstractTupleStore.Filter} filter
 * @return {!Promise.<boolean>}
 */
wrm.data.sync.AbstractTupleStore.prototype.deleteTracks = ABSTRACT_METHOD;

/*
 * Utilities
 */

/**
 * @protected
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 * @return {{key1.new:(?*), key2.new:(?*), serverKey1.new:(?*), serverKey2.new:(?*)}}
 */
wrm.data.sync.AbstractTupleStore.prototype.extractNewValues = function(values) {
  return {"key1.new":values.key1, "key2.new":values.key2, "serverKey1.new":values.serverKey1, "serverKey2.new":values.serverKey2};
};

/**
 * @private
 * @const {!Array<string>}
 */
wrm.data.sync.AbstractTupleStore._FILTER_KEYS = ["key1", "key2", "serverKey1", "serverKey2"];

/**
 * @protected
 * @param {wrm.data.sync.AbstractTupleStore.BulkFilter} bulkFilter
 * @param {number} chunkSize
 * @return {?Array<wrm.data.sync.AbstractTupleStore.BulkFilter>}
 */
wrm.data.sync.AbstractTupleStore.prototype.sliceBulkFilter = function(bulkFilter, chunkSize) {
  var FILTER_KEYS = wrm.data.sync.AbstractTupleStore._FILTER_KEYS;
  
  /*
   * A bulk filter can be processed if it has at most one array property. The degenerate case of no array property is also valid and
   * equivalent to a non-bulk filter.
   */
  
  /* Slice the filter into chunks, each being a bulk filter */
  var chunkedBulkFilters = [bulkFilter];
  for (var i = 0;i < FILTER_KEYS.length;i++) {
    var propertyKey = FILTER_KEYS[i];
    if (chunkedBulkFilters.length > 1) {
      if (Array.isArray(bulkFilter[propertyKey])) {
        throw new Error("Found multiple array properties in bulk filter");
      }
    } else {
      if (chunkedBulkFilters.length === 1) {
        chunkedBulkFilters = this._sliceBulkFilterOnProperty(chunkedBulkFilters[0], propertyKey, chunkSize);
      } else {
        return null;
      }
    }
  }
  
  return chunkedBulkFilters;
};

/**
 * @private
 * @param {wrm.data.sync.AbstractTupleStore.BulkFilter} bulkFilter
 * @param {string} propertyKey
 * @param {number} chunkSize
 * @return {!Array<wrm.data.sync.AbstractTupleStore.BulkFilter>}
 */
wrm.data.sync.AbstractTupleStore.prototype._sliceBulkFilterOnProperty = function(bulkFilter, propertyKey, chunkSize) {
  if (DEBUG) {
    if (wrm.data.sync.AbstractTupleStore._FILTER_KEYS.indexOf(propertyKey) < 0) {
      throw new Error("Invalid property key '" + propertyKey + "'");
    }
  }
  
  /* If the property is not an array (including null or undefined), there is no slicing to do */
  var propertyValue = bulkFilter[propertyKey];
  if (!Array.isArray(propertyValue)) {
    return [bulkFilter];
  }
  
  /* Slice the property value in chunks, producing a new bulk filter for each of them */
  return wrm.util.obj.sliceList(propertyValue, chunkSize).map(function(chunk) {
    var chunkBulkFilter = Object.create(bulkFilter);
    chunkBulkFilter[propertyKey] = chunk;
    return chunkBulkFilter;
  });
};




//== wrm/data/sync/BridgedTupleStore.js =======================================



/**
 * Tuple store that uses a "bridge entity" for storing tuples, and the corresponding auxiliary entity for storing non-resolved tuples.
 * This store is suitable for all association types, but generally used only for N:N associations.
 * 
 * @package
 * @constructor
 * @extends wrm.data.sync.AbstractTupleStore
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.BridgedTupleStore = function(assoc, purger, dataRunner) {
  wrm.data.sync.AbstractTupleStore.call(this);
  
  var TrackType = wrm.data.sync.AbstractTupleStore.TrackType;
  
  /** @private */
  this._resolvedQueries = this._createResolvedQueries(assoc, dataRunner);
  
  /** @private */
  this._unresolvedQueries = this._createAuxiliaryQueries(assoc, null, dataRunner);
  
  /**
   * @private
   * @type {!Object.<wrm.data.sync.AbstractTupleStore.TrackType,{select:!wrm.data.SelectQuery, insert:!wrm.data.XInsertQuery,
   *       delete:!wrm.data.XDeleteQuery}>}
   */
  this._tracksQueries = {};
  this._tracksQueries[TrackType.ADDITION] = this._createAuxiliaryQueries(assoc, TrackType.ADDITION, dataRunner);
  this._tracksQueries[TrackType.REMOVAL] = this._createAuxiliaryQueries(assoc, TrackType.REMOVAL, dataRunner);
};

extendConstructor(wrm.data.sync.BridgedTupleStore, wrm.data.sync.AbstractTupleStore);

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {{select:!wrm.data.SelectQuery, insert:!wrm.data.XInsertQuery, delete:!wrm.data.XDeleteQuery}}
 */
wrm.data.sync.BridgedTupleStore.prototype._createResolvedQueries = function(assoc, dataRunner) {
  
  /* Compute information about the elements that hold tuples */
  var entity1 = assoc.getEntity1();
  var entity2 = assoc.getEntity2();
  var assocId = assoc.getId();
  
  /* Prepare references to all attributes */
  var keyRef1 = assoc.getRole1().getId() + "." + entity1.getKeyAttribute().getId();
  var keyRef2 = assoc.getRole2().getId() + "." + entity2.getKeyAttribute().getId();
  var serverKeyRef1 = assoc.getRole1().getId() + "." + entity1.getServerKeyAttribute().getId();
  var serverKeyRef2 = assoc.getRole2().getId() + "." + entity2.getServerKeyAttribute().getId();
  
  /* Prepare filtering options for searching freely by values */
  var searchFilteringOptions = {filter:[{property:keyRef1, valueInput:"key1", implied:true}, {property:keyRef2, valueInput:"key2", implied:true}, {property:serverKeyRef1, valueInput:"serverKey1", implied:true}, {property:serverKeyRef2, valueInput:"serverKey2", implied:true}]};
  
  /* From this point onwards, actual QUERIES are constructed */
  
  /* Prepare a query for selecting existing tuples */
  var selectQuery = dataRunner.prepareNewAssociationSelect(assocId, angular.extend({}, searchFilteringOptions, {output:{"key1":keyRef1, "key2":keyRef2, "serverKey1":serverKeyRef1, "serverKey2":serverKeyRef2}, outputConfig:{useNames:true}}));
  
  /* Prepare a query for inserting new tuples */
  var insertQuery = dataRunner.prepareNewAssociationInsert(assocId, function(params) {
    var obj = {};
    obj[keyRef1] = params["key1.new"];
    obj[keyRef2] = params["key2.new"];
    return obj;
  });
  
  /* Prepare a query for deleting tuples */
  var deleteQuery = dataRunner.prepareNewAssociationDelete(assocId, searchFilteringOptions);
  
  return {select:selectQuery, insert:insertQuery, "delete":deleteQuery};
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {?wrm.data.sync.AbstractTupleStore.TrackType} trackType
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {{select:!wrm.data.SelectQuery, insert:!wrm.data.XInsertQuery, delete:!wrm.data.DeleteQuery}}
 */
wrm.data.sync.BridgedTupleStore.prototype._createAuxiliaryQueries = function(assoc, trackType, dataRunner) {
  var TrackType = wrm.data.sync.AbstractTupleStore.TrackType;
  
  /* Compute information about the elements that hold tuples */
  var bridgeEntity = assoc.getBridgeEntity();
  var entityId = bridgeEntity.getAuxiliaryEntity().getId();
  var addTimestampAttr = bridgeEntity.getAddTimestampAuxiliaryAttribute();
  var removeTimestampAttr = bridgeEntity.getRemoveTimestampAuxiliaryAttribute();
  
  /* Prepare references to all attributes */
  var serverKeyRef1 = bridgeEntity.getRole1().getServerTrackerAuxiliaryAttribute().getId();
  var serverKeyRef2 = bridgeEntity.getRole2().getServerTrackerAuxiliaryAttribute().getId();
  var addTimestampRef = addTimestampAttr && addTimestampAttr.getId();
  var removeTimestampRef = removeTimestampAttr && removeTimestampAttr.getId();
  
  /* Prepare filtering options for searching freely by values */
  var searchFilteringOptions = {filter:function() {
    var filter = [{property:serverKeyRef1, valueInput:"serverKey1", implied:true}, {property:serverKeyRef2, valueInput:"serverKey2", implied:true}];
    if (addTimestampRef) {
      filter.push({property:addTimestampRef, operator:trackType === TrackType.ADDITION ? "!n" : "n"});
    }
    if (removeTimestampRef) {
      filter.push({property:removeTimestampRef, operator:trackType === TrackType.REMOVAL ? "!n" : "n"});
    }
    return filter;
  }()};
  
  /* From this point onwards, actual QUERIES are constructed */
  
  /* Prepare a query for selecting existing tuples */
  var selectQuery = dataRunner.prepareSelect(entityId, angular.extend({}, searchFilteringOptions, {output:{"serverKey1":serverKeyRef1, "serverKey2":serverKeyRef2}, outputConfig:{useNames:true}}));
  
  /* Prepare a query for inserting new tuples */
  var insertQuery = dataRunner.prepareNewInsert(entityId, function(params) {
    var obj = {};
    obj[serverKeyRef1] = params["serverKey1.new"];
    obj[serverKeyRef2] = params["serverKey2.new"];
    if (addTimestampRef && trackType === TrackType.ADDITION) {
      obj[addTimestampRef] = params["timestamp"];
    }
    if (removeTimestampRef && trackType === TrackType.REMOVAL) {
      obj[removeTimestampRef] = params["timestamp"];
    }
    return obj;
  });
  
  /* Prepare a query for deleting tuples */
  var deleteQuery = dataRunner.prepareDelete(entityId, searchFilteringOptions);
  
  return {select:selectQuery, insert:insertQuery, "delete":deleteQuery};
};

/*
 * Operations
 */

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.getPreferredLookupServerKeyIndex = function() {
  
  /* Both sides would be the same */
  return 1;
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.isUpdateRequired = function() {
  return false;
};

/**
 * @private
 * @const
 */
wrm.data.sync.BridgedTupleStore._SELECT_CHUNK_SIZE = 600;

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.select = function(dataContext, resolved, bulkFilter) {
  var selectQuery = resolved ? this._resolvedQueries.select : this._unresolvedQueries.select;
  
  var bulkFilters = this.sliceBulkFilter(bulkFilter, wrm.data.sync.BridgedTupleStore._SELECT_CHUNK_SIZE);
  if (bulkFilters) {
    return (Promise.map(bulkFilters, function(chunkBulkFilter) {
      return selectQuery.query(dataContext, chunkBulkFilter);
    }, {concurrency:this.selectConcurrency}).then(function(chunks) {
      return Array.prototype.concat.apply([], chunks);
    }));
  }
  
  return Promise.resolve([]);
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.insert = function(dataContext, resolved, values) {
  var insertQuery = resolved ? this._resolvedQueries.insert : this._unresolvedQueries.insert;
  var newValues = this.extractNewValues(values);
  return insertQuery.executeGetChanged(dataContext, newValues);
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.update = function(dataContext, resolved, values, filter) {
  throw new Error("Bridged association tuples cannot be updated directly");
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype["delete"] = function(dataContext, resolved, filter) {
  var deleteQuery = resolved ? this._resolvedQueries["delete"] : this._unresolvedQueries["delete"];
  return deleteQuery.executeGetChanged(dataContext, filter);
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.selectTracks = function(dataContext, type, filter) {
  var selectQuery = this._tracksQueries[type].select;
  return (selectQuery.query(dataContext, filter));
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.insertTrack = function(dataContext, type, values, timestamp) {
  var insertQuery = this._tracksQueries[type].insert;
  var newValues = angular.extend(this.extractNewValues(values), {"timestamp":timestamp});
  return insertQuery.executeGetChanged(dataContext, newValues);
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.updateTracks = function(dataContext, type, values, timestamp, filter) {
  throw new Error("Bridged association tracks cannot be updated directly");
};

/** @override */
wrm.data.sync.BridgedTupleStore.prototype.deleteTracks = function(dataContext, type, filter) {
  var deleteQuery = this._tracksQueries[type]["delete"];
  return deleteQuery.executeGetChanged(dataContext, filter);
};




//== wrm/data/sync/CollapsedTupleStore.js =====================================



/**
 * Tuple store that "collapses" all tuples on one of their side, attaching them either to the instances of one of the entities or to
 * the corresponding auxiliary table (for non-resolved tuples). This store is suitable for 1:1, 1:N and N:1 associations. It cannot
 * support N:N associations.
 * 
 * @package
 * @constructor
 * @extends wrm.data.sync.AbstractTupleStore
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.CollapsedTupleStore = function(assoc, purger, dataRunner) {
  wrm.data.sync.AbstractTupleStore.call(this);
  
  var TrackType = wrm.data.sync.AbstractTupleStore.TrackType;
  
  /** @private */
  this._resolvedQueries = this._createResolvedQueries(assoc, dataRunner);
  
  /** @private */
  this._unresolvedQueries = this._createAuxiliaryQueries(assoc, null, dataRunner);
  
  /**
   * @private
   * @type {!Object.<wrm.data.sync.AbstractTupleStore.TrackType,{select:!wrm.data.SelectQuery, insert:!wrm.data.XInsertQuery,
   *       update:!wrm.data.XUpdateQuery}>}
   */
  this._tracksQueries = {};
  this._tracksQueries[TrackType.ADDITION] = this._createAuxiliaryQueries(assoc, TrackType.ADDITION, dataRunner);
  this._tracksQueries[TrackType.REMOVAL] = this._createAuxiliaryQueries(assoc, TrackType.REMOVAL, dataRunner);
  
  /** @private */
  this._preferredIndex = this._computePreferredLookupServerKeyIndex(assoc);
  
  /** @private */
  this._purger = purger;
  
  /** @private */
  this._purgeRuleId = this._registerPurgeRule(assoc, purger, dataRunner);
};

extendConstructor(wrm.data.sync.CollapsedTupleStore, wrm.data.sync.AbstractTupleStore);

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {{select:!wrm.data.SelectQuery, update:!wrm.data.XUpdateQuery}}
 */
wrm.data.sync.CollapsedTupleStore.prototype._createResolvedQueries = function(assoc, dataRunner) {
  
  /* Compute information about the elements that hold tuples */
  var near = wrm.data.sync.CollapsedTupleStore._findNearInfo(assoc);
  var nearRole = near.role;
  var nearEntity = nearRole.getEntity();
  var assocId = assoc.getId();
  
  /* Prepare references to all attributes */
  var locatorRef = nearRole.getId() + "." + nearEntity.getKeyAttribute().getId();
  var serverLocatorRef = nearRole.getId() + "." + nearEntity.getServerKeyAttribute().getId();
  var keyRef1 = nearRole.getId() + "." + nearEntity.getKeyAttribute().getId();
  var keyRef2 = nearRole.getInverseRole().getId() + "." + nearRole.getInverseEntity().getKeyAttribute().getId();
  var serverKeyRef1 = nearRole.getId() + "." + nearEntity.getServerKeyAttribute().getId();
  var serverKeyRef2 = nearRole.getInverseRole().getId() + "." + nearRole.getInverseEntity().getServerKeyAttribute().getId();
  
  /* Invert references if needed */
  if (near.inverted) {
    var tmp = keyRef1;
    keyRef1 = keyRef2;
    keyRef2 = tmp;
    
    tmp = serverKeyRef1;
    serverKeyRef1 = serverKeyRef2;
    serverKeyRef2 = tmp;
  }
  
  /* Prepare filtering options for searching freely by values */
  var searchFilteringOptions = {filter:[{property:keyRef1, valueInput:"key1", implied:true}, {property:keyRef2, valueInput:"key2", implied:true}, {property:serverKeyRef1, valueInput:"serverKey1", implied:true}, {property:serverKeyRef2, valueInput:"serverKey2", implied:true}]};
  
  /* Prepare filtering options for searching for an exact row for sharing */
  var locateFilteringOptions = {filter:{or:[{property:locatorRef, valueInput:locatorRef == keyRef1 ? "key1" : "key2", implied:false}, {property:serverLocatorRef, valueInput:serverLocatorRef == serverKeyRef1 ? "serverKey1" : "serverKey2", implied:false}]}};
  
  /* From this point onwards, actual QUERIES are constructed */
  
  /* Prepare a query for selecting existing tuples */
  var selectQuery = dataRunner.prepareNewAssociationSelect(assocId, angular.extend({}, searchFilteringOptions, {output:{"key1":keyRef1, "key2":keyRef2, "serverKey1":serverKeyRef1, "serverKey2":serverKeyRef2}, outputConfig:{useNames:true}}));
  
  /* Prepare a query for updating tuples (on shared rows) */
  var updateQuery = dataRunner.prepareNewAssociationUpdate(assocId, angular.extend({}, locateFilteringOptions, {update:function(params) {
    var obj = {};
    if (keyRef1 !== locatorRef) {
      obj[keyRef1] = params["key1.new"];
    }
    if (keyRef2 !== locatorRef) {
      obj[keyRef2] = params["key2.new"];
    }
    return obj;
  }}));
  
  return {select:selectQuery, update:updateQuery};
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {?wrm.data.sync.AbstractTupleStore.TrackType} trackType
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {{select:!wrm.data.SelectQuery, insert:!wrm.data.XInsertQuery, update:!wrm.data.XUpdateQuery}}
 */
wrm.data.sync.CollapsedTupleStore.prototype._createAuxiliaryQueries = function(assoc, trackType, dataRunner) {
  var TrackType = wrm.data.sync.AbstractTupleStore.TrackType;
  
  /* Compute information about the elements that hold tuples */
  var near = wrm.data.sync.CollapsedTupleStore._findNearInfo(assoc);
  var nearRole = near.role;
  var nearEntity = nearRole.getEntity();
  var entityId = nearEntity.getAuxiliaryEntity().getId();
  var addTimestampAttr = nearRole.getAddTimestampAuxiliaryAttribute();
  var removeTimestampAttr = nearRole.getRemoveTimestampAuxiliaryAttribute();
  
  /* Prepare references to all attributes */
  var serverLocatorRef = nearEntity.getServerKeyAttribute().getTrackerAuxiliaryAttribute().getId();
  var serverKeyRef1 = nearEntity.getServerKeyAttribute().getTrackerAuxiliaryAttribute().getId();
  var serverKeyRef2 = nearRole.getServerTrackerAuxiliaryAttribute().getId();
  var localKeyRef1 = nearEntity.getKeyAttribute().getTrackerAuxiliaryAttribute().getId();
  var localKeyRef2 = undefined;
  var addTimestampRef = addTimestampAttr && addTimestampAttr.getId();
  var removeTimestampRef = removeTimestampAttr && removeTimestampAttr.getId();
  
  /* Invert references if needed */
  if (near.inverted) {
    var tmp = serverKeyRef1;
    serverKeyRef1 = serverKeyRef2;
    serverKeyRef2 = tmp;
    
    localKeyRef2 = localKeyRef1;
    localKeyRef1 = undefined;
  }
  
  /* Prepare filtering options for searching freely by values */
  var searchFilteringOptions = {filter:function() {
    var filter = [{property:serverKeyRef1, valueInput:"serverKey1", implied:true}, {property:serverKeyRef2, valueInput:"serverKey2", implied:true}];
    if (addTimestampRef) {
      filter.push({property:addTimestampRef, operator:trackType === TrackType.ADDITION ? "!n" : "n"});
    }
    if (removeTimestampRef) {
      filter.push({property:removeTimestampRef, operator:trackType === TrackType.REMOVAL ? "!n" : "n"});
    }
    return filter;
  }()};
  
  /* Prepare filtering options for searching for an exact row for sharing */
  var locateFilteringOptions = {filter:function() {
    var filter = [{property:serverLocatorRef, valueInput:serverLocatorRef == serverKeyRef1 ? "serverKey1" : "serverKey2", implied:false}, {property:serverLocatorRef == serverKeyRef1 ? serverKeyRef2 : serverKeyRef1, valueInput:serverLocatorRef == serverKeyRef1 ? "serverKey2" : "serverKey1", implied:true}];
    if (addTimestampRef) {
      filter.push({property:addTimestampRef, operator:trackType === TrackType.ADDITION ? "!n" : "n"});
    }
    if (removeTimestampRef) {
      filter.push({property:removeTimestampRef, operator:trackType === TrackType.REMOVAL ? "!n" : "n"});
    }
    return filter;
  }()};
  
  var selectionOutput = {"output":{"serverKey1":serverKeyRef1, "serverKey2":serverKeyRef2}};
  if (localKeyRef1 !== undefined) {
    selectionOutput["output"]["localKey1"] = localKeyRef1;
  } else {
    selectionOutput["output"]["localKey2"] = localKeyRef2;
  }
  
  /* From this point onwards, actual QUERIES are constructed */
  
  /* Prepare a query for selecting existing tuples */
  var selectQuery = dataRunner.prepareSelect(entityId, angular.extend({outputConfig:{useNames:true}}, searchFilteringOptions, selectionOutput));
  
  /* Prepare a query for inserting new tuples */
  var insertQuery = dataRunner.prepareNewInsert(entityId, function(params) {
    var obj = {};
    if (localKeyRef1 !== undefined) {
      obj[localKeyRef1] = params["key1.new"];
    } else {
      obj[localKeyRef2] = params["key2.new"];
    }
    obj[serverKeyRef1] = params["serverKey1.new"];
    obj[serverKeyRef2] = params["serverKey2.new"];
    if (addTimestampRef && trackType === TrackType.ADDITION) {
      obj[addTimestampRef] = params["timestamp"];
    }
    if (removeTimestampRef && trackType === TrackType.REMOVAL) {
      obj[removeTimestampRef] = params["timestamp"];
    }
    return obj;
  });
  
  /* Prepare a query for updating tuples (on shared rows) */
  var updateQuery = dataRunner.prepareNewUpdate(entityId, angular.extend({}, locateFilteringOptions, {update:function(params) {
    var obj = {};
    if (serverKeyRef1 !== serverLocatorRef) {
      obj[serverKeyRef1] = params["serverKey1.new"];
    }
    if (serverKeyRef2 !== serverLocatorRef) {
      obj[serverKeyRef2] = params["serverKey2.new"];
    }
    if (addTimestampRef && trackType === TrackType.ADDITION) {
      obj[addTimestampRef] = params["timestamp"];
    }
    if (removeTimestampRef && trackType === TrackType.REMOVAL) {
      obj[removeTimestampRef] = params["timestamp"];
    }
    return obj;
  }}));
  
  return {select:selectQuery, insert:insertQuery, update:updateQuery};
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @return {number}
 */
wrm.data.sync.CollapsedTupleStore.prototype._computePreferredLookupServerKeyIndex = function(assoc) {
  
  /*
   * Lookups are more efficient on the server key residing on the "near" side (on the same entities of the tuples), since that does
   * no require joining
   */
  return wrm.data.sync.CollapsedTupleStore._findNearInfo(assoc).inverted ? 2 : 1;
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {string}
 */
wrm.data.sync.CollapsedTupleStore.prototype._registerPurgeRule = function(assoc, purger, dataRunner) {
  
  /* Compute information about the entity holding tuples */
  var nearRole = wrm.data.sync.CollapsedTupleStore._findNearInfo(assoc).role;
  var nearEntity = nearRole.getEntity();
  
  if (purger["_registered_collapsed_role_filters" + nearEntity.getId()]) {
    return purger["_registered_collapsed_role_filters" + nearEntity.getId()];
  }
  
  /*
   * Prepare filters for matching instances in the auxiliary entity that have all server keys nulled out (also considering other
   * associations)
   */    /** @type {!Array.<wrm.data.Condition.Expression>} */
  var roleFilters = [];
  nearEntity.getRoles().forEach(function(role) {
    var trackerAuxAttr = role.getServerTrackerAuxiliaryAttribute();
    if (trackerAuxAttr) {
      roleFilters.push({property:trackerAuxAttr.getId(), operator:"n"});
    }
  });
  
  purger["_registered_collapsed_role_filters" + nearEntity.getId()] = purger.registerRule(nearEntity.getAuxiliaryEntity(), roleFilters);
  return purger["_registered_collapsed_role_filters" + nearEntity.getId()];
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @return {{role:!wrm.data.meta.Role, inverted:boolean}}
 */
wrm.data.sync.CollapsedTupleStore._findNearInfo = function(assoc) {
  var role1 = assoc.getRole1();
  var role2 = assoc.getRole2();
  
  /*
   * Find the "near" role, i.e. the one residing with a foreign key on the entity onto which the association is collapsed. Invert
   * roles as necessary, keeping track of that.
   */
  var role;
  var inverted = role2.isForeignKey();
  if (!inverted) {
    role = role1;
  } else {
    role = role2;
  }
  
  return {role:role, inverted:inverted};
};

/*
 * Operations
 */

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.getPreferredLookupServerKeyIndex = function() {
  return this._preferredIndex;
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.isUpdateRequired = function() {
  return true;
};

/**
 * @private
 * @const
 */
wrm.data.sync.CollapsedTupleStore._SELECT_CHUNK_SIZE = 600;

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.select = function(dataContext, resolved, bulkFilter) {
  var selectQuery = resolved ? this._resolvedQueries.select : this._unresolvedQueries.select;
  
  var bulkFilters = this.sliceBulkFilter(bulkFilter, wrm.data.sync.CollapsedTupleStore._SELECT_CHUNK_SIZE);
  if (bulkFilters) {
    return (Promise.map(bulkFilters, function(chunkBulkFilter) {
      return selectQuery.query(dataContext, chunkBulkFilter);
    }, {concurrency:this.selectConcurrency}).then(function(chunks) {
      return Array.prototype.concat.apply([], chunks);
    }));
  }
  
  return Promise.resolve([]);
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.insert = function(dataContext, resolved, values) {
  
  /* Forbid inserting resolved tuples, since it would be like crating "ghost" entities */
  if (resolved) {
    throw new Error("Collapsed resolved association tuples cannot be inserted directly");
  }
  
  var insertQuery = this._unresolvedQueries.insert;
  var newValues = this.extractNewValues(values);
  if (!resolved) {
    this._requirePurging();
  }
  return insertQuery.executeGetChanged(dataContext, newValues);
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.update = function(dataContext, resolved, values, filter) {
  var updateQuery = resolved ? this._resolvedQueries.update : this._unresolvedQueries.update;
  var newValues = this.extractNewValues(values);
  var allValues = angular.extend({}, filter, newValues);
  if (!resolved) {
    this._requirePurging();
  }
  return updateQuery.executeGetChanged(dataContext, allValues);
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype["delete"] = function(dataContext, resolved, filter) {
  
  /*
   * Forbid deleting tuples in all cases. For resolved tuples, it would be like deleting entities, which is not the responsibility of
   * this object. For unresolved tuples, it may cause other tuples or tracks that share the same row to be deleted: this is handled
   * at a different time by the purger rule
   */
  throw new Error("Collapsed association tuples cannot be deleted directly");
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.selectTracks = function(dataContext, type, filter) {
  var selectQuery = this._tracksQueries[type].select;
  return (selectQuery.query(dataContext, filter));
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.insertTrack = function(dataContext, type, values, timestamp) {
  var insertQuery = this._tracksQueries[type].insert;
  var newValues = angular.extend(this.extractNewValues(values), {"timestamp":timestamp});
  this._requirePurging();
  return insertQuery.executeGetChanged(dataContext, newValues);
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.updateTracks = function(dataContext, type, values, timestamp, filter) {
  var updateQuery = this._tracksQueries[type].update;
  var newValues = angular.extend(this.extractNewValues(values), {"timestamp":timestamp});
  var allValues = angular.extend({}, filter, newValues);
  this._requirePurging();
  return updateQuery.executeGetChanged(dataContext, allValues);
};

/** @override */
wrm.data.sync.CollapsedTupleStore.prototype.deleteTracks = function(dataContext, type, filter) {
  
  /*
   * Forbid deleting tracks in all cases, since it may cause other tuples or tracks that share the same row to be deleted: this is
   * handled at a different time by the purger rule
   */
  throw new Error("Collapsed association tracks cannot be deleted directly");
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.sync.CollapsedTupleStore.prototype._requirePurging = function() {
  this._purger.touch(this._purgeRuleId);
};




//== wrm/data/sync/AssociationPersister.js ====================================



/**
 * @package
 * @constructor
 * @class Helper for managing the persistent storage of association instances and of tracks of association changes.
 *        <p>
 *        Each association instance is represented in two ways:
 *        <ul>
 *        <li>a pair of (local) keys,
 *        <li>a pair of server keys.
 *        </ul>
 *        A single association instance may have only server keys or both local and server keys. A server-only association instance is
 *        known as <i>unresolved</i>, while client-too instances are called <i>resolved</i>.
 *        <p>
 *        The association persister provides operations for managing the association using either local key pairs or server key pairs.
 *        <p>
 *        The history of association changes is composed by <i>addition</i> and <i>removal</i> tracks, each of them memorizing the
 *        addition/removal of an association instance.
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.AssociationPersister = function(assoc, purger, dataRunner) {
  
  /** @protected */
  this.assoc = assoc;
  
  /** @private */
  this._store = wrm.data.sync.AssociationPersister._createTupleStore(assoc, purger, dataRunner);
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {!wrm.data.sync.AbstractTupleStore}
 */
wrm.data.sync.AssociationPersister._createTupleStore = function(assoc, purger, dataRunner) {
  var role1 = assoc.getRole1();
  var role2 = assoc.getRole2();
  
  /*
   * Proceed differently depending on how the association roles are implemented. There are two possible implementation: BRIDGED and
   * COLLAPSED. Bridged mode has no foreign keys (implying a "bridge" entity). Collapsed mode has a single foreign key. Multiple
   * foreign keys do not make sense.
   */
  if (role1.isForeignKey() && role2.isForeignKey()) {
    throw new Error("Association has two foreign keys");
  } else {
    if (role1.isForeignKey() || role2.isForeignKey()) {
      return new wrm.data.sync.CollapsedTupleStore(assoc, purger, dataRunner);
    } else {
      return new wrm.data.sync.BridgedTupleStore(assoc, purger, dataRunner);
    }
  }
};

/**
 * @package
 * @param {number} selectConcurrency
 */
wrm.data.sync.AssociationPersister.prototype.setSelectConcurrency = function(selectConcurrency) {
  this._store.setSelectConcurrency(selectConcurrency);
};

/*
 * Operations
 */

/**
 * @package
 * @return {number}
 */
wrm.data.sync.AssociationPersister.prototype.getPreferredLookupKeyIndex = function() {
  return this._store.getPreferredLookupServerKeyIndex();
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*|!Array<*>} serverKey1
 * @param {?*|!Array<*>} serverKey2
 * @return {!Promise.<!Array.<{serverKey1:?*, serverKey2:?*}>>}
 */
wrm.data.sync.AssociationPersister.prototype.select = function(dataContext, serverKey1, serverKey2) {
  return this.selectTuples(dataContext, null, null, serverKey1, serverKey2).then(function(tuples) {
    var result = [];
    tuples.forEach(function(tuple) {
      if (tuple.serverKey1 !== null && tuple.serverKey2 !== null) {
        result.push({serverKey1:tuple.serverKey1, serverKey2:tuple.serverKey2});
      }
    });
    return result;
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*} key1
 * @param {?*} key2
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.add = function(dataContext, key1, key2, serverKey1, serverKey2) {
  return this.insertTuple(dataContext, this._constructTuple(key1, key2, serverKey1, serverKey2));
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.remove = function(dataContext, serverKey1, serverKey2) {
  return this.deleteTuple(dataContext, this._constructTuple(null, null, serverKey1, serverKey2));
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise.<!Array.<{serverKey1:?*, serverKey2:?*}>>}
 */
wrm.data.sync.AssociationPersister.prototype.selectAdditionTracks = function(dataContext, serverKey1, serverKey2) {
  var type = wrm.data.sync.AbstractTupleStore.TrackType.ADDITION;
  return this._doSelectTracks(dataContext, type, serverKey1, serverKey2);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise.<!Array.<{serverKey1:?*, serverKey2:?*}>>}
 */
wrm.data.sync.AssociationPersister.prototype.selectRemovalTracks = function(dataContext, serverKey1, serverKey2) {
  var type = wrm.data.sync.AbstractTupleStore.TrackType.REMOVAL;
  return this._doSelectTracks(dataContext, type, serverKey1, serverKey2);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise.<!Array.<{serverKey1:?*, serverKey2:?*}>>}
 */
wrm.data.sync.AssociationPersister.prototype._doSelectTracks = function(dataContext, type, serverKey1, serverKey2) {
  return this.selectTracks(dataContext, type, null, null, serverKey1, serverKey2).then(function(trackTuples) {
    var result = [];
    trackTuples.forEach(function(trackTuple) {
      if (trackTuple.serverKey1 !== null && trackTuple.serverKey2 !== null) {
        result.push({serverKey1:trackTuple.serverKey1, serverKey2:trackTuple.serverKey2});
      }
    });
    return result;
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @param {!wrm.data.DateTime} timestamp
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.addAdditionTrack = function(dataContext, serverKey1, serverKey2, timestamp) {
  var type = wrm.data.sync.AbstractTupleStore.TrackType.ADDITION;
  return this._addTrack(dataContext, type, this._constructTuple(null, null, serverKey1, serverKey2), timestamp);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @param {!wrm.data.DateTime} timestamp
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.addRemovalTrack = function(dataContext, serverKey1, serverKey2, timestamp) {
  var type = wrm.data.sync.AbstractTupleStore.TrackType.REMOVAL;
  return this._addTrack(dataContext, type, this._constructTuple(null, null, serverKey1, serverKey2), timestamp);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.removeAdditionTrack = function(dataContext, serverKey1, serverKey2) {
  var type = wrm.data.sync.AbstractTupleStore.TrackType.ADDITION;
  return this._removeTrack(dataContext, type, this._constructTuple(null, null, serverKey1, serverKey2));
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.removeRemovalTrack = function(dataContext, serverKey1, serverKey2) {
  var type = wrm.data.sync.AbstractTupleStore.TrackType.REMOVAL;
  return this._removeTrack(dataContext, type, this._constructTuple(null, null, serverKey1, serverKey2));
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AssociationPersister.Tuple} trackTuple
 * @param {!wrm.data.DateTime} timestamp
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype._addTrack = function(dataContext, type, trackTuple, timestamp) {
  var TrackType = wrm.data.sync.AbstractTupleStore.TrackType;
  var thisPersister = this;
  
  /* First remove the same track of the OTHER type */
  var otherType = type === TrackType.ADDITION ? TrackType.REMOVAL : TrackType.ADDITION;
  return this.deleteTrack(dataContext, otherType, trackTuple).then(function(wasDeleted) {
    if (wasDeleted) {
      return;
    }
    
    /* If not balanced by a delete, insert a new track */
    return thisPersister.insertTrack(dataContext, type, trackTuple, timestamp);
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AssociationPersister.Tuple} trackTuple
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype._removeTrack = function(dataContext, type, trackTuple) {
  return this.deleteTrack(dataContext, type, trackTuple);
};

/*
 * Low-level tuple/track operations
 */

/**
 * @protected
 * @typedef {{key1:?*, key2:?*, serverKey1:?*, serverKey2:?*}}
 */
wrm.data.sync.AssociationPersister.Tuple;

/**
 * @private
 * @param {?*=} key1
 * @param {?*=} key2
 * @param {?*=} serverKey1
 * @param {?*=} serverKey2
 * @return {wrm.data.sync.AssociationPersister.Tuple}
 */
wrm.data.sync.AssociationPersister.prototype._constructTuple = function(key1, key2, serverKey1, serverKey2) {
  return {key1:key1 !== undefined ? key1 : null, key2:key2 !== undefined ? key2 : null, serverKey1:serverKey1 !== undefined ? serverKey1 : null, serverKey2:serverKey2 !== undefined ? serverKey2 : null};
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*|!Array<*>} key1
 * @param {?*|!Array<*>} key2
 * @param {?*|!Array<*>} serverKey1
 * @param {?*|!Array<*>} serverKey2
 * @param {boolean=} resolved
 * @return {!Promise.<!Array.<wrm.data.sync.AssociationPersister.Tuple>>}
 */
wrm.data.sync.AssociationPersister.prototype.selectTuples = function(dataContext, key1, key2, serverKey1, serverKey2, resolved) {
  var thisPersister = this;
  var store = this._store;
  
  var tuples = {list:[], map:{}};
  
  /* Select resolved tuples, then unresolved ones (honoring the filter boolean if present) */
  var filter = this._prepareFilterForKeys(key1, key2, serverKey1, serverKey2);
  var promise = Promise.resolve();
  if (resolved !== false) {
    promise = promise.then(function() {
      return store.select(dataContext, true, filter).then(function(valuesList) {
        valuesList.forEach(function(values) {
          thisPersister._extractAndMergeTupleFromResultValues(tuples, values);
        });
      });
    });
  }
  if (resolved !== true) {
    promise = promise.then(function() {
      return store.select(dataContext, false, filter).then(function(valuesList) {
        valuesList.forEach(function(values) {
          thisPersister._extractAndMergeTupleFromResultValues(tuples, values);
        });
      });
    });
  }
  
  return promise.then(function() {
    return tuples.list;
  });
};

/**
 * @private
 * @param {{list:!Array.<wrm.data.sync.AssociationPersister.Tuple>, map:!Object.<string,number>}} tuples
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 */
wrm.data.sync.AssociationPersister.prototype._extractAndMergeTupleFromResultValues = function(tuples, values) {
  
  /* Extract a tuple directly from the new object */
  var newTuple = this._extractTupleFromResultValues(values);
  
  /* Tuples with server keys may be both resolved and unresolved: retrieve a possible previous instance of them on the map */
  var mapKey = null, listIndex = null, oldTuple = null;
  if (newTuple.serverKey1 !== null && newTuple.serverKey2 !== null) {
    mapKey = String(newTuple.serverKey1) + "###" + String(newTuple.serverKey2);
    listIndex = tuples.map[mapKey];
    if (listIndex === undefined) {
      tuples.list.push(newTuple);
      listIndex = tuples.list.length - 1;
      tuples.map[mapKey] = listIndex;
      oldTuple = null;
    } else {
      oldTuple = tuples.list[listIndex];
    }
  }
  
  /* Integrate data from the old tuple */
  if (oldTuple) {
    Object.keys((oldTuple)).forEach(function(property) {
      var oldValue = oldTuple[property];
      var newValue = newTuple[property];
      if (newValue === null || newValue === undefined) {
        newTuple[property] = oldValue;
      }
    });
  }
  
  /* Update or add to the list */
  if (listIndex !== null) {
    tuples.list[listIndex] = newTuple;
  } else {
    tuples.list.push(newTuple);
  }
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AssociationPersister.Tuple} oldTuple
 * @param {wrm.data.sync.AssociationPersister.Tuple} newTuple
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.updateTuple = function(dataContext, oldTuple, newTuple) {
  var thisPersister = this;
  var store = this._store;
  
  /* If the tuples are changing store type (resolved to unresolved or vice versa), just insert the new one */
  var oldResolved = this._isResolvedTuple(oldTuple);
  var newResolved = this._isResolvedTuple(newTuple);
  if (oldResolved !== newResolved) {
    return thisPersister.insertTuple(dataContext, newTuple);
  }
  
  /* Update to the new values or perform a delete followed by an insert */
  var resolved = oldResolved;
  var newValues = this._prepareValuesForTuple(newTuple);
  var filter = this._prepareFilterForTuple(oldTuple);
  if (store.isUpdateRequired()) {
    return store.update(dataContext, resolved, newValues, filter);
  } else {
    return store["delete"](dataContext, resolved, filter).then(function() {
      return store.insert(dataContext, resolved, newValues);
    });
  }
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AssociationPersister.Tuple} newTuple
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.insertTuple = function(dataContext, newTuple) {
  var thisPersister = this;
  var store = this._store;
  
  /* First delete the same tuple from the OTHER store type */
  var resolved = this._isResolvedTuple(newTuple);
  return this.deleteTuple(dataContext, newTuple, !resolved).then(function() {
    
    /* If required, attempt to update first. In all cases, fallback to inserting */
    var values = thisPersister._prepareValuesForTuple(newTuple);
    if (store.isUpdateRequired()) {
      var filter = thisPersister._prepareFilterForTuple(newTuple);
      return store.update(dataContext, resolved, values, filter).then(function(wasUpdated) {
        if (wasUpdated) {
          return;
        }
        return store.insert(dataContext, resolved, values);
      });
    } else {
      return store.insert(dataContext, resolved, values);
    }
  });
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AssociationPersister.Tuple} oldTuple
 * @param {boolean=} resolved
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.deleteTuple = function(dataContext, oldTuple, resolved) {
  var store = this._store;
  
  /* Update to nulls or delete, depending on the store capabilities, both resolved and unresolved */
  var filter = this._prepareFilterForTuple(oldTuple);
  var resolvedFlags = resolved !== undefined ? [resolved] : [true, false];
  return Promise.all(resolvedFlags.map(function(resolved) {
    if (store.isUpdateRequired()) {
      return store.update(dataContext, resolved, {key1:null, key2:null, serverKey1:null, serverKey2:null}, filter);
    } else {
      return store["delete"](dataContext, resolved, filter);
    }
  }));
};

/**
 * @private
 * @param {wrm.data.sync.AssociationPersister.Tuple} tuple
 * @return {boolean}
 */
wrm.data.sync.AssociationPersister.prototype._isResolvedTuple = function(tuple) {
  return tuple.key1 !== null && tuple.key2 !== null;
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {?*} key1
 * @param {?*} key2
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise.<!Array.<wrm.data.sync.AssociationPersister.Tuple>>}
 */
wrm.data.sync.AssociationPersister.prototype.selectTracks = function(dataContext, type, key1, key2, serverKey1, serverKey2) {
  var thisPersister = this;
  var store = this._store;
  
  /* Select tracks */
  var filter = this._prepareValuesForKeys(key1, key2, serverKey1, serverKey2);
  return store.selectTracks(dataContext, type, filter).then(function(valuesList) {
    return valuesList.map(function(values) {
      return thisPersister._extractTupleFromResultValues(values);
    });
  });
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AssociationPersister.Tuple} newTrackTuple
 * @param {!wrm.data.DateTime} newTrackTimestamp
 * @return {!Promise}
 */
wrm.data.sync.AssociationPersister.prototype.insertTrack = function(dataContext, type, newTrackTuple, newTrackTimestamp) {
  var store = this._store;
  
  /* If required, attempt to update first. In all cases, fallback to inserting */
  var values = this._prepareValuesForTuple(newTrackTuple);
  if (store.isUpdateRequired()) {
    var filter = this._prepareFilterForTuple(newTrackTuple);
    return store.updateTracks(dataContext, type, values, newTrackTimestamp, filter).then(function(wasUpdated) {
      if (wasUpdated) {
        return;
      }
      return store.insertTrack(dataContext, type, values, newTrackTimestamp);
    });
  } else {
    return store.insertTrack(dataContext, type, values, newTrackTimestamp);
  }
};

/**
 * @protected
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AbstractTupleStore.TrackType} type
 * @param {wrm.data.sync.AssociationPersister.Tuple} oldTrackTuple
 * @return {!Promise.<boolean>}
 */
wrm.data.sync.AssociationPersister.prototype.deleteTrack = function(dataContext, type, oldTrackTuple) {
  var store = this._store;
  
  /* Update to nulls or delete, depending on the store capabilities */
  var filter = this._prepareFilterForTuple(oldTrackTuple);
  if (store.isUpdateRequired()) {
    return store.updateTracks(dataContext, type, {key1:null, key2:null, serverKey1:null, serverKey2:null}, null, filter);
  } else {
    return store.deleteTracks(dataContext, type, filter);
  }
};

/**
 * @private
 * @param {wrm.data.sync.AbstractTupleStore.Values} values
 * @return {wrm.data.sync.AssociationPersister.Tuple}
 */
wrm.data.sync.AssociationPersister.prototype._extractTupleFromResultValues = function(values) {
  return {key1:values["key1"] || null, key2:values["key2"] || null, serverKey1:values["serverKey1"] || null, serverKey2:values["serverKey2"] || null};
};

/**
 * @private
 * @param {wrm.data.sync.AssociationPersister.Tuple} tuple
 * @return {wrm.data.sync.AbstractTupleStore.Values}
 */
wrm.data.sync.AssociationPersister.prototype._prepareValuesForTuple = function(tuple) {
  return {key1:tuple.key1, key2:tuple.key2, serverKey1:tuple.serverKey1, serverKey2:tuple.serverKey2};
};

/**
 * @private
 * @param {?*} key1
 * @param {?*} key2
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {wrm.data.sync.AbstractTupleStore.Values}
 */
wrm.data.sync.AssociationPersister.prototype._prepareValuesForKeys = function(key1, key2, serverKey1, serverKey2) {
  return {key1:key1 !== null ? key1 : undefined, key2:key2 !== null ? key2 : undefined, serverKey1:serverKey1 !== null ? serverKey1 : undefined, serverKey2:serverKey2 !== null ? serverKey2 : undefined};
};

/**
 * @private
 * @param {?*|!Array<*>} key1
 * @param {?*|!Array<*>} key2
 * @param {?*|!Array<*>} serverKey1
 * @param {?*|!Array<*>} serverKey2
 * @return {wrm.data.sync.AbstractTupleStore.BulkFilter}
 */
wrm.data.sync.AssociationPersister.prototype._prepareFilterForKeys = function(key1, key2, serverKey1, serverKey2) {
  return {key1:key1 !== null ? key1 : undefined, key2:key2 !== null ? key2 : undefined, serverKey1:serverKey1 !== null ? serverKey1 : undefined, serverKey2:serverKey2 !== null ? serverKey2 : undefined};
};

/**
 * @private
 * @param {wrm.data.sync.AssociationPersister.Tuple} tuple
 * @return {wrm.data.sync.AbstractTupleStore.Filter}
 */
wrm.data.sync.AssociationPersister.prototype._prepareFilterForTuple = function(tuple) {
  return {key1:tuple.key1 !== null ? tuple.key1 : undefined, key2:tuple.key2 !== null ? tuple.key2 : undefined, serverKey1:tuple.serverKey1 !== null ? tuple.serverKey1 : undefined, serverKey2:tuple.serverKey2 !== null ? tuple.serverKey2 : undefined};
};




//== wrm/util/ListProcessor.js ================================================


/**
 * @internal
 * @template E
 * @constructor
 */
wrm.util.ListProcessor = function() {
  
  /** @private {!Array<E>} */
  this._list = [];
  
  /** @private {!Array<!wrm.util.ListProcessor._Processor<E>>} */
  this._processors = [];
  
  /** @private {!Array<number>} */
  this._allIndexesToProcess = [];
  
  /** @private {?function(E):(E|undefined)} */
  this._finalizer = null;
  
  /** @private {?boolean} */
  this._processed = null;
};

/**
 * @template PV
 * @param {function(E):(string|undefined)} valueGetter
 * @param {function(!Array<string>):(!Promise<!Array<PV>>|!Array<PV>)} bulkProcessor
 * @param {function(PV):(string|undefined)} originalValueMatcher
 * @param {function(E,PV)} valueSetter
 */
wrm.util.ListProcessor.prototype.registerValueProcessor = function(valueGetter, bulkProcessor, originalValueMatcher, valueSetter) {
  if (this._list.length > 0) {
    throw new Error("Cannot register processors after adding elements");
  }
  this._processors.push(new wrm.util.ListProcessor._Processor(this, valueGetter, bulkProcessor, originalValueMatcher, valueSetter));
};

/**
 * @param {function(E):(E|undefined)} finalizer
 */
wrm.util.ListProcessor.prototype.registerFinalizer = function(finalizer) {
  if (this._finalizer) {
    throw new Error("Finalizer already registered");
  }
  this._finalizer = finalizer;
};

/**
 * @param {E} element
 */
wrm.util.ListProcessor.prototype.add = function(element) {
  if (this._processed !== null) {
    throw new Error("Cannot add element after processing has started");
  }
  this._list.push(element);
  var index = this._list.length - 1;
  
  /* Enlist the object for possible processing of its values */
  var willBeProcessed = false;
  for (var i = 0;i < this._processors.length;i++) {
    willBeProcessed = this._processors[i].enlist(element, index) || willBeProcessed;
  }
  if (willBeProcessed) {
    this._allIndexesToProcess.push(index);
  }
};

/**
 * @param {!Array<E>} elements
 */
wrm.util.ListProcessor.prototype.addAll = function(elements) {
  for (var i = 0;i < elements.length;i++) {
    this.add(elements[i]);
  }
};

/**
 * @return {!Promise<!Array<E>>}
 */
wrm.util.ListProcessor.prototype.process = function() {
  if (this._processed !== null) {
    throw new Error("Cannot start another processing");
  }
  this._processed = false;
  return this._doProcess().then(function() {
    this._processed = true;
    return this._list;
  }.bind(this));
};

/**
 * @private
 * @return {!Promise}
 */
wrm.util.ListProcessor.prototype._doProcess = function() {
  
  /* Exit immediately if there is nothing to process */
  if (this._allIndexesToProcess.length <= 0) {
    return Promise.resolve();
  }
  
  /* Process in parallel */
  return Promise.all(this._processors.map(function(processor) {
    return processor.process();
  })).then(function() {
    
    /* Finalize all processed elements */
    var finalizer = this._finalizer;
    if (finalizer) {
      for (var i = 0;i < this._allIndexesToProcess.length;i++) {
        var index = this._allIndexesToProcess[i];
        var element = this._list[index];
        var replacementElement = finalizer(element);
        if (replacementElement !== undefined) {
          this._list[index] = replacementElement;
        }
      }
    }
  }.bind(this));
};

/**
 * @private
 * @template E, PV
 * @constructor
 * @param {!wrm.util.ListProcessor} parent
 * @param {function(E):(string|undefined)} valueGetter
 * @param {function(!Array<string>):(!Promise<!Array<PV>>|!Array<PV>)} bulkProcessor
 * @param {function(PV):(string|undefined)} originalValueMatcher
 * @param {function(E,PV)} valueSetter
 */
wrm.util.ListProcessor._Processor = function(parent, valueGetter, bulkProcessor, originalValueMatcher, valueSetter) {
  this._parent = parent;
  this._valueGetter = valueGetter;
  this._bulkProcessor = bulkProcessor;
  this._originalValueMatcher = originalValueMatcher;
  this._valueSetter = valueSetter;
  
  /** @type {!Object<string,!Array<number>>} */
  this._indexesByValue = {};
};

/**
 * @param {E} element
 * @param {number} index
 * @return {boolean}
 */
wrm.util.ListProcessor._Processor.prototype.enlist = function(element, index) {
  var value = this._valueGetter(element);
  if (value !== undefined) {
    var arr = this._indexesByValue[value];
    if (!arr) {
      this._indexesByValue[value] = arr = [];
    }
    arr.push(index);
    return true;
  }
  return false;
};

/**
 * @return {!Promise}
 */
wrm.util.ListProcessor._Processor.prototype.process = function() {
  
  /* Get the values to process; exit if there are none */
  var values = Object.keys(this._indexesByValue);
  if (values.length <= 0) {
    return Promise.resolve();
  }
  
  /* Process all values in bulk */
  var list = this._parent._list;
  return Promise.resolve(this._bulkProcessor(values)).then(function(processedValues) {
    
    /* Set processed values on elements */
    for (var i = 0;i < processedValues.length;i++) {
      var processedValue = processedValues[i];
      var value = this._originalValueMatcher(processedValue);
      if (value !== undefined) {
        var indexes = this._indexesByValue[value];
        if (DEBUG && !indexes) {
          throw new Error("Unknown value: check values providers, setter, and values processor.");
        }
        for (var j = 0;j < indexes.length;j++) {
          var element = list[indexes[j]];
          this._valueSetter(element, processedValue);
        }
      }
    }
  }.bind(this));
};




//== wrm/data/sync/AssociationResolvingPersister.js ===========================



/**
 * @package
 * @constructor
 * @class An enhanced association persister that is also capable of handling the <i>resolution</i> of tuples.
 *        <p>
 *        The additional {@link #resolve} method will carry out resolution of local keys from server ones using the supplied
 *        {@link wrm.data.sync.KeyResolver}.
 * @extends wrm.data.sync.AssociationPersister
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.sync.KeyResolver} keyResolver
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.AssociationResolvingPersister = function(assoc, keyResolver, purger, dataRunner) {
  wrm.data.sync.AssociationPersister.call(this, assoc, purger, dataRunner);
  
  /** @private */
  this._keyResolver = keyResolver;
  
  /** @private */
  this._selectConcurrency = +Infinity;
};

extendConstructor(wrm.data.sync.AssociationResolvingPersister, wrm.data.sync.AssociationPersister);

/** @override */
wrm.data.sync.AssociationResolvingPersister.prototype.setSelectConcurrency = function(selectConcurrency) {
  wrm.data.sync.AssociationResolvingPersister._super.setSelectConcurrency.call(this, selectConcurrency);
  this._selectConcurrency = selectConcurrency;
};

/*
 * Operations
 */

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} concurrency
 * @return {!Promise<number>}
 */
wrm.data.sync.AssociationResolvingPersister.prototype.resolve = function(dataContext, concurrency) {
  var $jscomp$this = this;
  
  /* Process all unresolved tuples */
  var resolvedCount = 0;
  return this.selectTuples(dataContext, null, null, null, null, false).then(function(unresolvedTuples) {
    
    /* Attempt to resolve the tuples, all in one go */
    return $jscomp$this._resolveTuples(dataContext, unresolvedTuples).then(function(resolvedTuples) {
      
      /* Update each tuple if resolved */
      return Promise.map(unresolvedTuples, function(tuple, i) {
        var resolvedTuple = resolvedTuples[i];
        if (resolvedTuple) {
          resolvedCount++;
          return $jscomp$this.updateTuple(dataContext, tuple, resolvedTuple);
        }
      }, {concurrency:concurrency});
    });
  }).then(function() {
    return resolvedCount;
  });
};

/*
 * Low-level tuple/track operations
 */

/** @override */
wrm.data.sync.AssociationResolvingPersister.prototype.updateTuple = function(dataContext, oldTuple, newTuple) {
  
  /* Attempt a cheap resolution from cache */
  newTuple = this._resolveTupleFromCache(newTuple) || newTuple;
  
  return wrm.data.sync.AssociationResolvingPersister._super.updateTuple.call(this, dataContext, oldTuple, newTuple);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Array<wrm.data.sync.AssociationPersister.Tuple>} tuples
 * @return {!Promise<!Array<?wrm.data.sync.AssociationPersister.Tuple>>}
 */
wrm.data.sync.AssociationResolvingPersister.prototype._resolveTuples = function(dataContext, tuples) {
  var $jscomp$this = this;
  var keyResolver = this._keyResolver;
  var assoc = this.assoc;
  
  /** @type {!wrm.util.ListProcessor<?wrm.data.sync.AssociationPersister.Tuple>} */
  var processor = new wrm.util.ListProcessor;
  
  /* Processor for resolving key 1 by server key 1 */
  processor.registerValueProcessor(function(tuple) {
    if (tuple !== null && tuple.key1 === null) {
      return String(tuple.serverKey1);
    }
  }, function(serverKeys) {
    var entity1 = assoc.getRole1().getEntity();
    return keyResolver.resolveAll(dataContext, entity1, serverKeys, $jscomp$this._selectConcurrency);
  }, function(pair) {
    if (pair.key !== null) {
      return pair.serverKey;
    }
  }, function(tuple, pair) {
    tuple.key1 = pair.key;
  });
  
  /* Processor for resolving key 2 by server key 2 */
  processor.registerValueProcessor(function(tuple) {
    if (tuple !== null && tuple.key2 === null) {
      return String(tuple.serverKey2);
    }
  }, function(serverKeys) {
    var entity2 = assoc.getRole2().getEntity();
    return keyResolver.resolveAll(dataContext, entity2, serverKeys, $jscomp$this._selectConcurrency);
  }, function(pair) {
    if (pair.key !== null) {
      return pair.serverKey;
    }
  }, function(tuple, pair) {
    tuple.key2 = pair.key;
  });
  
  /* Finalizer for replacing still-unresolved tuples with 'null' in the resulting list */
  processor.registerFinalizer(function(tuple) {
    if (tuple.key1 === null || tuple.key2 === null) {
      return null;
    }
  });
  
  /*
   * Scan all tuples. Immediately put a 'null' for tuples that are already resolved or that can not yet be resolved: this is enough
   * to inhibit the two value processors defined above.
   */
  tuples.forEach(function(tuple, i) {
    if (tuple.key1 !== null && tuple.key2 !== null) {
      processor.add(null);
    } else {
      if (tuple.serverKey1 === null || tuple.serverKey2 === null) {
        processor.add(null);
      } else {
        processor.add(angular.extend({}, tuple));
      }
    }
  });
  
  return processor.process();
};

/**
 * @private
 * @param {wrm.data.sync.AssociationPersister.Tuple} tuple
 * @return {?wrm.data.sync.AssociationPersister.Tuple}
 */
wrm.data.sync.AssociationResolvingPersister.prototype._resolveTupleFromCache = function(tuple) {
  var resolved1 = tuple.key1 !== null;
  var resolved2 = tuple.key2 !== null;
  if (resolved1 && resolved2) {
    return null;
  }
  
  var entity1 = this.assoc.getRole1().getEntity();
  var entity2 = this.assoc.getRole2().getEntity();
  
  /* Resolve keys from cache */
  var resolvedKey1 = !resolved1 ? this._keyResolver.resolveFromCache(entity1, tuple.serverKey1) : null;
  var resolvedKey2 = !resolved2 ? this._keyResolver.resolveFromCache(entity2, tuple.serverKey2) : null;
  if (resolvedKey1 === null && resolvedKey2 === null) {
    return null;
  }
  
  /* At least one key was resolved: return a new tuple */
  return {key1:resolvedKey1 !== null ? resolvedKey1 : tuple.key1, key2:resolvedKey2 !== null ? resolvedKey2 : tuple.key2, serverKey1:tuple.serverKey1, serverKey2:tuple.serverKey2};
};




//== wrm/data/sync/AssociationAligner.js ======================================



/**
 * @package
 * @constructor
 * @class Helper for keeping track of desired changes of an association and ultimately align it.
 *        <p>
 *        Changes indicated by the server should be reported to the aligner by calling {@link #createdRecord}, {@link #updatedRecord}
 *        and {@link #deletedRecord}. After all server changes are committed to the entities, the changes to the association can be
 *        finalized by invoking {@link #save}.
 *        <p>
 *        When an entity changes, it is possible that attached associations need to change to align to the new entity as modified by
 *        the server. This is true even when not changing the said associations directly. In cases like this, {@link #align} should be
 *        invoked on the corresponding association aligner.
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.sync.KeyResolver} keyResolver
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.AssociationAligner = function(assoc, keyResolver, purger, dataRunner) {
  
  /** @private */
  this._assoc = assoc;
  
  /** @private */
  this._persister = new wrm.data.sync.AssociationResolvingPersister(assoc, keyResolver, purger, dataRunner);
  
  /* Find the role that is also a foreign key and can therefore be inlined in CUD operations */
  var inlinedRole = null;
  if (assoc.getRole1().isForeignKey() && assoc.getRole1().getServerName()) {
    inlinedRole = assoc.getRole1();
  } else {
    if (assoc.getRole2().isForeignKey() && assoc.getRole2().getServerName()) {
      inlinedRole = assoc.getRole2();
    }
  }
  
  /** @private */
  this._inlinedRole = inlinedRole;
  
  /** @private */
  this._keyResolver = keyResolver;
  
  /** @private */
  this._selectConcurrency = +Infinity;
  
  /**
   * Final desired server keys as seen from ROLE 1 of the association, i.e. server keys of side 2 mapped by server key of side 1.
   * 
   * @private
   * @type {!Object.<?,!Object.<?,boolean>>}
   */
  this._desiredPairings1 = {};
  
  /**
   * Final desired server keys as seen from ROLE 2 of the association, i.e. server keys of side 1 mapped by server key of side 2.
   * 
   * @private
   * @type {!Object.<?,!Object.<?,boolean>>}
   */
  this._desiredPairings2 = {};
  
  /**
   * Pairings to be deleted. May also include sets of pairings, with one key left open.
   * 
   * @private
   * @type {!Array.<{serverKey1:?*, serverKey2:?*}>}
   */
  this._deletedPairings = [];
};

/**
 * @return {!wrm.data.meta.Association}
 */
wrm.data.sync.AssociationAligner.prototype.getAssociation = function() {
  return this._assoc;
};

/**
 * @package
 * @param {number} selectConcurrency
 */
wrm.data.sync.AssociationAligner.prototype.setSelectConcurrency = function(selectConcurrency) {
  this._persister.setSelectConcurrency(selectConcurrency);
  this._selectConcurrency = selectConcurrency;
};

/*
 * Server record CUD tracking
 */

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} serverRecord
 */
wrm.data.sync.AssociationAligner.prototype.createdRecord = function(entity, serverRecord) {
  this._trackDesiredRecord(entity, serverRecord);
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} serverRecord
 */
wrm.data.sync.AssociationAligner.prototype.updatedRecord = function(entity, serverRecord) {
  this._trackDesiredRecord(entity, serverRecord);
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} serverRecord
 */
wrm.data.sync.AssociationAligner.prototype._trackDesiredRecord = function(entity, serverRecord) {
  var entity1 = this._assoc.getRole1().getEntity();
  var entity2 = this._assoc.getRole2().getEntity();
  
  /* Find the server names of the record properties holding the two roles */
  var role, nearPairings, farPairings;
  if (entity1 === entity) {
    role = this._assoc.getRole1();
    nearPairings = this._desiredPairings1;
    farPairings = this._desiredPairings2;
  } else {
    if (entity2 === entity) {
      role = this._assoc.getRole2();
      nearPairings = this._desiredPairings2;
      farPairings = this._desiredPairings1;
    } else {
      return;
    }
  }
  var nearKeyServerName = entity.getServerKeyAttribute().getServerName();
  var farKeyServerName = role.getServerName();
  
  if (serverRecord[farKeyServerName] === undefined) {
    return;
  }
  
  /* Extract server keys */
  var nearServerKey = wrm.data.toAnySingle(serverRecord[nearKeyServerName]);
  var farServerKeys = wrm.data.toAnyArray(serverRecord[farKeyServerName]);
  
  /*
   * Record desired server keys. On the NEAR side, record them exactly. On the FAR side, update the exact reversed information only
   * if already known. Generally speaking, pairings on the near side cannot be "swapped" to be used on the far side, since they might
   * carry incomplete information about the association.
   */
  var farServerKeysSet = nearPairings[nearServerKey];
  if (!farServerKeysSet) {
    nearPairings[nearServerKey] = farServerKeysSet = {};
  }
  for (var i = 0;i < farServerKeys.length;i++) {
    var farServerKey = farServerKeys[i];
    farServerKeysSet[farServerKey] = true;
    var reversedNearServerKeysSet = farPairings[farServerKey];
    if (reversedNearServerKeysSet) {
      reversedNearServerKeysSet[nearServerKey] = true;
    }
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} serverKey
 */
wrm.data.sync.AssociationAligner.prototype.deletedRecord = function(entity, serverKey) {
  var entity1 = this._assoc.getRole1().getEntity();
  var entity2 = this._assoc.getRole2().getEntity();
  
  /* Ignore records that were still unknown to the server */
  if (serverKey === null) {
    return;
  }
  
  /* Construct a pairing set with the server key */    /** @type {{serverKey1:?*, serverKey2:?*}} */
  var pairing;
  if (entity1 === entity) {
    pairing = {serverKey1:serverKey, serverKey2:null};
  } else {
    if (entity2 === entity) {
      pairing = {serverKey1:null, serverKey2:serverKey};
    } else {
      return;
    }
  }
  
  /* Align desired pairings as seen from both sides */
  if (pairing.serverKey1 !== null) {
    this._desiredPairings1[pairing.serverKey1] = {};
    var serverKeys2 = Object.keys(this._desiredPairings2);
    for (var i = 0;i < serverKeys2.length;i++) {
      var serverKey2 = serverKeys2[i];
      var serverKeysSet = this._desiredPairings2[serverKey2];
      if (serverKeysSet) {
        delete serverKeysSet[pairing.serverKey1];
      }
    }
  } else {
    this._desiredPairings2[pairing.serverKey2] = {};
    var serverKeys1 = Object.keys(this._desiredPairings1);
    for (var j = 0;j < serverKeys1.length;j++) {
      var serverKey1 = serverKeys1[j];
      var serverKeysSet$0 = this._desiredPairings1[serverKey1];
      if (serverKeysSet$0) {
        delete serverKeysSet$0[pairing.serverKey2];
      }
    }
  }
  
  this._deletedPairings.push(pairing);
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.sync.AssociationAligner.prototype.reset = function() {
  this._desiredPairings1 = {};
  this._desiredPairings2 = {};
  this._deletedPairings = [];
};

/*
 * Entity CUD tracking (to reflect server records)
 */

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array<!Object>} serverRecords
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype.resolveInlineKeyValues = function(dataContext, entity, serverRecords) {
  var $jscomp$this = this;
  var keyResolver = this._keyResolver;
  var inlinedRole = this._inlinedRole;
  if (!inlinedRole || inlinedRole.getEntity() !== entity) {
    return Promise.resolve();
  }
  var roleId = inlinedRole.getId();
  var roleServerName = inlinedRole.getServerName();
  
  /** @type {!wrm.util.ListProcessor<!Object>} */
  var processor = new wrm.util.ListProcessor;
  
  /* Processor for resolving the role key from server key if possible */
  processor.registerValueProcessor(function(serverRecord) {
    var serverKey = serverRecord[roleServerName];
    if (serverKey !== null && serverKey !== undefined) {
      return String(serverKey);
    }
  }, function(serverKeys) {
    var farEntity = inlinedRole.getInverseEntity();
    return keyResolver.resolveAll(dataContext, farEntity, serverKeys, $jscomp$this._selectConcurrency);
  }, function(pair) {
    if (pair.key !== null) {
      return pair.serverKey;
    }
  }, function(serverRecord, pair) {
    var inlineKeys = serverRecord["__INLINE_KEYS"];
    if (!inlineKeys) {
      serverRecord["__INLINE_KEYS"] = inlineKeys = {};
    }
    inlineKeys[roleId] = pair.key;
  });
  
  processor.addAll(serverRecords);
  return processor.process();
};

/*
 * Association updates
 */

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} concurrency
 * @param {!wrm.data.sync.AssociationSyncStats} stats
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype.save = function(dataContext, concurrency, stats) {
  var thisAligner = this;
  
  /* Delete pairings */
  var promise = this._deletePairings(dataContext, this._deletedPairings, stats).then(function() {
    thisAligner._deletedPairings = [];
  });
  
  /* Align each of the keys on side 1 with the new desired keys on side 2 */
  promise = promise.then(function() {
    var serverKeys1 = Object.keys(thisAligner._desiredPairings1);
    return thisAligner._selectCurrentTuples(dataContext, 1, serverKeys1).then(function(allCurrentTuples) {
      return thisAligner._alignToDesiredPairings(dataContext, allCurrentTuples, 1, serverKeys1, thisAligner._desiredPairings1, concurrency, stats);
    });
  }).then(function() {
    thisAligner._desiredPairings1 = {};
  });
  
  /* Align each of the keys on side 2 with the new desired keys on side 1 */
  return promise.then(function() {
    var serverKeys2 = Object.keys(thisAligner._desiredPairings2);
    return thisAligner._selectCurrentTuples(dataContext, 2, serverKeys2).then(function(allCurrentTuples) {
      return thisAligner._alignToDesiredPairings(dataContext, allCurrentTuples, 2, serverKeys2, thisAligner._desiredPairings2, concurrency, stats);
    });
  }).then(function() {
    thisAligner._desiredPairings2 = {};
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Array.<{serverKey1:?*, serverKey2:?*}>} pairingSets
 * @param {!wrm.data.sync.AssociationSyncStats} stats
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype._deletePairings = function(dataContext, pairingSets, stats) {
  var persister = this._persister;
  
  /* Remove all pairing sets */
  return Promise.all(pairingSets.map(function(pairingSet) {
    return persister.remove(dataContext, pairingSet.serverKey1, pairingSet.serverKey2).then(function() {
      stats.disconnected++;
    });
  }));
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Array<{serverKey1:?*, serverKey2:?*}>} allCurrentTuples
 * @param {number} side
 * @param {!Array<string>} nearServerKeysAsString
 * @param {!Object<?,!Object<string,boolean>>} desiredFarServerKeysSets
 * @param {number} concurrency
 * @param {!wrm.data.sync.AssociationSyncStats} stats
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype._alignToDesiredPairings = function(dataContext, allCurrentTuples, side, nearServerKeysAsString, desiredFarServerKeysSets, concurrency, stats) {
  var thisAligner = this;
  
  /*
   * Determine the current far server keys for each near server key, by scanning all current tuples. The constructed map of lists
   * should contain all and just the pairings corresponding to the near server keys of the "desired pairings" variable; this is a
   * consequence of how both arguments are constructed by calling functions, i.e. by selecting only current tuples pertaining to near
   * server keys that are changing desired pairings.
   */    /** @type {!Object<?,!Array<*>>} */
  var currentFarServerKeysLists = {};
  allCurrentTuples.forEach(function(tuple) {
    var tupleNearServerKeyAsString = String(side === 1 ? tuple.serverKey1 : tuple.serverKey2);
    if (desiredFarServerKeysSets[tupleNearServerKeyAsString]) {
      var currentFarServerKeys = currentFarServerKeysLists[tupleNearServerKeyAsString];
      if (!currentFarServerKeys) {
        currentFarServerKeysLists[tupleNearServerKeyAsString] = currentFarServerKeys = [];
      }
      currentFarServerKeys.push(side === 1 ? tuple.serverKey2 : tuple.serverKey1);
    }
  }, this);
  
  /* Find all tuples to remove and to add, by examining each near server key and its far ones */
  var removedTuples = [], addedTuples = [];
  nearServerKeysAsString.forEach(function(nearServerKeyAsString) {
    var currentFarServerKeys = currentFarServerKeysLists[nearServerKeyAsString] || [];
    var desiredFarServerKeys = Object.keys(desiredFarServerKeysSets[nearServerKeyAsString]);
    
    /* Determine the tuples to change depending on which pairings are newly or no longer desired */
    var diffs = wrm.util.obj.findValuesDiff(currentFarServerKeys, desiredFarServerKeys);
    diffs.removed.forEach(function(removedFarServerKey) {
      removedTuples.push({nearServerKey:nearServerKeyAsString, farServerKey:removedFarServerKey});
    }, this);
    diffs.added.forEach(function(addedFarServerKey) {
      addedTuples.push({nearServerKey:nearServerKeyAsString, farServerKey:addedFarServerKey});
    }, this);
  });
  
  /* Remove and add tuples */
  return Promise.resolve().then(function() {
    return thisAligner._doRemoveTuples(dataContext, side, removedTuples, concurrency);
  }).then(function() {
    return thisAligner._doAddTuples(dataContext, side, addedTuples, concurrency);
  }).then(function() {
    stats.disconnected += removedTuples.length;
    stats.connected += addedTuples.length;
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} side
 * @param {!Array<*>} nearServerKeys
 * @return {!Promise<!Array<{serverKey1:?*, serverKey2:?*}>>}
 */
wrm.data.sync.AssociationAligner.prototype._selectCurrentTuples = function(dataContext, side, nearServerKeys) {
  var $jscomp$this = this;
  var persister = this._persister;
  var serverKeys1 = side === 1 ? nearServerKeys : null;
  var serverKeys2 = side === 2 ? nearServerKeys : null;
  var assoc = this._assoc;
  
  /* Select all tuples, possibly including some with "unsafe" server keys, not created by the server */
  return persister.select(dataContext, serverKeys1, serverKeys2).then(function(allTuples) {
    
    /** @type {!wrm.util.ListProcessor<{serverKey1:?*, serverKey2:?*}>} */
    var processor = new wrm.util.ListProcessor;
    
    /* Processor for nulling "unsafe" server key 1 */
    processor.registerValueProcessor(function(tuple) {
      if (tuple.serverKey1 !== null) {
        return String(tuple.serverKey1);
      }
    }, function(serverKeys) {
      var entity1 = assoc.getRole1().getEntity();
      return wrm.data.sync.findAllKeys(dataContext, entity1, serverKeys, $jscomp$this._selectConcurrency);
    }, function(pair) {
      return pair.serverKey;
    }, function(tuple, pair) {
      if (pair.key === null) {
        tuple.serverKey1 = null;
      }
    });
    
    /* Processor for nulling "unsafe" server key 2 */
    processor.registerValueProcessor(function(tuple) {
      if (tuple.serverKey2 !== null) {
        return String(tuple.serverKey2);
      }
    }, function(serverKeys) {
      var entity2 = assoc.getRole2().getEntity();
      return wrm.data.sync.findAllKeys(dataContext, entity2, serverKeys, $jscomp$this._selectConcurrency);
    }, function(pair) {
      return pair.serverKey;
    }, function(tuple, pair) {
      if (pair.key === null) {
        tuple.serverKey2 = null;
      }
    });
    
    processor.addAll(allTuples);
    return processor.process();
  }).then(function(allTuplesWithSafeKeys) {
    
    /*
     * Filter out tuples that are missing server keys (either because they were not present or because they were turned into 'null'
     * by the processor above since they were unsafe
     */
    return allTuplesWithSafeKeys.filter(function(tuple) {
      return tuple.serverKey1 !== null && tuple.serverKey2 !== null;
    });
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} side
 * @param {!Array<{nearServerKey:?*, farServerKey:?*}>} tuples
 * @param {number} concurrency
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype._doAddTuples = function(dataContext, side, tuples, concurrency) {
  var $jscomp$this = this;
  var assoc = this._assoc;
  var keyResolver = this._keyResolver;
  var persister = this._persister;
  
  /** @type {!wrm.util.ListProcessor<{key1:?*, key2:?*, serverKey1:?*, serverKey2:?*}>} */
  var processor = new wrm.util.ListProcessor;
  
  /* Processor for resolving key 1 from server key 1 if possible */
  processor.registerValueProcessor(function(tuple) {
    if (tuple.serverKey1 !== null) {
      return String(tuple.serverKey1);
    }
  }, function(serverKeys) {
    var entity1 = assoc.getRole1().getEntity();
    return keyResolver.resolveAll(dataContext, entity1, serverKeys, $jscomp$this._selectConcurrency);
  }, function(pair) {
    if (pair.key !== null) {
      return pair.serverKey;
    }
  }, function(tuple, pair) {
    tuple.key1 = pair.key;
  });
  
  /* Processor for resolving key 2 from server key 2 if possible */
  processor.registerValueProcessor(function(tuple) {
    if (tuple.serverKey2 !== null) {
      return String(tuple.serverKey2);
    }
  }, function(serverKeys) {
    var entity2 = assoc.getRole2().getEntity();
    return keyResolver.resolveAll(dataContext, entity2, serverKeys, $jscomp$this._selectConcurrency);
  }, function(pair) {
    if (pair.key !== null) {
      return pair.serverKey;
    }
  }, function(tuple, pair) {
    tuple.key2 = pair.key;
  });
  
  /* Normalize the two sides and resolve keys (if possible) */
  tuples.forEach(function(tuple) {
    processor.add({key1:null, key2:null, serverKey1:side === 1 ? tuple.nearServerKey : tuple.farServerKey, serverKey2:side === 2 ? tuple.nearServerKey : tuple.farServerKey});
  });
  return processor.process().then(function(normalizedTuples) {
    
    /* Add each tuple */
    return Promise.map(normalizedTuples, function(tuple) {
      return persister.add(dataContext, tuple.key1, tuple.key2, tuple.serverKey1, tuple.serverKey2);
    }, {concurrency:concurrency});
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} side
 * @param {!Array<{nearServerKey:?*, farServerKey:?*}>} tuples
 * @param {number} concurrency
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype._doRemoveTuples = function(dataContext, side, tuples, concurrency) {
  var persister = this._persister;
  
  /* Normalize the tow sides and remove each tuple */
  return Promise.map(tuples, function(tuple) {
    var serverKey1 = side === 1 ? tuple.nearServerKey : tuple.farServerKey;
    var serverKey2 = side === 2 ? tuple.nearServerKey : tuple.farServerKey;
    return persister.remove(dataContext, serverKey1, serverKey2);
  }, {concurrency:concurrency});
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} concurrency
 * @param {!wrm.data.sync.AssociationSyncStats} stats
 * @return {!Promise}
 */
wrm.data.sync.AssociationAligner.prototype.align = function(dataContext, concurrency, stats) {
  return this._persister.resolve(dataContext, concurrency).then(function(resolvedCount) {
    stats.aligned += resolvedCount;
  });
};




//== wrm/data/sync/AssociationSetAligner.js ===================================


/**
 * @package
 * @constructor
 * @class Wrapper around a set of {@link wrm.data.sync.AssociationAligner} for aligning multiple associations at the same time in a
 *        convenient way.
 * @param {!Array.<!wrm.data.sync.AssociationAligner>} aligners
 */
wrm.data.sync.AssociationSetAligner = function(aligners) {
  
  /** @private */
  this._aligners = aligners;
};

/**
 * @return {!Array.<!wrm.data.sync.AssociationAligner>}
 */
wrm.data.sync.AssociationSetAligner.prototype.getAligners = function() {
  return this._aligners;
};

/**
 * @package
 * @param {number} selectConcurrency
 */
wrm.data.sync.AssociationSetAligner.prototype.setSelectConcurrency = function(selectConcurrency) {
  this._aligners.forEach(function(aligner) {
    aligner.setSelectConcurrency(selectConcurrency);
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} serverRecord
 */
wrm.data.sync.AssociationSetAligner.prototype.createdRecord = function(entity, serverRecord) {
  return this._aligners.forEach(function(aligner) {
    aligner.createdRecord(entity, serverRecord);
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} serverRecord
 */
wrm.data.sync.AssociationSetAligner.prototype.updatedRecord = function(entity, serverRecord) {
  return this._aligners.forEach(function(aligner) {
    aligner.updatedRecord(entity, serverRecord);
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} serverKey
 */
wrm.data.sync.AssociationSetAligner.prototype.deletedRecord = function(entity, serverKey) {
  return this._aligners.forEach(function(aligner) {
    aligner.deletedRecord(entity, serverKey);
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array<!Object>} serverRecords
 * @return {!Promise}
 */
wrm.data.sync.AssociationSetAligner.prototype.resolveKeys = function(dataContext, entity, serverRecords) {
  
  /* Let each aligned provide its own resolved keys (all of them are automatically merged into the server records) */
  return Promise.all(this._aligners.map(function(aligner) {
    return aligner.resolveInlineKeyValues(dataContext, entity, serverRecords);
  }, this));
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.sync.AssociationSetAligner.prototype.reset = function() {
  return this._aligners.forEach(function(aligner) {
    aligner.reset();
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} concurrency
 * @param {!wrm.data.sync.AssociationSyncStats} stats
 * @return {!Promise}
 */
wrm.data.sync.AssociationSetAligner.prototype.saveAndAlign = function(dataContext, concurrency, stats) {
  return this._aligners.reduce(function(chain, aligner) {
    return chain.then(function() {
      return aligner.save(dataContext, concurrency, stats);
    });
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {number} concurrency
 * @param {!wrm.data.sync.AssociationSyncStats} stats
 * @return {!Promise}
 */
wrm.data.sync.AssociationSetAligner.prototype.align = function(dataContext, concurrency, stats) {
  return this._aligners.reduce(function(chain, aligner) {
    return chain.then(function() {
      return aligner.align(dataContext, concurrency, stats);
    });
  });
};




//== wrm/data/sync/AssociationSyncStats.js ====================================


/**
 * @package
 * @constructor
 */
wrm.data.sync.AssociationSyncStats = function() {
  this.connected = 0;
  this.disconnected = 0;
  this.aligned = 0;
};

/**
 * @return {boolean}
 */
wrm.data.sync.AssociationSyncStats.prototype.hasChanges = function() {
  return this.connected > 0 || this.disconnected > 0 || this.aligned > 0;
};

/** @override */
wrm.data.sync.AssociationSyncStats.prototype.toString = function() {
  return "{connected: " + this.connected + ", disconnected: " + this.disconnected + ", aligned: " + this.aligned + "}";
};




//== wrm/data/sync/AssociationTracker.js ======================================



/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.AssociationTracker = function(assoc, purger, dataRunner) {
  
  /** @private */
  this._assoc = assoc;
  
  /** @private */
  this._persister = new wrm.data.sync.AssociationPersister(assoc, purger, dataRunner);
};

/**
 * @package
 * @param {!wrm.data.meta.Association} assoc
 * @return {boolean}
 */
wrm.data.sync.AssociationTracker.isRelevantAssociation = function(assoc) {
  var role1 = assoc.getRole1();
  var role2 = assoc.getRole2();
  return !!role1.getAddTimestampAuxiliaryAttribute() || !!role1.getRemoveTimestampAuxiliaryAttribute() || !!role2.getAddTimestampAuxiliaryAttribute() || !!role2.getRemoveTimestampAuxiliaryAttribute();
};

/*
 * Change tracking
 */

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.AssociationTracker.prototype.trackClientAdd = function(dataContext, serverKey1, serverKey2) {
  return this._persister.addAdditionTrack(dataContext, serverKey1, serverKey2, wrm.data.DateTime.now());
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.AssociationTracker.prototype.trackClientRemove = function(dataContext, serverKey1, serverKey2) {
  return this._persister.addRemovalTrack(dataContext, serverKey1, serverKey2, wrm.data.DateTime.now());
};

/*
 * Change collection and settlement
 */

/**
 * @package
 * @typedef {{serverKey1:*, serverKey2:*}}
 */
wrm.data.sync.AssociationTracker.Change;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise.<!Array.<wrm.data.sync.AssociationTracker.Change>>|!Promise.<null>}
 */
wrm.data.sync.AssociationTracker.prototype.collectAdditions = function(dataContext, serverKey1, serverKey2) {
  return this._persister.selectAdditionTracks(dataContext, serverKey1, serverKey2);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AssociationTracker.Change} change
 * @return {!Promise}
 */
wrm.data.sync.AssociationTracker.prototype.settleAddition = function(dataContext, change) {
  return this._persister.removeAdditionTrack(dataContext, change.serverKey1, change.serverKey2);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {?*} serverKey1
 * @param {?*} serverKey2
 * @return {!Promise.<!Array.<wrm.data.sync.AssociationTracker.Change>>|!Promise.<null>}
 */
wrm.data.sync.AssociationTracker.prototype.collectRemovals = function(dataContext, serverKey1, serverKey2) {
  return this._persister.selectRemovalTracks(dataContext, serverKey1, serverKey2);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.AssociationTracker.Change} change
 * @return {!Promise}
 */
wrm.data.sync.AssociationTracker.prototype.settleRemoval = function(dataContext, change) {
  return this._persister.removeRemovalTrack(dataContext, change.serverKey1, change.serverKey2);
};




//== wrm/data/sync/EntityTracksPersister.js ===================================


/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.EntityTracksPersister = function(entity, purger, dataRunner) {
  
  /** @private */
  this._entity = entity;
  
  /* Create queries */
  var main = this._createMainQueries(entity, dataRunner);
  var auxiliary = this._createAuxiliaryQueries(entity, dataRunner);
  
  /** @private */
  this._mainSelect = main && main.selectQuery;
  
  /** @private */
  this._mainSelectCreated = main && main.selectCreatedQuery;
  
  /** @private */
  this._mainSelectUpdated = main && main.selectUpdatedQuery;
  
  /** @private */
  this._mainUpdate = main && main.updateQuery;
  
  /** @private */
  this._auxSelectUpdate = auxiliary && auxiliary.selectUpdatedQuery;
  
  /** @private */
  this._auxSelectDelete = auxiliary && auxiliary.selectDeleteQuery;
  
  /** @private */
  this._auxInsert = auxiliary && auxiliary.insertQuery;
  
  /** @private */
  this._auxUpdate = auxiliary && auxiliary.updateQuery;
  
  /** @private */
  this._purger = purger;
  
  /** @private */
  this._purgeRuleId = this._registerPurgeRule(entity, purger);
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {?{selectQuery:!wrm.data.SelectQuery, selectCreatedQuery:?wrm.data.SelectQuery, selectUpdatedQuery:?wrm.data.SelectQuery,
 *         updateQuery:!wrm.data.UpdateQuery}}
 */
wrm.data.sync.EntityTracksPersister.prototype._createMainQueries = function(entity, dataRunner) {
  var createTsAttr = entity.getCreateTimestampAttribute();
  var updateTsAttr = entity.getUpdateTimestampAttribute();
  if (!createTsAttr && !updateTsAttr) {
    return null;
  }
  
  var entityId = entity.getId();
  var keyAttrId = entity.getKeyAttribute().getId();
  var serverKeyAttrId = entity.getServerKeyAttribute().getId();
  var createTsAttrId = createTsAttr && createTsAttr.getId();
  var upadteTsAttrId = updateTsAttr && updateTsAttr.getId();
  
  /* From this point onwards, actual QUERIES are constructed */
  
  /* Prepare a query for selecting a main instance row */
  var mainOutput = {"key":keyAttrId, "serverKey":serverKeyAttrId};
  if (createTsAttrId) {
    mainOutput["createdAt"] = createTsAttrId;
  }
  if (upadteTsAttrId) {
    mainOutput["updatedAt"] = upadteTsAttrId;
  }
  var selectQuery = dataRunner.prepareSelect(entityId, {output:mainOutput, outputConfig:{useNames:true}, filter:[{property:keyAttrId, valueInput:"key"}]});
  
  /* Prepare a query for selecting the keys of main instance with create timestamp */
  var selectCreatedQuery = createTsAttrId && dataRunner.prepareSelect(entityId, {output:{"key":keyAttrId, "serverKey":serverKeyAttrId}, outputConfig:{useNames:true}, filter:[{property:createTsAttrId, operator:"!n"}]});
  
  /* Prepare a query for selecting the keys of main instance with update timestamp */
  var selectUpdatedQuery = upadteTsAttrId && dataRunner.prepareSelect(entityId, {output:{"key":keyAttrId, "serverKey":serverKeyAttrId}, outputConfig:{useNames:true}, filter:[{property:upadteTsAttrId, operator:"!n"}]});
  
  /* Prepare a query for updating the main instance row with create/update timestamps */
  var updateQuery = dataRunner.prepareUpdate(entityId, {update:function(parameters) {
    var updates = {};
    
    /* Create timestamp */
    if (createTsAttrId && parameters["createdAt"] !== undefined) {
      updates[createTsAttrId] = parameters["createdAt"] || null;
    }
    
    /* Update timestamp */
    if (upadteTsAttrId && parameters["updatedAt"] !== undefined) {
      updates[upadteTsAttrId] = parameters["updatedAt"] || null;
    }
    
    return updates;
  }, filter:[{property:keyAttrId, valueInput:"key"}]});
  
  return {selectQuery:selectQuery, selectCreatedQuery:selectCreatedQuery, selectUpdatedQuery:selectUpdatedQuery, updateQuery:updateQuery};
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {?{selectUpdatedQuery:!wrm.data.SelectQuery, selectDeleteQuery:?wrm.data.SelectQuery, insertQuery:!wrm.data.InsertQuery,
 *         updateQuery:!wrm.data.UpdateQuery}}
 */
wrm.data.sync.EntityTracksPersister.prototype._createAuxiliaryQueries = function(entity, dataRunner) {
  var auxEntity = entity.getAuxiliaryEntity();
  if (!auxEntity) {
    return null;
  }
  
  var keyAuxAttr = entity.getKeyAttribute().getTrackerAuxiliaryAttribute();
  var serverKeyAuxAttr = entity.getServerKeyAttribute().getTrackerAuxiliaryAttribute();
  var flagAttr = entity.getDirtyAuxiliaryAttribute();
  var deleteTsAuxAttr = entity.getDeleteTimestampAuxiliaryAttribute();
  if (!flagAttr) {
    return null;
  }
  
  var auxEntityId = auxEntity.getId();
  var keyAuxAttrId = keyAuxAttr.getId();
  var serverKeyAuxAttrId = serverKeyAuxAttr.getId();
  var flagAttrId = flagAttr.getId();
  var deleteTsAttrId = deleteTsAuxAttr && deleteTsAuxAttr.getId();
  
  /* Prepare helper maps for accepting/returning dirty attribute flags */
  var dirtyFlagsNulled = {}, dirtyFlagsIds = {}, dirtyFlagsOutputMap = {};
  entity.getAttributes().forEach(function(attr) {
    var dirtyAuxAttr = attr.getDirtyAuxiliaryAttribute();
    if (dirtyAuxAttr) {
      dirtyFlagsNulled[dirtyAuxAttr.getId()] = null;
      dirtyFlagsIds["dirty_" + attr.getId()] = dirtyAuxAttr.getId();
      dirtyFlagsOutputMap["dirty_" + attr.getId()] = dirtyAuxAttr.getId();
    }
  });
  
  /* Function for preparing the updates to do (also for inserts) */
  var createUpdates = function(parameters) {
    var updates = {};
    updates[flagAttrId] = true;
    
    /* Delete timestamp */
    if (deleteTsAttrId && parameters["deletedAt"] !== undefined) {
      updates[deleteTsAttrId] = parameters["deletedAt"];
    }
    
    /* Dirty attribute flags */
    if (!parameters["dirtyAttrsMerge"]) {
      angular.extend(updates, dirtyFlagsNulled);
    }
    Object.keys(parameters).forEach(function(paramName) {
      var dirtyAttrId = dirtyFlagsIds[paramName];
      if (dirtyAttrId) {
        updates[dirtyAttrId] = !!parameters[paramName];
      }
    });
    
    return updates;
  };
  
  /* Prepare filtering options for searching for an exact row for sharing */
  var locateFilteringOptions = {filter:[{property:flagAttrId, value:true}]};
  
  /* From this point onwards, actual QUERIES are constructed */
  
  /* Prepare a query for selecting auxiliary rows by the key of an updated main row */
  var selectUpdatedQuery = dataRunner.prepareSelect(auxEntityId, angular.extend({}, locateFilteringOptions, {output:angular.extend({"key":keyAuxAttrId, "serverKey":serverKeyAuxAttrId}, dirtyFlagsOutputMap), outputConfig:{useNames:true}, filter:[{property:keyAuxAttrId, valueInput:"key"}, {property:flagAttrId, value:true}]}));
  
  /* Prepare a query for selecting the server keys of auxiliary rows with delete timestamp */
  var selectDeleteQuery = deleteTsAttrId && dataRunner.prepareSelect(auxEntityId, angular.extend({}, locateFilteringOptions, {output:{"key":keyAuxAttrId, "serverKey":serverKeyAuxAttrId}, outputConfig:{useNames:true}, filter:[{property:deleteTsAttrId, operator:"!n"}, {property:flagAttrId, value:true}]}));
  
  /* Prepare a query for inserting a new auxiliary row and updating it with delete timestamp and dirty attributes */
  var insertQuery = dataRunner.prepareInsert(auxEntityId, function(parameters) {
    var inserts = createUpdates(parameters);
    inserts[keyAuxAttrId] = parameters["key"];
    inserts[serverKeyAuxAttrId] = parameters["serverKey"];
    return inserts;
  });
  
  /* Prepare a query for updating an auxiliary row with delete timestamp and dirty attributes */
  var updateQuery = dataRunner.prepareUpdate(auxEntityId, angular.extend({}, locateFilteringOptions, {update:function(parameters) {
    return createUpdates(parameters);
  }, filter:[{property:keyAuxAttrId, valueInput:"key"}, {property:flagAttrId, value:true}]}));
  
  return {selectUpdatedQuery:selectUpdatedQuery, selectDeleteQuery:selectDeleteQuery, insertQuery:insertQuery, updateQuery:updateQuery};
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.Purger} purger
 * @return {?string}
 */
wrm.data.sync.EntityTracksPersister.prototype._registerPurgeRule = function(entity, purger) {
  
  /* Compute information about the entity holding tuples */
  var auxEntity = entity.getAuxiliaryEntity();
  if (!auxEntity) {
    return null;
  }
  
  /*
   * Prepare filters for matching instances in the auxiliary entity that have the delete timestamp nulled out and all dirty
   * attributes flags nulled our
   */    /** @type {!Array.<wrm.data.Condition.Expression>} */
  var filters = [];
  var deleteTsAuxAttr = entity.getDeleteTimestampAuxiliaryAttribute();
  if (deleteTsAuxAttr) {
    filters.push({property:deleteTsAuxAttr.getId(), operator:"n"});
  }
  entity.getAttributes().forEach(function(attr) {
    var dirtyAuxAttr = attr.getDirtyAuxiliaryAttribute();
    if (dirtyAuxAttr) {
      filters.push({property:dirtyAuxAttr.getId(), operator:"!eq", value:true});
    }
  });
  
  return purger.registerRule(auxEntity, filters);
};

/*
 * Operations
 */

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:?*}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype.selectOneCreateTrack = function(dataContext) {
  var thisPersister = this;
  if (!this._selectOneCreatedMainRowPossible()) {
    return Promise.resolve(null);
  }
  
  /* Select one row with a create timestamp set */
  return thisPersister._selectOneCreatedMainRow(dataContext);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, attributes:!Array.<!wrm.data.meta.Attribute>}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype.selectOneUpdateTrack = function(dataContext) {
  var thisPersister = this;
  if (!this._selectOneUpdatedMainRowPossible() || !this._selectUpdatedAuxiliaryRowPossible()) {
    return Promise.resolve(null);
  }
  
  /* Select one row with an update timestamp set */
  return thisPersister._selectOneUpdatedMainRow(dataContext).then(function(foundKeys) {
    if (!foundKeys) {
      return null;
    }
    return thisPersister._selectUpdatedAuxiliaryRow(foundKeys.key, dataContext).then(function(foundInfo) {
      if (foundInfo) {
        return {key:foundInfo.key, serverKey:foundInfo.serverKey, attributes:foundInfo.dirtyAttrs};
      } else {
        return {key:foundKeys.key, serverKey:foundKeys.serverKey, attributes:[]};
      }
    });
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:*}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype.selectOneDeleteTrack = function(dataContext) {
  var thisPersister = this;
  if (!this._selectOneDeletedAuxiliaryRowPossible()) {
    return Promise.resolve(null);
  }
  
  /* Select one row with a delete timestamp set */
  return thisPersister._selectOneDeletedAuxiliaryRow(dataContext);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?*} serverKey
 * @param {!wrm.data.DateTime} createdAt
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype.addCreateTrack = function(dataContext, key, serverKey, createdAt) {
  var thisPersister = this;
  if (!this._updateMainRowPossible() && !this._createOrUpdateAuxiliaryRowPossible()) {
    return Promise.resolve();
  }
  
  /* Set create timestamp, clear everything else */
  return thisPersister._updateMainRow(key, {createdAt:createdAt, updatedAt:null}, dataContext).then(function(mainUpdated) {
    if (!mainUpdated) {
      return;
    }
    return thisPersister._createOrUpdateAuxiliaryRow(key, serverKey, {deletedAt:null, dirtyAttrs:[]}, dataContext);
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?*} serverKey
 * @param {!wrm.data.DateTime} updatedAt
 * @param {!Array.<!wrm.data.meta.Attribute>} updatedAttributes
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype.addUpdateTrack = function(dataContext, key, serverKey, updatedAt, updatedAttributes) {
  var thisPersister = this;
  if (!this._updateMainRowPossible() && !this._createOrUpdateAuxiliaryRowPossible()) {
    return Promise.resolve();
  }
  
  /*
   * Set update timestamp, merge dirty attributes, clear everything else; all this UNLESS there is already a create timestamp, since
   * an update track is logically merged with a create track
   */
  return thisPersister._selectMainRow(key, dataContext).then(function(mainRow) {
    if (mainRow && !!mainRow.createdAt) {
      return;
    }
    
    return thisPersister._updateMainRow(key, {createdAt:null, updatedAt:updatedAt}, dataContext).then(function(mainUpdated) {
      if (!mainUpdated) {
        return;
      }
      return thisPersister._createOrUpdateAuxiliaryRow(key, serverKey, {deletedAt:null, dirtyAttrs:updatedAttributes, dirtyAttrsMerge:true}, dataContext);
    });
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?*} serverKey
 * @param {!wrm.data.DateTime} deletedAt
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype.addDeleteTrack = function(dataContext, key, serverKey, deletedAt) {
  var thisPersister = this;
  if (!this._createOrUpdateAuxiliaryRowPossible()) {
    return Promise.resolve();
  }
  
  /* Set delete timestamp, clear dirty everything else */
  return thisPersister._createOrUpdateAuxiliaryRow(key, serverKey, {deletedAt:deletedAt, dirtyAttrs:[]}, dataContext);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype.removeCreateTracks = function(dataContext, key) {
  var thisPersister = this;
  if (!this._updateMainRowPossible()) {
    return Promise.resolve();
  }
  
  /* Clear create timestamp */
  return thisPersister._updateMainRow(key, {createdAt:null}, dataContext);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype.removeUpdateTracks = function(dataContext, key) {
  var thisPersister = this;
  if (!this._updateMainRowPossible() && !this._createOrUpdateAuxiliaryRowPossible()) {
    return Promise.resolve();
  }
  
  /* Clear update timestamp and dirty attributes */
  return thisPersister._updateMainRow(key, {updatedAt:null}, dataContext).then(function(mainUpdated) {
    if (!mainUpdated) {
      return;
    }
    return thisPersister._createOrUpdateAuxiliaryRow(key, null, {dirtyAttrs:[]}, dataContext);
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype.removeDeleteTracks = function(dataContext, key) {
  var thisPersister = this;
  if (!this._createOrUpdateAuxiliaryRowPossible()) {
    return Promise.resolve();
  }
  
  /* Clear delete timestamp */
  return thisPersister._createOrUpdateAuxiliaryRow(key, null, {deletedAt:null}, dataContext);
};

/*
 * Low-level query operations
 */

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectMainRowPossible = function() {
  return !!this._mainSelect;
};

/**
 * @private
 * @param {*} key
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:?*, createdAt:?wrm.data.DateTime, updatedAt:?wrm.data.DateTime}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectMainRow = function(key, dataContext) {
  var mainSelect = this._mainSelect;
  if (!mainSelect) {
    return Promise.resolve(null);
  }
  
  /* Select the main row */
  return mainSelect.queryOne(dataContext, {"key":key}).then(function(foundRow) {
    if (foundRow) {
      return {key:foundRow["key"], serverKey:foundRow["serverKey"], createdAt:foundRow["createdAt"] || null, updatedAt:foundRow["updatedAt"] || null};
    }
    return null;
  });
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectOneCreatedMainRowPossible = function() {
  return !!this._mainSelectCreated;
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:?*}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectOneCreatedMainRow = function(dataContext) {
  var mainSelect = this._mainSelectCreated;
  if (!mainSelect) {
    return Promise.resolve(null);
  }
  
  /* Select the keys of the first main row with a create track */
  return mainSelect.queryOne(dataContext).then(function(foundKeys) {
    if (foundKeys) {
      return {key:foundKeys["key"], serverKey:foundKeys["serverKey"]};
    }
    return null;
  });
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectOneUpdatedMainRowPossible = function() {
  return !!this._mainSelectUpdated;
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:?*}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectOneUpdatedMainRow = function(dataContext) {
  var mainSelect = this._mainSelectUpdated;
  if (!mainSelect) {
    return Promise.resolve(null);
  }
  
  /* Select the keys of the first main row with an update track */
  return mainSelect.queryOne(dataContext).then(function(foundKeys) {
    if (!foundKeys) {
      return null;
    }
    return {key:foundKeys["key"], serverKey:foundKeys["serverKey"]};
  });
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._updateMainRowPossible = function() {
  return !!this._mainUpdate;
};

/**
 * @private
 * @param {*} key
 * @param {{createdAt:(?wrm.data.DateTime|undefined), updatedAt:(?wrm.data.DateTime|undefined)}} changes
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<boolean>}
 */
wrm.data.sync.EntityTracksPersister.prototype._updateMainRow = function(key, changes, dataContext) {
  var mainUpdate = this._mainUpdate;
  
  /* Exit if there are not queries (i.e., nothing to do because not tracking) */
  if (!mainUpdate) {
    return Promise.resolve(true);
  }
  
  /* Update the main row */
  return mainUpdate.execute(dataContext, {"key":key, "createdAt":changes.createdAt, "updatedAt":changes.updatedAt}).then(function(updatedKeys) {
    return updatedKeys.length > 0;
  });
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectUpdatedAuxiliaryRowPossible = function() {
  return !!this._auxSelectUpdate;
};

/**
 * @private
 * @param {*} key
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:?*, dirtyAttrs:!Array.<!wrm.data.meta.Attribute>}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectUpdatedAuxiliaryRow = function(key, dataContext) {
  var entity = this._entity;
  var auxSelect = this._auxSelectUpdate;
  if (!auxSelect) {
    return Promise.resolve(null);
  }
  
  /* Select keys and dirty attribute flags from the first auxiliary row with an update track */
  return auxSelect.queryOne(dataContext, {"key":key}).then(function(foundInfo) {
    if (!foundInfo) {
      return null;
    }
    
    var dirtyAttrs = [];
    entity.getAttributes().forEach(function(attr) {
      if (foundInfo["dirty_" + attr.getId()]) {
        dirtyAttrs.push(attr);
      }
    });
    
    return {key:foundInfo["key"], serverKey:foundInfo["serverKey"], dirtyAttrs:dirtyAttrs};
  });
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectOneDeletedAuxiliaryRowPossible = function() {
  return !!this._auxSelectDelete;
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<{key:*, serverKey:?*}>|!Promise.<null>}
 */
wrm.data.sync.EntityTracksPersister.prototype._selectOneDeletedAuxiliaryRow = function(dataContext) {
  var auxSelect = this._auxSelectDelete;
  if (!auxSelect) {
    return Promise.resolve(null);
  }
  
  /* Select keys from the first auxiliary row with a delete track */
  return auxSelect.queryOne(dataContext).then(function(foundKeys) {
    if (!foundKeys) {
      return null;
    }
    return {key:foundKeys["key"], serverKey:foundKeys["serverKey"]};
  });
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.EntityTracksPersister.prototype._createOrUpdateAuxiliaryRowPossible = function() {
  return !!this._auxInsert || !!this._auxUpdate;
};

/**
 * @private
 * @param {?*} key
 * @param {?*} serverKey
 * @param {{deletedAt:(?wrm.data.DateTime|undefined), dirtyAttrs:(!Array.<!wrm.data.meta.Attribute>|undefined),
 *            dirtyAttrsMerge:(boolean|undefined)}} changes
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.sync.EntityTracksPersister.prototype._createOrUpdateAuxiliaryRow = function(key, serverKey, changes, dataContext) {
  var auxInsert = this._auxInsert;
  var auxUpdate = this._auxUpdate;
  
  /* Exit if there are not queries (i.e., nothing to do because not tracking) */
  if (!auxInsert && !auxUpdate) {
    return Promise.resolve();
  }
  
  this._requirePurging();
  
  var promise = Promise.resolve();
  
  /* Prepare the common query parameters */
  var parameters = {"key":key, "serverKey":serverKey, "deletedAt":changes.deletedAt};
  if (changes.dirtyAttrs) {
    changes.dirtyAttrs.forEach(function(attr) {
      parameters["dirty_" + attr.getId()] = true;
    });
  }
  
  /* Update by UPDATING an existing auxiliary row */
  if (auxUpdate) {
    promise = promise.then(function() {
      return auxUpdate.execute(dataContext, angular.extend({}, parameters, {"dirtyAttrsMerge":changes.dirtyAttrsMerge}));
    }).then(function(updatedKeys) {
      return updatedKeys.length > 0;
    });
  }
  
  /* If setting something and the update did not find rows, retry by CREATING a new auxiliary row */
  if (auxInsert && (!!changes.deletedAt || !!changes.dirtyAttrs && changes.dirtyAttrs.length > 0)) {
    promise = promise.then(function(auxUpdated) {
      if (auxUpdated) {
        return;
      }
      return auxInsert.execute(dataContext, parameters);
    });
  }
  
  return promise;
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.sync.EntityTracksPersister.prototype._requirePurging = function() {
  if (this._purgeRuleId) {
    this._purger.touch(this._purgeRuleId);
  }
};




//== wrm/data/sync/EntityTracker.js ===========================================



/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.EntityTracker = function(entity, purger, dataRunner) {
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._persister = new wrm.data.sync.EntityTracksPersister(entity, purger, dataRunner);
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @return {boolean}
 */
wrm.data.sync.EntityTracker.isRelevantEntity = function(entity) {
  if (!(entity instanceof wrm.data.meta.RegularEntity)) {
    return false;
  }
  var createTsAttr = entity.getCreateTimestampAttribute();
  var updateTsAttr = entity.getUpdateTimestampAttribute();
  var deleteTsAuxAttr = entity.getDeleteTimestampAuxiliaryAttribute();
  return !!createTsAttr || !!updateTsAttr || !!deleteTsAuxAttr;
};

/*
 * Change tracking
 */

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?*} serverKey
 * @return {!Promise}
 */
wrm.data.sync.EntityTracker.prototype.trackClientCreate = function(dataContext, key, serverKey) {
  return this._persister.addCreateTrack(dataContext, key, serverKey, wrm.data.DateTime.now());
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?*} serverKey
 * @param {!Array.<!wrm.data.meta.Attribute>} updatedAttributes
 * @return {!Promise}
 */
wrm.data.sync.EntityTracker.prototype.trackClientUpdate = function(dataContext, key, serverKey, updatedAttributes) {
  return this._persister.addUpdateTrack(dataContext, key, serverKey, wrm.data.DateTime.now(), updatedAttributes);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?*} serverKey
 * @return {!Promise}
 */
wrm.data.sync.EntityTracker.prototype.trackClientDelete = function(dataContext, key, serverKey) {
  return this._persister.addDeleteTrack(dataContext, key, serverKey, wrm.data.DateTime.now());
};

/*
 * Change collection and settlement
 */

/**
 * @package
 * @typedef {{key:*, serverKey:?*, attributeValues:?Object.<string,*>}}
 */
wrm.data.sync.EntityTracker.Change;

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<wrm.data.sync.EntityTracker.Change>|!Promise.<null>}
 */
wrm.data.sync.EntityTracker.prototype.collectNextCreate = function(dataContext) {
  var thisTracker = this;
  var persister = this._persister;
  
  /* Function for selecting the next change caused by a create track associated with an EXISTING object */
  function attempt() {
    return persister.selectOneCreateTrack(dataContext).then(function(createTrack) {
      if (!createTrack) {
        return null;
      }
      
      return thisTracker._fetchAttributeValues(dataContext, createTrack.key).then(function(attributeValues) {
        var change = ({key:createTrack.key, serverKey:createTrack.serverKey, attributeValues:attributeValues});
        
        if (attributeValues) {
          return change;
        }
        
        /* Invalid create track: settle and go on */
        return thisTracker.settleCreate(dataContext, change).then(function() {
          return attempt();
        });
      });
    });
  }
  
  return attempt();
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.EntityTracker.Change} change
 * @return {!Promise}
 */
wrm.data.sync.EntityTracker.prototype.settleCreate = function(dataContext, change) {
  return this._persister.removeCreateTracks(dataContext, change.key);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<wrm.data.sync.EntityTracker.Change>|!Promise.<null>}
 */
wrm.data.sync.EntityTracker.prototype.collectNextUpdate = function(dataContext) {
  var thisTracker = this;
  var persister = this._persister;
  
  /* Function for selecting the next change caused by an update track associated with an EXISTING object */
  function attempt() {
    return persister.selectOneUpdateTrack(dataContext).then(function(updateTrack) {
      if (!updateTrack) {
        return null;
      }
      
      return thisTracker._fetchAttributeValues(dataContext, updateTrack.key, updateTrack.attributes).then(function(attributeValues) {
        var change = ({key:updateTrack.key, serverKey:updateTrack.serverKey, attributeValues:attributeValues});
        
        if (attributeValues) {
          return change;
        }
        
        /* Invalid update track: settle and go on */
        return thisTracker.settleUpdate(dataContext, change).then(function() {
          return attempt();
        });
      });
    });
  }
  
  return attempt();
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.EntityTracker.Change} change
 * @return {!Promise}
 */
wrm.data.sync.EntityTracker.prototype.settleUpdate = function(dataContext, change) {
  return this._persister.removeUpdateTracks(dataContext, change.key);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<wrm.data.sync.EntityTracker.Change>|!Promise.<null>}
 */
wrm.data.sync.EntityTracker.prototype.collectNextDelete = function(dataContext) {
  
  /* Select the next change caused by a delete track */
  return this._persister.selectOneDeleteTrack(dataContext).then(function(deleteTrack) {
    if (!deleteTrack) {
      return null;
    }
    return ({key:deleteTrack.key, serverKey:deleteTrack.serverKey, serverRecord:null});
  });
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {wrm.data.sync.EntityTracker.Change} change
 * @return {!Promise}
 */
wrm.data.sync.EntityTracker.prototype.settleDelete = function(dataContext, change) {
  return this._persister.removeDeleteTracks(dataContext, change.key);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {*} key
 * @param {?Array.<!wrm.data.meta.Attribute>=} attributes
 * @return {!Promise.<?Object.<string,?>>}
 */
wrm.data.sync.EntityTracker.prototype._fetchAttributeValues = function(dataContext, key, attributes) {
  var entity = this._entity;
  
  /*
   * Prepare an output transformation object for mapping attribute values to their id. Include just the specified attributes or all
   * of them (if not specified)
   */
  var output = {};
  (attributes || entity.getAttributes()).forEach(function(attribute) {
    var attrId = attribute.getId();
    output[attrId] = attrId;
  });
  
  /* Select a transformed version of the object indicated by the key */
  return (dataContext.selectOne(entity.getId(), {output:output, outputConfig:{useNames:true}, filter:[{property:entity.getKeyAttribute().getId()}]}, [key]));
};




//== wrm/data/Query.js ========================================================


/**
 * @interface
 * @template B
 */
wrm.data.Query = function() {
};

/**
 * @return {B}
 */
wrm.data.Query.prototype.getBaseElement = function() {
};




//== wrm/data/DeleteQuery.js ==================================================



/**
 * @interface
 * @template B
 * @extends wrm.data.Query<B>
 */
wrm.data.DeleteQuery = function() {
};

/**
 * @typedef {{ filter:(!wrm.data.Condition.Expression|undefined) }}}
 */
wrm.data.DeleteQuery.Options;




//== wrm/data/SelectQuery.js ==================================================



/**
 * @interface
 * @template B
 * @extends wrm.data.Query<B>
 */
wrm.data.SelectQuery = function() {
};

/**
 * @typedef {{useNames:(boolean|undefined)}}
 */
wrm.data.SelectQuery.OutputConfig;

/**
 * @typedef {{distinct:(boolean|undefined), output:(!Object<string,string>|!Array<string>|string|undefined),
 *          outputConfig:(!wrm.data.SelectQuery.OutputConfig|undefined), filter:(!wrm.data.Condition.Expression|undefined),
 *          order:(!Array<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined),
 *          limit:({begin:number,count:number}|number|undefined) }}
 */
wrm.data.SelectQuery.Options;




//== wrm/data/QueryFactory.js =================================================



/**
 * @interface
 */
wrm.data.QueryFactory = function() {
};

/**
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @return {!wrm.data.EntitySelectQuery}
 */
wrm.data.QueryFactory.prototype.prepareSelect = ABSTRACT_METHOD;
/**
 * @deprecated
 * @param {string} entityId
 * @param {{ output: (!Object.<string,string>|!Array.<string>|string|undefined), distinct: (boolean|undefined), include:
 *            (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined), order:
 *            (!Array.<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined), limit:
 *            ({begin:number,count:number}|number|undefined) }=} options
 * @return {!wrm.data.JSelectQuery}
 */
wrm.data.QueryFactory.prototype.prepareOldSelect = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {!Array.<(function(!Object):!Object)|!Object>|(function(!Object):!Object)|!Object} insert
 * @return {!wrm.data.InsertQuery}
 */
wrm.data.QueryFactory.prototype.prepareInsert = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array.<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 * @return {!wrm.data.UpdateQuery}
 */
wrm.data.QueryFactory.prototype.prepareUpdate = ABSTRACT_METHOD;

/**
 * @param {string} entityId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @return {!wrm.data.EntityDeleteQuery}
 */
wrm.data.QueryFactory.prototype.prepareDelete = ABSTRACT_METHOD;
/**
 * @deprecated
 * @param {string} entityId
 * @param {{ include: (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=}
 *            options
 * @return {!wrm.data.JDeleteQuery}
 */
wrm.data.QueryFactory.prototype.prepareOldDelete = ABSTRACT_METHOD;

/**
 * @deprecated Use wrm.data.Condition.Expression directly in the queries. If wanting to cache for performance, prepare the <i>entire
 *             query</i> and cache that.
 * @param {string} entityId
 * @param {!wrm.data.Condition.Expression=} expression
 * @return {!wrm.data.Condition}
 */
wrm.data.QueryFactory.prototype.prepareCondition = ABSTRACT_METHOD;




//== wrm/data/DataRunner.js ===================================================



/**
 * @interface
 * @extends wrm.data.QueryFactory
 */
wrm.data.DataRunner = function() {
};

/**
 * @template R
 * @param {function(!wrm.data.DataContext):(R|!Promise.<R>)} callback
 * @param {boolean=} inTransaction
 * @return {!Promise.<R>}
 */
wrm.data.DataRunner.prototype.execute = ABSTRACT_METHOD;




//== wrm/data/sync/UntrackedDataRunner.js =====================================



/**
 * @package
 * @constructor
 * @implements wrm.data.DataRunner
 * @param {!wrm.data.DataRunner} dataRunner
 */
wrm.data.sync.UntrackedDataRunner = function(dataRunner) {
  
  /** @private */
  this._dataRunner = dataRunner;
};

/** @override */
wrm.data.sync.UntrackedDataRunner.prototype.prepareSelect = function(entityId, options) {
  return this._dataRunner.prepareSelect(entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareOldSelect = function(entityId, options) {
  return this._dataRunner.prepareOldSelect(entityId, options);
};

/** @override */
wrm.data.sync.UntrackedDataRunner.prototype.prepareInsert = function(entityId, insert) {
  return this._dataRunner.prepareInsert(entityId, insert);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @return {!wrm.data.XEntityInsertQuery}
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareNewInsert = function(entityId, insert) {
  return this._dataRunner.prepareNewInsert(entityId, insert);
};

/** @override */
wrm.data.sync.UntrackedDataRunner.prototype.prepareUpdate = function(entityId, options) {
  return this._dataRunner.prepareUpdate(entityId, options);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @return {!wrm.data.XUpdateQuery}
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareNewUpdate = function(entityId, options) {
  return this._dataRunner.prepareNewUpdate(entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareOldDelete = function(entityId, options) {
  return this._dataRunner.prepareOldDelete(entityId, options);
};

/** @override */
wrm.data.sync.UntrackedDataRunner.prototype.prepareDelete = function(entityId, options) {
  return this._dataRunner.prepareDelete(entityId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @return {!wrm.data.XAssocSelectQuery}
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareNewAssociationSelect = function(assocId, options) {
  return this._dataRunner.prepareNewAssociationSelect(assocId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @return {!wrm.data.XAssocInsertQuery}
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareNewAssociationInsert = function(assocId, insert) {
  return this._dataRunner.prepareNewAssociationInsert(assocId, insert);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @return {!wrm.data.XAssocUpdateQuery}
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareNewAssociationUpdate = function(assocId, options) {
  return this._dataRunner.prepareNewAssociationUpdate(assocId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @return {!wrm.data.XAssocDeleteQuery}
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareNewAssociationDelete = function(assocId, options) {
  return this._dataRunner.prepareNewAssociationDelete(assocId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.sync.UntrackedDataRunner.prototype.prepareCondition = function(entityId, expression) {
  return this._dataRunner.prepareCondition(entityId, expression);
};

/** @override */
wrm.data.sync.UntrackedDataRunner.prototype.execute = function(callback, inTransaction) {
  return this._dataRunner.execute(function(dataContext) {
    dataContext.disableChangeTracking();
    return callback(dataContext);
  }, inTransaction);
};




//== wrm/data/sync/DataTrackerService.js ======================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.data.sync.DataTrackerService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /*
   * UNSTABLE STATE tied to the data service: each of the following state variables is (re-)initialized for each data service change
   */
  
  /**
   * @private
   * @type {!wrm.data.DataRunner}
   */
  this._dataRunner;
  
  /**
   * @private
   * @type {!Object.<string,?wrm.data.sync.EntityTracker>}
   */
  this._entityTrackers;
  
  /**
   * @private
   * @type {!Object.<string,?wrm.data.sync.AssociationTracker>}
   */
  this._assocTrackers;
  
  /**
   * @private
   * @type {!Object.<string,boolean>}
   */
  this._relevantEntities;
  
  /**
   * @private
   * @type {!wrm.data.Purger}
   */
  this._purger;
};

extendConstructor(wrm.data.sync.DataTrackerService, wrm.core.AbstractService);

/** @override */
wrm.data.sync.DataTrackerService.prototype.initialize = function(descr) {
  var manager = this.getManager();
  return manager.getDataService().then(function(dataService) {
    dataService.useUnstable(this._reinitFromDataService.bind(this));
  }.bind(this));
};

/**
 * @const
 * @type {string}
 */
wrm.data.sync.DataTrackerService.ID = "_datatrack";

/**
 * @private
 * @param {!wrm.data.DataService} dataService
 */
wrm.data.sync.DataTrackerService.prototype._reinitFromDataService = function(dataService) {
  this._dataRunner = new wrm.data.sync.UntrackedDataRunner(dataService);
  
  /* Create maps for storing trackers and a "set" to quickly filter relevant entities */
  var maps = wrm.data.sync.DataTrackerService._createMaps(dataService.getMetadata());
  this._entityTrackers = maps.entityTrackers;
  this._assocTrackers = maps.assocTrackers;
  this._relevantEntities = maps.relevantEntities;
  
  this._purger = dataService.getPurger();
};

/**
 * @private
 * @param {!wrm.data.meta.Metadata} metadata
 * @return {{entityTrackers:!Object.<string,?wrm.data.sync.EntityTracker>,
 *         assocTrackers:!Object.<string,?wrm.data.sync.AssociationTracker>, relevantEntities:!Object.<string,boolean>}}
 */
wrm.data.sync.DataTrackerService._createMaps = function(metadata) {
  var relevantEntities = {};
  
  /* Entity trackers */
  var entityTrackers = {};
  metadata.getEntities().forEach(function(entity) {
    if (wrm.data.sync.EntityTracker.isRelevantEntity(entity)) {
      entityTrackers[entity.getId()] = null;
      relevantEntities[entity.getId()] = true;
    }
  });
  
  /* Association trackers */
  var assocTrackers = {};
  metadata.getAssociations().forEach(function(assoc) {
    if (wrm.data.sync.AssociationTracker.isRelevantAssociation(assoc)) {
      assocTrackers[assoc.getId()] = null;
      relevantEntities[assoc.getEntity1().getId()] = true;
      relevantEntities[assoc.getEntity2().getId()] = true;
    }
  });
  
  return {entityTrackers:entityTrackers, assocTrackers:assocTrackers, relevantEntities:relevantEntities};
};

/*
 * Change tracking
 */

/**
 * @param {!wrm.data.meta.Entity} entity
 * @return {boolean}
 */
wrm.data.sync.DataTrackerService.prototype.isRelevantEntity = function(entity) {
  return this._relevantEntities.hasOwnProperty(entity.getId());
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype.trackEntityCreate = function(entity, key) {
  var thisService = this;
  var dataRunner = this._dataRunner;
  if (!this._isTrackableEntity(entity)) {
    return Promise.resolve();
  }
  
  /* Post to entity tracker after resolving server key */
  return dataRunner.execute(function(dataContext) {
    return wrm.data.sync.findServerKey(dataContext, entity, key).then(function(serverKey) {
      return thisService._doTrackEntityCreate(dataContext, entity, key, serverKey);
    });
  });
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {!Array.<!wrm.data.meta.Attribute>} updatedAttributes
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype.trackEntityUpdate = function(entity, key, updatedAttributes) {
  var thisService = this;
  var dataRunner = this._dataRunner;
  if (!this._isTrackableEntity(entity) || updatedAttributes.length <= 0) {
    return Promise.resolve();
  }
  
  /* Post to entity tracker after resolving server key */
  return dataRunner.execute(function(dataContext) {
    return wrm.data.sync.findServerKey(dataContext, entity, key).then(function(serverKey) {
      if (serverKey === null) {
        return;
      }
      return thisService._doTrackEntityUpdate(dataContext, entity, key, serverKey, updatedAttributes);
    });
  });
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {?*} serverKey
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype.trackEntityDelete = function(entity, key, serverKey) {
  var thisService = this;
  var dataRunner = this._dataRunner;
  if (!this._isTrackableEntity(entity) || serverKey === null) {
    return Promise.resolve();
  }
  
  /* Post to entity tracker */
  return dataRunner.execute(function(dataContext) {
    return thisService._doTrackEntityDelete(dataContext, entity, key, serverKey);
  });
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {?*} oldServerKey
 * @param {?*} newServerKey
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype.trackEntityServerKeyUpdate = function(entity, key, oldServerKey, newServerKey) {
  var thisService = this;
  var dataRunner = this._dataRunner;
  var log = this.getLog();
  if (!this.isRelevantEntity(entity) || oldServerKey === newServerKey) {
    return Promise.resolve();
  }
  if (log.isDebugEnabled()) {
    log.debug("Entity", entity, "changing server key of", "{key:" + key, ", serverKey: " + oldServerKey + "}", "to", newServerKey);
  }
  
  /*
   * Although the affected instance does not change its connections to the others, changing the server key may cause association
   * instances to be added/removed AS SEEN BY THE SERVER
   */
  return dataRunner.execute(function(dataContext) {
    return thisService._doTrackEntityServerKeyUpdate(dataContext, entity, key, oldServerKey, newServerKey);
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {?*} oldServerKey
 * @param {?*} newServerKey
 * @param {!Object.<string,boolean>=} excludedAssocs
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype._doTrackEntityServerKeyUpdate = function(dataContext, entity, key, oldServerKey, newServerKey, excludedAssocs) {
  var thisService = this;
  
  excludedAssocs = excludedAssocs || {};
  
  /* Process each association to which the instance participates and that is connected with server-mapped entity */
  return wrm.data.sync.DataTrackerService.retrieveTrackableAssociations(entity).reduce(function(chain, assoc) {
    if (excludedAssocs[assoc.getId()] === true) {
      return chain;
    }
    var inverted = entity === assoc.getEntity2();
    var role = inverted ? assoc.getRole2() : assoc.getRole1();
    
    /* Change the tuples (by a remove + add) for each far server key */
    return chain.then(function() {
      return wrm.data.sync.findFarServerKeys(dataContext, entity, key, role).then(function(farServerKeys) {
        if (inverted) {
          return farServerKeys.reduce(function(serverKeysChain, serverKey1) {
            return serverKeysChain.then(function() {
              return thisService._doTrackAssociationRemove(dataContext, assoc, serverKey1, oldServerKey);
            }).then(function() {
              return thisService._doTrackAssociationAdd(dataContext, assoc, serverKey1, newServerKey);
            });
          }, Promise.resolve());
        } else {
          return farServerKeys.reduce(function(serverKeysChain, serverKey2) {
            return serverKeysChain.then(function() {
              return thisService._doTrackAssociationRemove(dataContext, assoc, oldServerKey, serverKey2);
            }).then(function() {
              return thisService._doTrackAssociationAdd(dataContext, assoc, newServerKey, serverKey2);
            });
          }, Promise.resolve());
        }
      });
    });
  }, Promise.resolve());
};

/**
 * @param {!wrm.data.meta.Association} assoc
 * @param {*} key1
 * @param {*} key2
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype.trackAssociationAdd = function(assoc, key1, key2) {
  var thisService = this;
  var dataRunner = this._dataRunner;
  
  if (!this._isTrackableAssociation(assoc)) {
    return Promise.resolve();
  }
  
  /* Post to association tracker after resolving both server keys */
  return dataRunner.execute(function(dataContext) {
    return wrm.data.sync.findServerKey(dataContext, assoc.getEntity1(), key1).then(function(serverKey1) {
      return wrm.data.sync.findServerKey(dataContext, assoc.getEntity2(), key2).then(function(serverKey2) {
        if (serverKey1 === null || serverKey2 === null) {
          return;
        }
        return thisService._doTrackAssociationAdd(dataContext, assoc, serverKey1, serverKey2);
      });
    });
  });
};

/**
 * @param {!wrm.data.meta.Association} assoc
 * @param {*} key1
 * @param {*} key2
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype.trackAssociationRemove = function(assoc, key1, key2) {
  var thisService = this;
  var dataRunner = this._dataRunner;
  
  if (!this._isTrackableAssociation(assoc)) {
    return Promise.resolve();
  }
  
  /* Post to association tracker after resolving both server keys */
  return dataRunner.execute(function(dataContext) {
    return wrm.data.sync.findServerKey(dataContext, assoc.getEntity1(), key1).then(function(serverKey1) {
      return wrm.data.sync.findServerKey(dataContext, assoc.getEntity2(), key2).then(function(serverKey2) {
        if (serverKey1 === null || serverKey2 === null) {
          return;
        }
        return thisService._doTrackAssociationRemove(dataContext, assoc, serverKey1, serverKey2);
      });
    });
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Array<!wrm.data.meta.Association>}
 */
wrm.data.sync.DataTrackerService.retrieveTrackableAssociations = function(entity) {
  var associations = [];
  entity.getAssociations().forEach(function(assoc) {
    if (assoc.getServerName()) {
      associations.push(assoc);
    }
  });
  return associations;
};

/*
 * Change collection and settlement
 */

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @return {{next:function():(!Promise.<?wrm.data.sync.DataTrackerService.Change>)}}
 */
wrm.data.sync.DataTrackerService.prototype.createChangeCollector = function(dataContext, entity) {
  return new wrm.data.sync.DataTrackerService._ChangeCollector(this, dataContext, entity);
};

/**
 * @private
 * @constructor
 * @param {!wrm.data.sync.DataTrackerService} parent
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 */
wrm.data.sync.DataTrackerService._ChangeCollector = function(parent, dataContext, entity) {
  
  /** @private */
  this._parent = parent;
  
  /** @private */
  this._dataContext = dataContext;
  
  /** @private */
  this._entity = entity;
  
  /**
   * @private
   * @type {{entity:!wrm.data.meta.Entity, tracker:!wrm.data.sync.EntityTracker, expendedForDeletes:boolean,
   *       expendedForCreates:boolean,expendedForUpdates:boolean}}
   */
  this._entityState = {entity:entity, tracker:parent._getEntityTracker(entity), expendedForDeletes:false, expendedForCreates:false, expendedForUpdates:false};
  
  /**
   * @private
   * @type {!Array.<{assoc:!wrm.data.meta.Association, tracker:!wrm.data.sync.AssociationTracker}>}
   */
  this._assocStates = [];
  
  /* Add a tracker for each association to which the entity participates and that is connected with server-mapped entity */
  wrm.data.sync.DataTrackerService.retrieveTrackableAssociations(entity).forEach(function(assoc) {
    this._assocStates.push({assoc:assoc, tracker:parent._getAssociationTracker(assoc)});
  }, this);
  
  /**
   * @private
   * @type {?Array.<!wrm.data.sync.EntityTracker.Change>}
   */
  this._assocOnlyEntityChanges = null;
  
  /**
   * @private
   * @type {?wrm.data.sync.DataTrackerService.Change|undefined}
   */
  this._currentChange = undefined;
  
  /** @private */
  this._finished = false;
};

/**
 * @return {!Promise.<?wrm.data.sync.DataTrackerService.Change>}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype.next = function() {
  var thisCollector = this;
  
  if (this._finished) {
    throw new Error("No more changes available");
  }
  
  /* Settle the current change */
  var promise = Promise.resolve().then(function() {
    return thisCollector._settleCurrentChange();
  });
  
  /* Get another change */
  promise = promise.then(function() {
    return thisCollector._collectNextChange();
  }).then(function(nextChange) {
    thisCollector._currentChange = nextChange;
    if (!nextChange) {
      thisCollector._finished = true;
    }
    return nextChange;
  });
  
  return promise;
};

/**
 * @private
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._collectNextChange = function() {
  var Change = wrm.data.sync.DataTrackerService.Change;
  var Type = wrm.data.sync.DataTrackerService.Change.Type;
  var thisCollector = this;
  var entity = this._entity;
  var entityState = this._entityState;
  var dataContext = this._dataContext;
  
  var promise = Promise.resolve(null);
  
  /* Look for DELETE changes */
  if (!entityState.expendedForDeletes) {
    promise = promise.then(function() {
      return entityState.tracker.collectNextDelete(dataContext).then(function(deleteChange) {
        if (!deleteChange) {
          entityState.expendedForDeletes = true;
          return null;
        }
        return thisCollector._collectAttachedAssociationChanges(deleteChange).then(function(assocChanges) {
          return new Change(entity, Type.DELETE, deleteChange, assocChanges);
        });
      });
    });
  }
  
  /* Look for CREATE changes */
  if (!entityState.expendedForCreates) {
    promise = promise.then(function(foundChange) {
      if (foundChange) {
        return foundChange;
      }
      return entityState.tracker.collectNextCreate(dataContext).then(function(createChange) {
        if (!createChange) {
          entityState.expendedForCreates = true;
          return null;
        }
        thisCollector._filterUnmappedAttributes(createChange);
        return thisCollector._collectAttachedAssociationChanges(createChange, true).then(function(assocChanges) {
          return new Change(entity, Type.CREATE, createChange, assocChanges);
        });
      });
    });
  }
  
  /* Look for UPDATE changes */
  if (!entityState.expendedForUpdates) {
    promise = promise.then(function(foundChange) {
      if (foundChange) {
        return foundChange;
      }
      return entityState.tracker.collectNextUpdate(dataContext).then(function(updateChange) {
        if (!updateChange) {
          entityState.expendedForUpdates = true;
          return null;
        }
        thisCollector._filterUnmappedAttributes(updateChange);
        return thisCollector._collectAttachedAssociationChanges(updateChange).then(function(assocChanges) {
          return new Change(entity, Type.UPDATE, updateChange, assocChanges);
        });
      });
    });
  }
  
  /* Look for ASSOCIATION UPDATE changes */
  promise = promise.then(function(foundChange) {
    if (foundChange) {
      return foundChange;
    }
    return thisCollector._getAssocOnlyEntityChanges().then(function(assocUpdateChanges) {
      if (assocUpdateChanges.length <= 0) {
        return null;
      }
      var assocUpdateChange = assocUpdateChanges.shift();
      return thisCollector._collectAttachedAssociationChanges(assocUpdateChange).then(function(assocChanges) {
        return new Change(entity, Type.UPDATE, assocUpdateChange, assocChanges);
      });
    });
  });
  
  return promise;
};

/**
 * @private
 * @param {!wrm.data.sync.EntityTracker.Change} entityChange
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._filterUnmappedAttributes = function(entityChange) {
  var entity = this._entity;
  var attributeValues = entityChange.attributeValues;
  if (!attributeValues) {
    return;
  }
  
  entity.getAttributes().forEach(function(attr) {
    if (!attr.getServerName()) {
      delete attributeValues[attr.getId()];
    }
  });
};

/**
 * @private
 * @param {!wrm.data.sync.EntityTracker.Change} entityChange
 * @param {boolean=} includeCurrentAsAdditions
 * @return {!Promise.<!Object.<string,{additions:!Array.<!wrm.data.sync.AssociationTracker.Change>,
 *         removals:!Array.<!wrm.data.sync.AssociationTracker.Change>}>>}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._collectAttachedAssociationChanges = function(entityChange, includeCurrentAsAdditions) {
  var thisCollector = this;
  var entity = this._entity;
  var assocStates = this._assocStates;
  var dataContext = this._dataContext;
  
  includeCurrentAsAdditions = includeCurrentAsAdditions || false;
  
  var key = entityChange.key;
  var serverKey = entityChange.serverKey;
  if (serverKey === null && !includeCurrentAsAdditions) {
    return (Promise.resolve({}));
  }
  
  var result = {};
  
  /* Include changes for each association */
  var promise = assocStates.reduce(function(chain, assocState) {
    var assoc = assocState.assoc;
    var assocId = assoc.getId();
    var inverted = assoc.getEntity2() === entity;
    var nearRole = inverted ? assoc.getRole2() : assoc.getRole1();
    
    /* Exclude association whose role is not mapped on the entity */
    if (!nearRole.getServerName()) {
      return chain;
    }
    
    var foundAdditions = [];
    var foundRemovals = [];
    
    /* Find tracked changes (requires the near object to have a server key) */
    if (serverKey !== null) {
      chain = chain.then(function() {
        var serverKey1 = inverted ? null : serverKey;
        var serverKey2 = inverted ? serverKey : null;
        return assocState.tracker.collectAdditions(dataContext, serverKey1, serverKey2).then(function(additions) {
          return assocState.tracker.collectRemovals(dataContext, serverKey1, serverKey2).then(function(removals) {
            Array.prototype.push.apply(foundAdditions, additions);
            Array.prototype.push.apply(foundRemovals, removals);
          });
        });
      });
    }
    
    /* Include current connections into additions, if asked to */
    if (includeCurrentAsAdditions) {
      chain = chain.then(function() {
        return thisCollector._mergeCurrentAssociations(foundAdditions, assoc, entity, key, serverKey);
      });
    }
    
    return chain.then(function() {
      if (foundAdditions.length > 0 || foundRemovals.length > 0) {
        result[assocId] = {additions:foundAdditions, removals:foundRemovals};
      }
    });
  }, Promise.resolve());
  
  return promise.then(function() {
    return result;
  });
};

/**
 * @private
 * @param {!Array.<!wrm.data.sync.AssociationTracker.Change>} additions
 * @param {!wrm.data.meta.Association} assoc
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {*} serverKey
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._mergeCurrentAssociations = function(additions, assoc, entity, key, serverKey) {
  var addedPairs = {};
  var dataContext = this._dataContext;
  
  /* Consider all previous addition pairs of server keys as added */
  additions.forEach(function(addition) {
    var pair = String(addition.serverKey1) + "###" + String(addition.serverKey2);
    addedPairs[pair] = true;
  });
  
  /* Find far server keys and the resulting association tuples */
  var inverted = assoc.getEntity2() === entity;
  var nearRole = inverted ? assoc.getRole2() : assoc.getRole1();
  return wrm.data.sync.findFarServerKeys(dataContext, entity, key, nearRole).then(function(farServerKeys) {
    farServerKeys.forEach(function(farServerKey) {
      var serverKey1 = inverted ? farServerKey : serverKey;
      var serverKey2 = inverted ? serverKey : farServerKey;
      
      /* Merge into the additions list */
      var pair = String(serverKey1) + "###" + String(serverKey2);
      if (addedPairs[pair] !== true) {
        addedPairs[pair] = true;
        additions.push({serverKey1:serverKey1, serverKey2:serverKey2});
      }
    });
  });
};

/**
 * @private
 * @return {!Promise.<!Array.<!wrm.data.sync.EntityTracker.Change>>}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._getAssocOnlyEntityChanges = function() {
  var thisCollector = this;
  var entity = this._entity;
  var assocStates = this._assocStates;
  var dataContext = this._dataContext;
  
  if (this._assocOnlyEntityChanges) {
    return Promise.resolve(this._assocOnlyEntityChanges);
  }
  
  var serverKeys = {};
  
  /* Look for remaining changes on all associations */
  var promise = assocStates.reduce(function(chain, assocState) {
    var assoc = assocState.assoc;
    var inverted = assoc.getEntity2() === entity;
    var tracker = assocState.tracker;
    
    /* Retrieve all changed tuples and collect server keys on the near side */
    return chain.then(function() {
      return tracker.collectAdditions(dataContext, null, null);
    }).then(function(additions) {
      additions.forEach(function(addition) {
        var serverKey = inverted ? addition.serverKey2 : addition.serverKey1;
        serverKeys[String(serverKey)] = serverKey;
      });
      
      return tracker.collectRemovals(dataContext, null, null);
    }).then(function(removals) {
      removals.forEach(function(removal) {
        var serverKey = inverted ? removal.serverKey2 : removal.serverKey1;
        serverKeys[String(serverKey)] = serverKey;
      });
    });
  }, Promise.resolve());
  
  /* Turn each server key into a "fake" entity change */
  promise = promise.then(function() {
    var entityChanges = [];
    
    return Object.keys(serverKeys).reduce(function(chain, mapKey) {
      var serverKey = serverKeys[mapKey];
      return chain.then(function() {
        return wrm.data.sync.findKey(dataContext, entity, serverKey);
      }).then(function(key) {
        if (key !== null) {
          entityChanges.push({key:key, serverKey:serverKey, attributeValues:{}});
        }
      });
    }, Promise.resolve()).then(function() {
      return entityChanges;
    });
  });
  
  /* Cache */
  return promise.then(function(entityChanges) {
    thisCollector._assocOnlyEntityChanges = entityChanges;
    return entityChanges;
  });
};

/**
 * @private
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._settleCurrentChange = function() {
  var Type = wrm.data.sync.DataTrackerService.Change.Type;
  var thisCollector = this;
  var entityState = this._entityState;
  var assocStates = this._assocStates;
  var dataContext = this._dataContext;
  var change = this._currentChange;
  if (!change) {
    return Promise.resolve();
  }
  
  var promise = Promise.resolve();
  
  /* Settle entity change (CUD depending on type) */
  switch(change.getType()) {
    case Type.CREATE:
      promise = promise.then(function() {
        return entityState.tracker.settleCreate(dataContext, change._entityChange);
      });
      break;
    case Type.UPDATE:
      promise = promise.then(function() {
        return entityState.tracker.settleUpdate(dataContext, change._entityChange);
      });
      break;
    case Type.DELETE:
      promise = promise.then(function() {
        return entityState.tracker.settleDelete(dataContext, change._entityChange);
      });
      break;
  }
  
  /* Settle association changes */
  assocStates.forEach(function(assocState) {
    var assocId = assocState.assoc.getId();
    var changes = change._assocChanges[assocId];
    
    /* Settle additions */
    var additions = changes && changes.additions;
    if (additions && additions.length > 0) {
      additions.forEach(function(additionChange) {
        promise = promise.then(function() {
          assocState.tracker.settleAddition(dataContext, additionChange);
        });
      });
    }
    
    /* Settle removals */
    var removals = changes && changes.removals;
    if (removals && removals.length > 0) {
      removals.forEach(function(removalChange) {
        promise = promise.then(function() {
          assocState.tracker.settleRemoval(dataContext, removalChange);
        });
      });
    }
  });
  
  /* Adjust tracking after settlement of creates */
  if (change.getType() === Type.CREATE) {
    promise = promise.then(function() {
      return thisCollector._retrackAfterCreateSettlement((change));
    });
  }
  
  return promise;
};

/**
 * @private
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService._ChangeCollector.prototype._retrackAfterCreateSettlement = function(change) {
  var parent = this._parent;
  var dataContext = this._dataContext;
  
  var entity = change._entity;
  var key = change._entityChange.key;
  
  /* Find the (new) server key of the created object */
  return Promise.resolve().then(function() {
    return wrm.data.sync.findServerKey(dataContext, entity, key);
  }).then(function(serverKey) {
    if (serverKey === null) {
      return;
    }
    
    /* Build a set-map of the settled associations */
    var settledAssocIds = {};
    Object.keys(change._assocChanges).forEach(function(assocId) {
      settledAssocIds[assocId] = true;
    });
    
    return parent._doTrackEntityServerKeyUpdate(dataContext, entity, key, null, serverKey, settledAssocIds);
  });
};

/*
 * Lower-level notifications to entity and association trackers
 */

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {?*} serverKey
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype._doTrackEntityCreate = function(dataContext, entity, key, serverKey) {
  this._logEntityTracking(entity, "created", key, serverKey);
  return this._getEntityTracker(entity).trackClientCreate(dataContext, key, serverKey);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {?*} serverKey
 * @param {!Array.<!wrm.data.meta.Attribute>} updatedAttributes
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype._doTrackEntityUpdate = function(dataContext, entity, key, serverKey, updatedAttributes) {
  this._logEntityTracking(entity, "updated", key, serverKey, updatedAttributes);
  return this._getEntityTracker(entity).trackClientUpdate(dataContext, key, serverKey, updatedAttributes);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {?*} serverKey
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype._doTrackEntityDelete = function(dataContext, entity, key, serverKey) {
  this._logEntityTracking(entity, "deleted", key, serverKey);
  return this._getEntityTracker(entity).trackClientDelete(dataContext, key, serverKey);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Association} assoc
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype._doTrackAssociationAdd = function(dataContext, assoc, serverKey1, serverKey2) {
  this._logAssociationTracking(assoc, "added", serverKey1, serverKey2);
  return this._getAssociationTracker(assoc).trackClientAdd(dataContext, serverKey1, serverKey2);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Association} assoc
 * @param {*} serverKey1
 * @param {*} serverKey2
 * @return {!Promise}
 */
wrm.data.sync.DataTrackerService.prototype._doTrackAssociationRemove = function(dataContext, assoc, serverKey1, serverKey2) {
  this._logAssociationTracking(assoc, "removed", serverKey1, serverKey2);
  return this._getAssociationTracker(assoc).trackClientRemove(dataContext, serverKey1, serverKey2);
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {!wrm.data.sync.EntityTracker}
 */
wrm.data.sync.DataTrackerService.prototype._getEntityTracker = function(entity) {
  var tracker = this._entityTrackers[entity.getId()];
  if (!tracker) {
    tracker = new wrm.data.sync.EntityTracker(entity, this._purger, this._dataRunner);
    this._entityTrackers[entity.getId()] = tracker;
  }
  return tracker;
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @return {!wrm.data.sync.AssociationTracker}
 */
wrm.data.sync.DataTrackerService.prototype._getAssociationTracker = function(assoc) {
  if (DEBUG) {
    if (!assoc.getServerName()) {
      throw Error("Association " + assoc.getName() + " is connected to a non-synchronized class and can not be tracked.");
    }
  }
  var tracker = this._assocTrackers[assoc.getId()];
  if (!tracker) {
    tracker = new wrm.data.sync.AssociationTracker(assoc, this._purger, this._dataRunner);
    this._assocTrackers[assoc.getId()] = tracker;
  }
  return tracker;
};

/*
 * Utilities
 */

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {boolean}
 */
wrm.data.sync.DataTrackerService.prototype._isTrackableEntity = function(entity) {
  return this._entityTrackers.hasOwnProperty(entity.getId());
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @return {boolean}
 */
wrm.data.sync.DataTrackerService.prototype._isTrackableAssociation = function(assoc) {
  return this._assocTrackers.hasOwnProperty(assoc.getId());
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {string} verbLabel
 * @param {*} key
 * @param {?*} serverKey
 * @param {!Array<!wrm.data.meta.Attribute>=} updatedAttributes
 */
wrm.data.sync.DataTrackerService.prototype._logEntityTracking = function(entity, verbLabel, key, serverKey, updatedAttributes) {
  var log = this.getLog();
  if (!log.isDebugEnabled()) {
    return;
  }
  
  /* Build a string representation of the tracked entity instance */
  var instanceLabel = function() {
    var s = [];
    s.push("{key: ");
    s.push(String(key));
    s.push(", serverKey: ");
    s.push(String(serverKey));
    if (updatedAttributes !== undefined) {
      s.push(", updatedAttributes: [");
      s.push(updatedAttributes.map(function(attr) {
        return String(attr);
      }).join(", "));
      s.push("]");
    }
    s.push("}");
    return s.join("");
  }();
  
  log.debug("Entity", entity, verbLabel, instanceLabel);
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {string} verbLabel
 * @param {*} serverKey1
 * @param {*} serverKey2
 */
wrm.data.sync.DataTrackerService.prototype._logAssociationTracking = function(assoc, verbLabel, serverKey1, serverKey2) {
  var log = this.getLog();
  if (!log.isDebugEnabled()) {
    return;
  }
  
  /* Build a string representation of the tracked association instance */
  var instanceLabel = function() {
    var s = [];
    s.push("{serverKeys: (");
    s.push(String(serverKey1));
    s.push(", ");
    s.push(String(serverKey2));
    s.push(")}");
    return s.join("");
  }();
  
  log.debug("Association", assoc, verbLabel, instanceLabel);
};

/*
 * Change class
 */

/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Entity} entity
 * @param {wrm.data.sync.DataTrackerService.Change.Type} type
 * @param {!wrm.data.sync.EntityTracker.Change} entityChange
 * @param {!Object.<string,{additions:!Array.<!wrm.data.sync.AssociationTracker.Change>,
 *            removals:!Array.<!wrm.data.sync.AssociationTracker.Change>}>=} assocChanges
 */
wrm.data.sync.DataTrackerService.Change = function(entity, type, entityChange, assocChanges) {
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._entityChange = entityChange;
  
  /** @private */
  this._type = type;
  
  /** @private */
  this._assocChanges = assocChanges || {};
  
  /* Build maps of changed keys by role */
  var maps = this._createRoleServerKeysMaps(this._entity, this._assocChanges);
  
  /** @private */
  this._roleAddedServerKeys = maps.additions;
  
  /** @private */
  this._roleRemovedServerKeys = maps.removals;
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object.<string,{additions:!Array.<!wrm.data.sync.AssociationTracker.Change>,
 *            removals:!Array.<!wrm.data.sync.AssociationTracker.Change>}>} assocChanges
 * @return {{additions:!Object.<string,!Array.<*>>, removals:!Object.<string,!Array.<*>>}}
 */
wrm.data.sync.DataTrackerService.Change.prototype._createRoleServerKeysMaps = function(entity, assocChanges) {
  var result = {additions:{}, removals:{}};
  
  /* Process each entity association */
  entity.getAssociations().forEach(function(assoc) {
    var inverted = entity === assoc.getEntity2();
    var nearRole = inverted ? assoc.getRole2() : assoc.getRole1();
    var changes = assocChanges[assoc.getId()];
    
    /* Add the ADDED far server keys for each added tuple */
    var additions = changes && changes.additions;
    if (additions && additions.length > 0) {
      var addedServerKeys = [];
      result.additions[nearRole.getId()] = addedServerKeys;
      additions.forEach(function(addition) {
        addedServerKeys.push(inverted ? addition.serverKey1 : addition.serverKey2);
      });
    }
    
    /* Add the REMOVED far server keys for each removed tuple */
    var removals = changes && changes.removals;
    if (removals && removals.length > 0) {
      var removedServerKeys = [];
      result.removals[nearRole.getId()] = removedServerKeys;
      removals.forEach(function(removal) {
        removedServerKeys.push(inverted ? removal.serverKey1 : removal.serverKey2);
      });
    }
  });
  
  return result;
};

/**
 * @package
 * @return {wrm.data.sync.DataTrackerService.Change.Type}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getType = function() {
  return this._type;
};

/**
 * @package
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getEntity = function() {
  return this._entity;
};

/**
 * @package
 * @return {*}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getKey = function() {
  return this._entityChange.key;
};

/**
 * @package
 * @return {?*}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getServerKey = function() {
  return this._entityChange.serverKey;
};

/**
 * @package
 * @return {?Object.<string,*>}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getAttributeValues = function() {
  return this._entityChange.attributeValues;
};

/**
 * @package
 * @return {!Object.<string,!Array.<*>>}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getRoleAddedServerKeys = function() {
  return this._roleAddedServerKeys;
};

/**
 * @package
 * @return {!Object.<string,!Array.<*>>}
 */
wrm.data.sync.DataTrackerService.Change.prototype.getRoleRemovedServerKeys = function() {
  return this._roleRemovedServerKeys;
};

/** @override */
wrm.data.sync.DataTrackerService.Change.prototype.toString = function() {
  var Type = wrm.data.sync.DataTrackerService.Change.Type;
  var entity = this._entity;
  
  var s = [];
  
  switch(this._type) {
    case Type.CREATE:
      s.push("Create of ");
      break;
    case Type.UPDATE:
      s.push("Update of ");
      break;
    case Type.DELETE:
      s.push("Delete of ");
      break;
  }
  
  s.push(String(entity));
  s.push(" {key: ");
  s.push(String(this.getKey()));
  s.push(", serverKey: ");
  s.push(String(this.getServerKey()));
  s.push("}");
  
  if (this._type !== Type.DELETE) {
    var attrValues = this.getAttributeValues();
    var roleAdds = this.getRoleAddedServerKeys();
    var roleRemoves = this.getRoleRemovedServerKeys();
    var pushed = false;
    
    s.push("\r\n\tAttributes: {");
    entity.getAttributes().forEach(function(attr) {
      var attrId = attr.getId();
      if (!attrValues.hasOwnProperty(attrId)) {
        return;
      }
      var value = attrValues[attrId];
      s.push("\r\n\t\t");
      s.push(String(attr));
      s.push(": ");
      s.push(String(value));
      pushed = true;
    });
    if (pushed) {
      s.push("\r\n\t");
    }
    s.push("}");
    
    pushed = false;
    
    s.push("\r\n\tRoles: {");
    entity.getRoles().forEach(function(role) {
      var roleId = role.getId();
      if (!roleAdds.hasOwnProperty(roleId) && !roleRemoves.hasOwnProperty(roleId)) {
        return;
      }
      s.push("\r\n\t\t");
      s.push(String(role));
      s.push(": {addedServerKeys: [");
      s.push((roleAdds[roleId] || []).join(", "));
      s.push("], removedServerKeys: [");
      s.push((roleRemoves[roleId] || []).join(", "));
      s.push("]}");
      pushed = true;
    });
    if (pushed) {
      s.push("\r\n\t");
    }
    s.push("}");
    
  }
  
  return s.join("");
};

/**
 * @package
 * @enum {string}
 */
wrm.data.sync.DataTrackerService.Change.Type = {CREATE:"create", UPDATE:"update", DELETE:"delete"};




//== wrm/data/sync/EntityDiff.js ==============================================



/**
 * @package
 * @constructor
 * @param {?wrm.data.DateTime} timestamp
 * @param {number} serverRecordCount
 * @param {!Array<!Object>|!wrm.util.AsyncIterator<!Array<!Object>>} serverRecordPageOrIter
 * @param {!Array<*>} deletedServerKeys
 * @param {?number=} serverKeysHash
 */
wrm.data.sync.EntityDiff = function(timestamp, serverRecordCount, serverRecordPageOrIter, deletedServerKeys, serverKeysHash) {
  this.timestamp = timestamp;
  this.serverRecordCount = serverRecordCount;
  if (Array.isArray(serverRecordPageOrIter)) {
    this.serverRecordPages = new wrm.util.ArrayAsyncIterator([serverRecordPageOrIter]);
  } else {
    this.serverRecordPages = serverRecordPageOrIter;
  }
  this.deletedServerKeys = deletedServerKeys;
  this.serverKeysHash = typeof serverKeysHash === "number" ? serverKeysHash : null;
};

/**
 * @package
 * @return {!wrm.data.sync.EntityDiff}
 */
wrm.data.sync.EntityDiff.empty = function() {
  return new wrm.data.sync.EntityDiff(null, 0, [], []);
};

/**
 * @package
 * @param {?wrm.data.DateTime} timestamp
 * @param {!Array<!Object>} serverRecords
 * @param {!Array<*>} deletedServerKeys
 * @param {?number=} serverKeysHash
 * @return {!wrm.data.sync.EntityDiff}
 */
wrm.data.sync.EntityDiff.createFixed = function(timestamp, serverRecords, deletedServerKeys, serverKeysHash) {
  return new wrm.data.sync.EntityDiff(timestamp, serverRecords.length, serverRecords, deletedServerKeys, serverKeysHash);
};

/**
 * @package
 * @param {?wrm.data.DateTime} timestamp
 * @param {number} serverRecordCount
 * @param {!wrm.util.AsyncIterator<!Array<!Object>>} serverRecordPageIter
 * @param {!Array<*>} deletedServerKeys
 * @param {?number=} serverKeysHash
 * @return {!wrm.data.sync.EntityDiff}
 */
wrm.data.sync.EntityDiff.createIterable = function(timestamp, serverRecordCount, serverRecordPageIter, deletedServerKeys, serverKeysHash) {
  return new wrm.data.sync.EntityDiff(timestamp, serverRecordCount, serverRecordPageIter, deletedServerKeys, serverKeysHash);
};




//== wrm/util/PromisedValue.js ================================================



/**
 * @internal
 * @constructor
 * @template T
 * @extends Promise.<T>
 * @param {!Promise.<T>} promise
 */
wrm.util.PromisedValue = function(promise) {
  var $jscomp$this = this;
  
  /** @private */
  this._promise = promise.finally(function() {
    $jscomp$this._pending = false;
  });
  
  /** @private */
  this._pending = true;
};

/**
 * @return {boolean}
 */
wrm.util.PromisedValue.prototype.isPending = function() {
  return this._pending;
};

/** @override */
wrm.util.PromisedValue.prototype.then = function(onFulfilled, onRejected) {
  return this._promise.then(onFulfilled, onRejected);
};

/** @override */
wrm.util.PromisedValue.prototype["catch"] = function(onRejected) {
  return this._promise["catch"](onRejected);
};

/** @override */
wrm.util.PromisedValue.prototype.toString = function() {
  return this._promise.toString();
};




//== wrm/data/sync/EntityDiffApplier.js =======================================



/**
 * @package
 * @constructor
 * @class Helper that applies changes to actual entities on the data source, in the context of a synchronization episode.
 * @param {!wrm.data.meta.Entity} entity
 * @param {string} token
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.sync.ObjectPuller} puller
 * @param {!wrm.util.TaskQueue} binaryValueProcessQueue
 * @param {!wrm.data.sync.AssociationSetAligner} assocsAligner
 * @param {boolean} retryDownload
 */
wrm.data.sync.EntityDiffApplier = function(entity, token, dataContext, puller, binaryValueProcessQueue, assocsAligner, retryDownload) {
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._token = token;
  
  /** @private */
  this._dataContext = dataContext;
  
  /** @private */
  this._puller = puller;
  
  /** @private */
  this._binaryValueProcessQueue = binaryValueProcessQueue;
  
  /** @private */
  this._assocsAligner = assocsAligner;
  
  /** @private */
  this._retryDownload = retryDownload;
  
  /** @private */
  this._concurrency = +Infinity;
  
  /** @private */
  this._selectConcurrency = +Infinity;
  
  /* Common create/update state */
  
  /** @private */
  this._createOrUpdateInitd = false;
  
  /** @private {!Promise<?Object<string,!Object>>} */
  this._recordsToRetry;
  
  /** @private {!Promise} */
  this._oldBlobValuesReady;
  
  /** @private {!Array} */
  this._promisedValues = [];
  
  /* Other state */
  
  /** @private */
  this._finalized = false;
};

/**
 * @param {number} concurrency
 * @param {number} selectConcurrency
 */
wrm.data.sync.EntityDiffApplier.prototype.setConcurrency = function(concurrency, selectConcurrency) {
  this._concurrency = concurrency;
  this._selectConcurrency = selectConcurrency;
};

/**
 * @private
 * @const
 */
wrm.data.sync.EntityDiffApplier._DELETE_CHUNK_SIZE = 200;

/**
 * @package
 * @param {!Array<*>} serverKeys
 * @param {!wrm.data.sync.EntitySyncStats} stats
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 */
wrm.data.sync.EntityDiffApplier.prototype.deleteObjects = function(serverKeys, stats, pm) {
  var $jscomp$this = this;
  if (this._finalized) {
    return Promise.reject(new Error("Diff applier is finalized"));
  }
  
  var DELETE_CHUNK_SIZE = wrm.data.sync.EntityDiffApplier._DELETE_CHUNK_SIZE;
  var entity = this._entity;
  var entityId = entity.getId();
  var serverKeyAttributeId = entity.getServerKeyAttribute().getId();
  
  var promise = Promise.resolve();
  
  pm.resize(serverKeys.length);
  
  /* If there are no keys, exit immediately */
  if (serverKeys.length <= 0) {
    return promise;
  }
  
  /* Delete all objects indicated by server keys */
  wrm.util.obj.sliceList(serverKeys, DELETE_CHUNK_SIZE).forEach(function(deletedServerKeysChunk) {
    promise = promise.then(function() {
      return $jscomp$this._delete(entityId, {filter:{property:serverKeyAttributeId, operator:"in"}}, [deletedServerKeysChunk]);
    }).then(function(deletedCount) {
      deletedServerKeysChunk.forEach(function(serverKey) {
        $jscomp$this._assocsAligner.deletedRecord(entity, serverKey);
      });
      stats.deleted += deletedCount;
      pm.worked(1);
    });
  });
  
  return promise;
};

/**
 * @package
 * @param {!Array<!Object>} serverRecords
 * @param {!wrm.data.sync.EntitySyncStats} stats
 * @param {boolean} waitForAllValues
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 */
wrm.data.sync.EntityDiffApplier.prototype.createOrUpdateObjects = function(serverRecords, stats, waitForAllValues, pm) {
  var $jscomp$this = this;
  if (this._finalized) {
    return Promise.reject(new Error("Diff applier is finalized"));
  }
  
  /* If there are no records, exit immediately */
  if (serverRecords.length <= 0) {
    return Promise.resolve();
  }
  
  this._initBeforeAllCreateOrUpdate();
  
  /* Merge information from RECORDS TO RETRY into the new records */
  return this._recordsToRetry.then(function(recordsToRetry) {
    if (!recordsToRetry) {
      return serverRecords;
    }
    var entityServerKeyName = $jscomp$this._entity.getServerKeyAttribute().getServerName();
    return serverRecords.map(function(record) {
      var recordToRetry = recordsToRetry[record[entityServerKeyName]];
      if (recordToRetry) {
        record = angular.extend({}, recordToRetry, record);
        delete recordsToRetry[record[entityServerKeyName]];
      }
      return record;
    });
  }).then(function(serverRecords) {
    
    /* Create or update the merged records */
    return $jscomp$this._doCreateOrUpdateObjects(serverRecords, stats, waitForAllValues, pm);
  });
};

/**
 * @package
 * @param {!wrm.data.sync.EntitySyncStats} stats
 * @param {boolean} waitForAllValues
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise<{promisedValues:!Array<!wrm.util.PromisedValue>}>}
 */
wrm.data.sync.EntityDiffApplier.prototype.finalizeApplication = function(stats, waitForAllValues, pm) {
  var $jscomp$this = this;
  if (this._finalized) {
    return Promise.reject(new Error("Diff applier is finalized"));
  }
  this._finalized = true;
  
  this._initBeforeAllCreateOrUpdate();
  
  /* Retrieve the remaining RECORDS TO RETRY (not consumed by merging with new records) */
  return this._recordsToRetry.then(function(recordsToRetry) {
    if (!recordsToRetry) {
      return [];
    }
    var entityServerKeyName = $jscomp$this._entity.getServerKeyAttribute().getServerName();
    return Object.keys(recordsToRetry).map(function(recordKey) {
      var obj = recordsToRetry[recordKey];
      obj[entityServerKeyName] = recordKey;
      return obj;
    });
  }).then(function(serverRecords) {
    
    /* Create or update the records to retry */
    return $jscomp$this._doCreateOrUpdateObjects(serverRecords, stats, waitForAllValues, pm);
    
  }).then(function() {
    return {promisedValues:$jscomp$this._promisedValues};
  });
};

/**
 * @private
 * @param {!Array<!Object>} serverRecords
 * @param {!wrm.data.sync.EntitySyncStats} stats
 * @param {boolean} waitForAllValues
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 */
wrm.data.sync.EntityDiffApplier.prototype._doCreateOrUpdateObjects = function(serverRecords, stats, waitForAllValues, pm) {
  var $jscomp$this = this;
  var entity = this._entity;
  var entityId = entity.getId();
  var keyAttributeId = entity.getKeyAttribute().getId();
  var serverKeyAttributeServerName = entity.getServerKeyAttribute().getServerName();
  
  pm.resize(serverRecords.length);
  
  /* If there are no records, exit immediately */
  if (serverRecords.length <= 0) {
    return Promise.resolve();
  }
  
  return Promise.try(function() {
    
    /* Wait for old BLOB values, which are necessary for avoiding re-download of identical files */
    return $jscomp$this._oldBlobValuesReady;
    
  }).then(function() {
    return $jscomp$this._resolveExistingKeys(serverRecords);
  }).then(function() {
    return $jscomp$this._assocsAligner.resolveKeys($jscomp$this._dataContext, $jscomp$this._entity, serverRecords);
  }).then(function() {
    var createdObjectKeys = {};
    return Promise.map(serverRecords, function(record, recordIndex) {
      if (record["__SKIP"] === true) {
        pm.worked(1);
        return undefined;
      }
      
      /* Extract server key and, if present, the local key of the corresponding object */
      var serverKey = record[serverKeyAttributeServerName];
      var existingObjectKey = record["__KEY"];
      var inlineAssocKeys = record["__INLINE_KEYS"];
      
      /* Convert the record into an update object */
      return $jscomp$this._puller.prepareObjectValues(record, existingObjectKey, $jscomp$this._token).then(function(objectValues) {
        
        /* Integrate resolved inline association keys */
        if (inlineAssocKeys) {
          angular.extend(objectValues, inlineAssocKeys);
        }
        
        /* Update or insert */
        if (existingObjectKey !== null) {
          if (objectValues) {
            return $jscomp$this._updateNoResult(entityId, {update:objectValues, filter:keyAttributeId}, [existingObjectKey]).then(function() {
              $jscomp$this._assocsAligner.updatedRecord(entity, record);
              stats.updated++;
              return existingObjectKey;
            });
          } else {
            return existingObjectKey;
          }
        } else {
          return $jscomp$this._insert(entityId, objectValues || {}).then(function(keys) {
            $jscomp$this._assocsAligner.createdRecord(entity, record);
            stats.created++;
            var objectKey = keys[0];
            createdObjectKeys[serverKey] = objectKey;
            return objectKey;
          });
        }
      }).then(function(objectKey) {
        return $jscomp$this._finalizeUpdate(waitForAllValues, objectKey, record);
      }).tap(function() {
        pm.worked(1);
      });
    }, {concurrency:$jscomp$this._concurrency});
  });
};

/**
 * @private
 * @param {boolean} waitForAllValues
 * @param {!*} objectKey
 * @param {!Object} record
 * @return {!Promise}
 */
wrm.data.sync.EntityDiffApplier.prototype._finalizeUpdate = function(waitForAllValues, objectKey, record) {
  var $jscomp$this = this;
  
  /* Finalize the updated values or just keep track of their promises */
  var finalizationDataContext = waitForAllValues ? this._dataContext : undefined;
  var valuePromises = this._puller.finalizeValues(record, objectKey, this._token, finalizationDataContext);
  if (waitForAllValues) {
    var queueWasSuspended = this._binaryValueProcessQueue.isSuspended();
    this._binaryValueProcessQueue.resume();
    return Promise.all(valuePromises).then(function() {
      if (queueWasSuspended) {
        $jscomp$this._binaryValueProcessQueue.suspend();
      }
    });
  }
  valuePromises.forEach(function(valuePromise) {
    $jscomp$this._promisedValues.push(new wrm.util.PromisedValue(valuePromise));
  });
  return Promise.resolve();
};

/**
 * Prepares the environment required by create-or-update.
 * 
 * @private
 */
wrm.data.sync.EntityDiffApplier.prototype._initBeforeAllCreateOrUpdate = function() {
  if (this._createOrUpdateInitd) {
    return;
  }
  this._createOrUpdateInitd = true;
  
  /* If retrying downloads, retrieve the RECORD TO RETRY keyed by their server key */
  if (this._retryDownload) {
    this._recordsToRetry = this._puller.retrieveMissingDownloads(this._dataContext);
  } else {
    this._recordsToRetry = Promise.resolve(({}));
  }
  
  /* Prepare OLD BLOB VALUES on the puller instance */
  this._oldBlobValuesReady = this._puller.fetchOldBlobValues(this._dataContext);
};

/**
 * @private
 * @const
 */
wrm.data.sync.EntityDiffApplier._KEY_RESOLVE_CHUNK_SIZE = 280;

/**
 * @private
 * @param {!Array<!Object>} records
 * @return {!Promise}
 */
wrm.data.sync.EntityDiffApplier.prototype._resolveExistingKeys = function(records) {
  var $jscomp$this = this;
  var KEY_RESOLVE_CHUNK_SIZE = wrm.data.sync.EntityDiffApplier._KEY_RESOLVE_CHUNK_SIZE;
  
  var entity = this._entity;
  var entityId = entity.getId();
  var keyAttributeId = entity.getKeyAttribute().getId();
  var serverKeyAttributeId = entity.getServerKeyAttribute().getId();
  var serverKeyAttributeServerName = entity.getServerKeyAttribute().getServerName();
  
  return Promise.try(function() {
    var recordIndexes = {};
    var recordsWithHint = [];
    
    /* Collect indexes by server keys, and mark hint local keys */
    records.forEach(function(record, recordIndex) {
      var serverKey = record[serverKeyAttributeServerName];
      if (serverKey === null || serverKey === undefined) {
        throw new Error("Created or updated record has no server key");
      }
      var hintLocalKey = record["__KEY"];
      
      /*
       * If there is an hint local key, keep track of the record to resolve/validate that key in the later asynchronous part of
       * this algorithm
       */
      if (hintLocalKey !== undefined) {
        recordsWithHint.push(record);
        return;
      }
      
      /* Mark EXCESS RECORDS for the same server key, in order to skip them in inserts (unlikely, but possible) */
      var previousIndex = recordIndexes[serverKey];
      if (typeof previousIndex === "number") {
        records[previousIndex]["__SKIP"] = true;
      }
      
      /* Keep track of the referenced server key, to resolve it later, in chunks */
      recordIndexes[serverKey] = recordIndex;
      record["__KEY"] = null;
    });
    
    /*
     * Resolve/validate hint local keys. This should actually happen only for one-shot records, so it should not impact performance
     */
    return Promise.map(recordsWithHint, function(record) {
      var serverKey = record[serverKeyAttributeServerName];
      var hintLocalKey = record["__KEY"];
      
      return $jscomp$this._selectOne(entityId, {output:{"key":keyAttributeId}, filter:({or:[serverKeyAttributeId, {property:keyAttributeId, implied:false}]})}, [serverKey, hintLocalKey]).then(function(existingObject) {
        record["__KEY"] = existingObject ? existingObject["key"] : null;
      });
    }, {concurrency:$jscomp$this._concurrency}).return(recordIndexes);
  }).then(function(recordIndexes) {
    
    /* Resolve server keys in chunks */
    var serverKeyChunks = wrm.util.obj.sliceList(Object.keys(recordIndexes), KEY_RESOLVE_CHUNK_SIZE);
    return Promise.map(serverKeyChunks, function(chunkServerKeys) {
      
      /* Select existing objects matching a chunk of server keys */
      return $jscomp$this._select(entityId, {output:{"serverKey":serverKeyAttributeId, "key":keyAttributeId}, filter:serverKeyAttributeId}, [chunkServerKeys]).then(function(existingObjects) {
        existingObjects.forEach(function(existingObject) {
          var existingServerKey = existingObject["serverKey"];
          var existingLocalKey = existingObject["key"];
          
          /* Save found keys on records */
          var indexes = recordIndexes[existingServerKey];
          records[indexes]["__KEY"] = existingLocalKey;
        });
      });
    }, {concurrency:$jscomp$this._selectConcurrency});
  });
};

/**
 * @private
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.sync.EntityDiffApplier.prototype._select = function(entityId, options, parameters) {
  return this._dataContext.select(entityId, angular.extend({}, options, {outputConfig:{useNames:true}}), parameters);
};

/**
 * @private
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<?Object|*>}
 */
wrm.data.sync.EntityDiffApplier.prototype._selectOne = function(entityId, options, parameters) {
  return this._dataContext.selectOne(entityId, angular.extend({}, options, {outputConfig:{useNames:true}}), parameters);
};

/**
 * @private
 * @param {string} entityId
 * @param {!Array<!Object>|!Object} insert
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.sync.EntityDiffApplier.prototype._insert = function(entityId, insert, parameters) {
  parameters = parameters || {};
  parameters["useNewishQueries"] = true;
  return this._dataContext.insert(entityId, insert, parameters).finally(function() {
    parameters["useNewishQueries"] = false;
  });
};

/**
 * @private
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<undefined>}
 */
wrm.data.sync.EntityDiffApplier.prototype._updateNoResult = function(entityId, options, parameters) {
  parameters = parameters || {};
  parameters["useNewishQueries"] = true;
  return this._dataContext.updateNoResult(entityId, options, parameters).finally(function() {
    parameters["useNewishQueries"] = false;
  });
};

/**
 * @private
 * @param {string} entityId
 * @param {{ include: (!Array<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=}
 *            options
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.sync.EntityDiffApplier.prototype._delete = function(entityId, options, parameters) {
  parameters = parameters || {};
  parameters["useNewishQueries"] = true;
  return this._dataContext["delete"](entityId, options, parameters).finally(function() {
    parameters["useNewishQueries"] = false;
  });
};




//== wrm/data/sync/EntitySyncStats.js =========================================


/**
 * @package
 * @constructor
 */
wrm.data.sync.EntitySyncStats = function() {
  this.created = 0;
  this.updated = 0;
  this.deleted = 0;
};

/**
 * @return {boolean}
 */
wrm.data.sync.EntitySyncStats.prototype.hasChanges = function() {
  return this.created > 0 || this.updated > 0 || this.deleted > 0;
};

/** @override */
wrm.data.sync.EntitySyncStats.prototype.toString = function() {
  return "{created: " + this.created + ", updated: " + this.updated + ", deleted: " + this.deleted + "}";
};




//== wrm/data/sync/KeyResolver.js =============================================



/**
 * @package
 * @constructor
 * @class Helper for efficiently resolving server keys into (local) keys.
 *        <p>
 *        The resolver does aggressive caching, even of missing keys, in order to minimize the amount of DB queries. The cache can be
 *        injected with new or changed knowledge by submitting known entity instance objects to the {@link #register} method.
 */
wrm.data.sync.KeyResolver = function() {
  
  /**
   * @private
   * @type {!Object.<string,?Object.<?,*>>}
   */
  this._cache = {};
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} serverKey
 * @return {*|null}
 */
wrm.data.sync.KeyResolver.prototype.resolveFromCache = function(entity, serverKey) {
  var entityCache = this._retrieveEntityCache(entity);
  if (!entityCache) {
    return null;
  }
  
  /* Retrieve from cache */
  var key = entityCache[serverKey];
  if (key !== undefined) {
    return key;
  }
  
  return null;
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} serverKey
 * @return {!Promise.<*>|!Promise.<null>}
 */
wrm.data.sync.KeyResolver.prototype.resolve = function(dataContext, entity, serverKey) {
  var entityCache = this._retrieveEntityCache(entity);
  if (!entityCache) {
    return Promise.resolve(null);
  }
  
  /* First attempt a retrieval from cache */
  var key = entityCache[serverKey];
  if (key !== undefined) {
    return Promise.resolve(key);
  }
  
  /* Retrieve the key from DB and cache it, even if not found! */
  return wrm.data.sync.findKey(dataContext, entity, serverKey, true).then(function(key) {
    entityCache[serverKey] = key;
    return key;
  });
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array<*>} serverKeys
 * @param {number} concurrency
 * @return {!Promise<!Array<{key:?*, serverKey:*}>>}
 */
wrm.data.sync.KeyResolver.prototype.resolveAll = function(dataContext, entity, serverKeys, concurrency) {
  var entityCache = this._retrieveEntityCache(entity);
  if (!entityCache) {
    return Promise.resolve([]);
  }
  
  var result = [];
  
  /* First attempt retrievals from cache, taking note of all unavailable server keys */
  var unresolvedServerKeys = [];
  for (var i = 0;i < serverKeys.length;i++) {
    var serverKey = serverKeys[i];
    var key = entityCache[serverKey];
    if (key !== undefined) {
      result.push({key:key, serverKey:serverKey});
    } else {
      unresolvedServerKeys.push(serverKey);
    }
  }
  if (unresolvedServerKeys.length <= 0) {
    return Promise.resolve(result);
  }
  
  /* Retrieve all unknown keys from DB and cache them, even if not found! */
  return wrm.data.sync.findAllKeys(dataContext, entity, unresolvedServerKeys, concurrency, true).then(function(pairs) {
    for (var i = 0;i < pairs.length;i++) {
      var pair = pairs[i];
      entityCache[pair.serverKey] = pair.key;
    }
    return result.concat(pairs);
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} object
 */
wrm.data.sync.KeyResolver.prototype.register = function(entity, object) {
  var entityCache = this._retrieveEntityCache(entity);
  if (!entityCache) {
    return;
  }
  
  var serverKey = object[entity.getServerKeyAttribute().getName()];
  if (serverKey === null) {
    return;
  }
  
  var key = object[entity.getKeyAttribute().getName()];
  entityCache[serverKey] = key;
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} object
 */
wrm.data.sync.KeyResolver.prototype.unregister = function(entity, object) {
  var entityCache = this._retrieveEntityCache(entity);
  if (!entityCache) {
    return;
  }
  
  var serverKey = object[entity.getServerKeyAttribute().getName()];
  if (serverKey === null) {
    return;
  }
  
  delete entityCache[serverKey];
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {?Object.<?,*>}
 */
wrm.data.sync.KeyResolver.prototype._retrieveEntityCache = function(entity) {
  var entityId = entity.getId();
  var entityCache = this._cache[entityId];
  if (entityCache === undefined) {
    if (entity.getServerKeyAttribute()) {
      entityCache = {};
    } else {
      entityCache = null;
    }
    this._cache[entityId] = entityCache;
  }
  return entityCache;
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.sync.KeyResolver.prototype.clear = function() {
  this._cache = {};
};

/*
 * Change listener
 */

/**
 * @package
 * @return {!wrm.data.ChangeListener}
 */
wrm.data.sync.KeyResolver.prototype.createChangeListener = function() {
  return new wrm.data.sync.KeyResolver._ChangeListener(this);
};

/**
 * @private
 * @constructor
 * @implements wrm.data.ChangeListener
 * @param {!wrm.data.sync.KeyResolver} keyResolver
 */
wrm.data.sync.KeyResolver._ChangeListener = function(keyResolver) {
  
  /** @private */
  this._keyResolver = keyResolver;
};

/** @override */
wrm.data.sync.KeyResolver._ChangeListener.prototype.getEntityListener = function(entity) {
  return new wrm.data.sync.KeyResolver._ChangeListener.KeyChangeListener(entity, this._keyResolver);
};

/** @override */
wrm.data.sync.KeyResolver._ChangeListener.prototype.getAssociationListener = function(assoc) {
  return null;
};

/**
 * @private
 * @constructor
 * @extends wrm.data.XDChangeTrackerAdapter
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.sync.KeyResolver} keyResolver
 */
wrm.data.sync.KeyResolver._ChangeListener.KeyChangeListener = function(entity, keyResolver) {
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._keyResolver = keyResolver;
  
  this.tracked = [entity.getKeyAttribute().getName()];
  if (entity.getServerKeyAttribute()) {
    this.tracked.push(entity.getServerKeyAttribute().getName());
  }
  
  this.trackedOld = [entity.getKeyAttribute().getName()];
  if (entity.getServerKeyAttribute()) {
    this.trackedOld.push(entity.getServerKeyAttribute().getName());
  }
};

/** @override */
wrm.data.sync.KeyResolver._ChangeListener.KeyChangeListener.prototype.afterInsert = function(newInstance) {
  this._keyResolver.register(this._entity, newInstance);
};

/** @override */
wrm.data.sync.KeyResolver._ChangeListener.KeyChangeListener.prototype.afterUpdate = function(oldInstance, newInstance) {
  this._keyResolver.register(this._entity, newInstance);
};

/** @override */
wrm.data.sync.KeyResolver._ChangeListener.KeyChangeListener.prototype.afterDelete = function(oldInstance) {
  this._keyResolver.unregister(this._entity, oldInstance);
};




//== wrm/data/sync/AbstractObjectMover.js =====================================


/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.DataRunner|!Object} dataStore
 * @param {!wrm.Log} log
 */
wrm.data.sync.AbstractObjectMover = function(entity, dataStore, log) {
  
  /** @private */
  this._entity = entity;
  
  /* Determine whether to use a data runner or object */
  var dataRunner, dataObject;
  if (implementsInterface(dataStore, wrm.data.DataRunner)) {
    dataRunner = dataStore;
    dataObject = null;
  } else {
    dataRunner = null;
    dataObject = dataStore;
  }
  
  /**
   * @private
   * @type {?wrm.data.DataRunner}
   */
  this._dataRunner = (dataRunner);
  
  /**
   * @private
   * @type {?Object}
   */
  this._dataObject = dataObject;
  
  /** @private */
  this._log = log;
  
  /** @private */
  this._mappedAttributes = this._createMappedAttributes(entity);
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Array<!wrm.data.meta.Attribute>}
 */
wrm.data.sync.AbstractObjectMover.prototype._createMappedAttributes = function(entity) {
  
  /* Determine the mapped attributes (those having an agreed server name) */
  return entity.getAttributes().filter(function(attr) {
    return !!attr.getServerName();
  });
};

/**
 * @protected
 * @return {!wrm.Log}
 */
wrm.data.sync.AbstractObjectMover.prototype.getLog = function() {
  return this._log;
};

/**
 * @return {!Array<!wrm.data.meta.Attribute>}
 */
wrm.data.sync.AbstractObjectMover.prototype.getMappedAttributes = function() {
  return this._mappedAttributes;
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.sync.AbstractObjectMover.prototype.getEntity = function() {
  return this._entity;
};

/*
 * Utilities
 */

/**
 * @protected
 * @param {*} targetKey
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise.<*|Object>}
 */
wrm.data.sync.AbstractObjectMover.prototype.readTargetValue = function(targetKey, attribute, localDataContext) {
  if (this._dataRunner) {
    return this._readTargetValueFromRunner(targetKey, attribute, localDataContext || null);
  } else {
    return this._readTargetValueFromObject(targetKey, attribute);
  }
};

/**
 * @private
 * @param {*} targetKey
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise.<*|Object>}
 */
wrm.data.sync.AbstractObjectMover.prototype._readTargetValueFromRunner = function(targetKey, attribute, localDataContext) {
  var entity = this._entity;
  var keyAttribute = entity.getKeyAttribute();
  return this._executeDataOperations(localDataContext, function(dataContext) {
    dataContext.setExposedMetaAttributes("serverFileId");
    var outputAttrId = attribute instanceof wrm.data.meta.MetaAttribute ? attribute.getNewId() : attribute.getId();
    return dataContext.selectOne(entity.getId(), {output:outputAttrId, outputConfig:{useNames:true}, filter:keyAttribute.getId()}, [targetKey]);
  });
};

/**
 * @private
 * @param {*} targetKey
 * @param {!wrm.data.meta.Attribute} attribute
 * @return {!Promise.<*|Object>}
 */
wrm.data.sync.AbstractObjectMover.prototype._readTargetValueFromObject = function(targetKey, attribute) {
  var instance = this._dataObject[targetKey];
  return Promise.resolve(instance[attribute.getId()]);
};

/**
 * @protected
 * @param {*} targetKey
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*|Object} value
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise}
 */
wrm.data.sync.AbstractObjectMover.prototype.writeTargetValue = function(targetKey, attribute, value, localDataContext) {
  var updateValues = {};
  updateValues[attribute.getId()] = value;
  return this.writeTargetValues(targetKey, updateValues, localDataContext);
};

/**
 * @protected
 * @param {*} targetKey
 * @param {!Object.<string,*|Object>} attributeValues
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise}
 */
wrm.data.sync.AbstractObjectMover.prototype.writeTargetValues = function(targetKey, attributeValues, localDataContext) {
  if (this._dataRunner) {
    return this._writeTargetValuesToRunner(targetKey, attributeValues, localDataContext || null);
  } else {
    return this._writeTargetValuesToObject(targetKey, attributeValues);
  }
};

/**
 * @private
 * @param {*} targetKey
 * @param {!Object.<string,*|Object>} attributeValues
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise}
 */
wrm.data.sync.AbstractObjectMover.prototype._writeTargetValuesToRunner = function(targetKey, attributeValues, localDataContext) {
  var entity = this._entity;
  var keyAttribute = entity.getKeyAttribute();
  return this._executeDataOperations(localDataContext, function(dataContext) {
    dataContext.setExposedMetaAttributes("serverFileId");
    return dataContext.update(entity.getId(), {update:attributeValues, filter:keyAttribute.getId()}, [targetKey]);
  });
};

/**
 * @private
 * @param {*} targetKey
 * @param {!Object.<string,*|Object>} attributeValues
 * @return {!Promise}
 */
wrm.data.sync.AbstractObjectMover.prototype._writeTargetValuesToObject = function(targetKey, attributeValues) {
  var instance = this._dataObject[targetKey];
  if (instance) {
    angular.extend(instance, attributeValues);
  }
  return Promise.resolve();
};

/**
 * @private
 * @template R
 * @param {?wrm.data.DataContext} localDataContext
 * @param {function(!wrm.data.DataContext):(R|!Promise.<R>)} callback
 * @return {!Promise.<R>}
 */
wrm.data.sync.AbstractObjectMover.prototype._executeDataOperations = function(localDataContext, callback) {
  if (DEBUG && !this._dataRunner) {
    throw new Error("Object mover is not backed by a data runner store");
  }
  if (localDataContext) {
    return Promise.resolve(callback(localDataContext));
  }
  return this._dataRunner.execute(callback);
};




//== wrm/data/sync/ObjectPuller.js ============================================



/**
 * @internal
 * @constructor
 * @extends wrm.data.sync.AbstractObjectMover
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.DataRunner|!Object} dataStore
 * @param {!wrm.core.BackEndService} backEndService
 * @param {!wrm.Log} log
 */
wrm.data.sync.ObjectPuller = function(entity, dataStore, backEndService, log) {
  wrm.data.sync.AbstractObjectMover.call(this, entity, dataStore, log);
  
  /** @private */
  this._backEndService = backEndService;
  
  /**
   * @private
   * @type {?wrm.data.sync.BlobCache}
   */
  this._blobCache = null;
  
  /**
   * @private
   * @type {?wrm.util.TaskQueue}
   */
  this._binaryValueProcessQueue = null;
  
  /**
   * @private
   * @type {?Object<Object>}
   */
  this._oldBlobServerfileId = null;
};

/**
 * @private
 * @type {!Object<string,boolean>}
 */
wrm.data.sync.ObjectPuller._pendingBlob = {};

extendConstructor(wrm.data.sync.ObjectPuller, wrm.data.sync.AbstractObjectMover);

/**
 * @internal
 * @param {?wrm.data.sync.BlobCache} blobCache
 */
wrm.data.sync.ObjectPuller.prototype.setBlobCache = function(blobCache) {
  this._blobCache = blobCache;
};

/**
 * @internal
 * @param {?wrm.util.TaskQueue} binaryValueProcessQueue
 */
wrm.data.sync.ObjectPuller.prototype.setBinaryValueProcessQueue = function(binaryValueProcessQueue) {
  this._binaryValueProcessQueue = binaryValueProcessQueue;
};

/*
 * Value Preparation
 */

/**
 * @internal
 * @param {!Object} record
 * @param {?*} targetKey
 * @param {?string} token
 * @param {!wrm.data.DataContext=} dataContext
 * @return {!Promise<?Object>}
 */
wrm.data.sync.ObjectPuller.prototype.prepareObjectValues = function(record, targetKey, token, dataContext) {
  if (DEBUG) {
    if (!this._oldBlobServerfileId) {
      throw new Error("oldBlobServerfileId must be ferched before");
    }
  }
  
  var localDataContext = dataContext || null;
  
  /* Prepare each value */
  var result = {};
  var oneFieldSetSync = false;
  var preparePromises = (null);
  var mappedAttributes = this.getMappedAttributes();
  for (var i = 0;i < mappedAttributes.length;i++) {
    var attr = mappedAttributes[i];
    var value = record[attr.getServerName()];
    if (value !== undefined) {
      var flagOrPromise = this._prepareAttributeObjectValue(result, attr, value, targetKey, token, localDataContext);
      
      /* Keep track immediately of flags, maybe avoiding the use of Promise.all */
      if (typeof flagOrPromise === "boolean") {
        oneFieldSetSync = oneFieldSetSync || flagOrPromise;
      } else {
        if (!preparePromises) {
          preparePromises = [];
        }
        preparePromises.push(flagOrPromise);
      }
    }
  }
  
  /*
   * Return the result object if at least one field was set, while also waiting for any asynchronous preparation to complete. If
   * waiting for more preparations, it may also be necessary to test their (async) flags to determine whether a field has been
   * modified.
   * 
   * Note that all this hassle is necessary to avoid unnecessary Promise.all and closure creation, which are both taxing on
   * performance.
   */
  if (preparePromises) {
    return Promise.all(preparePromises).then(function(additionalFlags) {
      var oneFieldSet = oneFieldSetSync || additionalFlags.indexOf(true) >= 0;
      return oneFieldSet ? result : null;
    });
  } else {
    return (Promise.resolve(oneFieldSetSync ? result : null));
  }
};

/**
 * @private
 * @param {!Object} objectValues
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*} value
 * @param {?*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise.<boolean>|boolean}
 */
wrm.data.sync.ObjectPuller.prototype._prepareAttributeObjectValue = function(objectValues, attribute, value, targetKey, token, localDataContext) {
  var type = attribute.getType();
  
  /* Prepare binary values in a special way */
  if (type === wrm.data.Type.BLOB && !(value instanceof wrm.data.Blob)) {
    return this._prepareBinaryAttributeObjectValue(objectValues, attribute, value !== null ? String(value) : null, targetKey, token, localDataContext);
  }
  
  /* For other types, just set by server name (leave the eventual conversion to downstream code) */
  objectValues[attribute.getId()] = wrm.data.toAnySingle(value);
  return true;
};

/**
 * @private
 * @param {!Object} objectValues
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?string} serverFileId
 * @param {?*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise.<boolean>|boolean}
 */
wrm.data.sync.ObjectPuller.prototype._prepareBinaryAttributeObjectValue = function(objectValues, attribute, serverFileId, targetKey, token, localDataContext) {
  
  var thisPuller = this;
  
  /* Emptying the value is done as with regular values */
  if (serverFileId === null) {
    objectValues[attribute.getId()] = null;
    objectValues[attribute.getMetaAttribute("status").getId()] = wrm.data.AvailabilityStatus.AVAILABLE;
    return true;
  }
  
  /* If the blob didn't change do nothing */
  var oldRecord = this._oldBlobServerfileId[targetKey];
  if (oldRecord && oldRecord[attribute.getServerName()] === serverFileId) {
    return true;
  }
  
  /* If the value is in the map means that it is already pending and it is managed by another instance */
  if (wrm.data.sync.ObjectPuller._pendingBlob[this.getEntity().getId() + "_" + attribute.getId() + "_" + serverFileId]) {
    return true;
  }
  
  objectValues[attribute.getId()] = new wrm.data.BlobReference(serverFileId, wrm.data.AvailabilityStatus.PENDING);
  wrm.data.sync.ObjectPuller._pendingBlob[thisPuller.getEntity().getId() + "_" + attribute.getId() + "_" + serverFileId] = true;
  
  /*
   * A non-null server file id requires special handling: do not modify the target object and leave the change for later, during
   * finalization
   */
  return false;
};

/*
 * Value Finalization
 */

/**
 * @internal
 * @param {!Object} record
 * @param {*} targetKey
 * @param {?string} token
 * @param {!wrm.data.DataContext=} dataContext
 * @return {!Array<!Promise>}
 */
wrm.data.sync.ObjectPuller.prototype.finalizeValues = function(record, targetKey, token, dataContext) {
  var localDataContext = dataContext || null;
  
  /* Finalize each value */
  var finalizePromises = [];
  var mappedAttributes = this.getMappedAttributes();
  for (var i = 0;i < mappedAttributes.length;i++) {
    var attr = mappedAttributes[i];
    var value = record[attr.getServerName()];
    if (value !== undefined) {
      var valuePromise = this._finalizeAttributeValue(attr, value, targetKey, token, localDataContext);
      if (valuePromise) {
        finalizePromises.push(valuePromise);
      }
    }
  }
  
  return finalizePromises;
};

/**
 * @private
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*|Object} value
 * @param {*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise|undefined}
 */
wrm.data.sync.ObjectPuller.prototype._finalizeAttributeValue = function(attribute, value, targetKey, token, localDataContext) {
  var Type = wrm.data.Type;
  
  var type = attribute.getType();
  
  /* Finalize binary values in a special way */
  if (type === Type.BLOB && !(value instanceof wrm.data.Blob)) {
    return this._finalizeBinaryAttributeValue(attribute, value !== null ? String(value) : null, targetKey, token, localDataContext);
  }
  
  /* For other types, no finalization is required */
};

/**
 * @private
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?string} serverFileId
 * @param {*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise|undefined}
 */
wrm.data.sync.ObjectPuller.prototype._finalizeBinaryAttributeValue = function(attribute, serverFileId, targetKey, token, localDataContext) {
  
  /* Emptying the value does not require finalization */
  if (serverFileId === null) {
    return;
  }
  
  /* Require a token */
  if (token === null || token === undefined) {
    throw new Error("Token is required for finalizing non-null binary values");
  }
  var requiredToken = token;
  
  /* Perform the actual finalization through a queue (if provided) or immediately */
  if (this._binaryValueProcessQueue) {
    return this._binaryValueProcessQueue.post(this._doFinalizeBinaryAttributeValue.bind(this, attribute, serverFileId, targetKey, requiredToken, localDataContext));
  }
  return this._doFinalizeBinaryAttributeValue(attribute, serverFileId, targetKey, requiredToken, localDataContext);
};

/**
 * @private
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?string} serverFileId
 * @param {*} targetKey
 * @param {string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise|undefined}
 */
wrm.data.sync.ObjectPuller.prototype._doFinalizeBinaryAttributeValue = function(attribute, serverFileId, targetKey, token, localDataContext) {
  var thisPuller = this;
  var updatedValues = {};
  
  /* Determine the current server file id for the binary attribute */
  var serverFileIdMetaAttr = attribute.getMetaAttribute("serverFileId");
  var statusMetaAttId = attribute.getMetaAttribute("status").getId();
  
  /* Fetch the new binary value and set it along with the server file id */
  return thisPuller._fetchBinaryValue(String(serverFileId), token).then(function(blob) {
    if (blob) {
      
      updatedValues[attribute.getId()] = blob;
      updatedValues[statusMetaAttId] = wrm.data.AvailabilityStatus.AVAILABLE;
    } else {
      updatedValues[statusMetaAttId] = wrm.data.AvailabilityStatus.FAILED;
    }
    delete wrm.data.sync.ObjectPuller._pendingBlob[thisPuller.getEntity().getId() + "_" + attribute.getId() + "_" + serverFileId];
    
    updatedValues[attribute.getId()] = blob;
    updatedValues[serverFileIdMetaAttr.getId()] = serverFileId;
    return thisPuller.writeTargetValues(targetKey, updatedValues, localDataContext);
  });
};

/**
 * @private
 * @param {string} serverFileId
 * @param {string} token
 * @return {!Promise.<?wrm.data.Blob>}
 */
wrm.data.sync.ObjectPuller.prototype._fetchBinaryValue = function(serverFileId, token) {
  var backEndService = this._backEndService;
  var log = this.getLog();
  
  /* Attempt to retrieve from the local BLOB cache */
  return this._retrieveCachedBlob(serverFileId).then(function(cachedBlob) {
    if (cachedBlob) {
      if (log.isDebugEnabled()) {
        log.debug("Reusing previously downloaded content for file", serverFileId);
      }
      return cachedBlob;
    }
    
    /* Obtain a blob for the file id from the back-end */
    return backEndService.downloadFile(token, serverFileId).then(function(file) {
      var buffer = file.buffer;
      var contentType = file.contentType;
      if (log.isDebugEnabled()) {
        log.debug("Received content for file", serverFileId, ": size " + buffer.byteLength + ", type " + contentType + ", fileName " + file.fileName);
      }
      return wrm.data.Blob.fromBytes(buffer, contentType || undefined, {fileName:file.fileName, contentSignature:serverFileId});
    })["catch"](function(e) {
      log.error("Failed download of file", serverFileId, ":", e);
      return null;
    });
  });
};

/**
 * @private
 * @param {string} fileIdString
 * @return {!Promise.<!wrm.data.Blob>|!Promise.<null>}
 */
wrm.data.sync.ObjectPuller.prototype._retrieveCachedBlob = function(fileIdString) {
  
  /* Retrieve from cache if possible */
  if (this._blobCache) {
    return this._blobCache.retrieve(fileIdString);
  }
  
  return Promise.resolve(null);
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.sync.ObjectPuller.prototype.fetchOldBlobValues = function(dataContext) {
  var blobAttributes = this._retrieveAttributeOfSpecificType(wrm.data.Type.BLOB);
  if (blobAttributes.length === 0) {
    this._oldBlobServerfileId = {};
    return Promise.resolve();
  }
  
  var entity = this.getEntity();
  var serverKeyAttr = entity.getServerKeyAttribute();
  var outputs = {};
  outputs[serverKeyAttr.getServerName()] = serverKeyAttr.getId();
  blobAttributes.forEach(function(attribute) {
    outputs[attribute.getMetaAttribute("status").getId()] = attribute.getMetaAttribute("status").getNewId();
    outputs[attribute.getServerName()] = attribute.getMetaAttribute("serverFileId").getNewId();
  });
  
  var thisObjectPuller = this;
  return dataContext.select(entity.getId(), {output:outputs, outputConfig:{useNames:true}}).then(function(records) {
    var result = {};
    records.forEach(function(record) {
      var obj = {};
      var serverKey = record[serverKeyAttr.getServerName()];
      var available = wrm.data.AvailabilityStatus.AVAILABLE;
      blobAttributes.forEach(function(att) {
        if (record[att.getMetaAttribute("status").getId()] === available) {
          obj[att.getServerName()] = record[att.getServerName()];
        }
      });
      result[serverKey] = obj;
    });
    thisObjectPuller._oldBlobServerfileId = result;
    return;
  });
  
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<?Object<string,!Object>>}
 */
wrm.data.sync.ObjectPuller.prototype.retrieveMissingDownloads = function(dataContext) {
  var blobAttributes = this._retrieveAttributeOfSpecificType(wrm.data.Type.BLOB);
  if (blobAttributes.length === 0) {
    return Promise.resolve();
  }
  
  var entity = this.getEntity();
  var available = wrm.data.AvailabilityStatus.AVAILABLE;
  var serverKeyAttr = entity.getServerKeyAttribute();
  var orConditionParts = [];
  var outputs = {};
  outputs[serverKeyAttr.getServerName()] = serverKeyAttr.getId();
  blobAttributes.forEach(function(attribute) {
    var conditionPart = {property:attribute.getMetaAttribute("status").getNewId(), operator:"!eq", value:available};
    orConditionParts.push(conditionPart);
    outputs[attribute.getServerName()] = attribute.getMetaAttribute("serverFileId").getNewId();
  });
  
  return dataContext.select(entity.getId(), {filter:({or:orConditionParts}), output:outputs, outputConfig:{useNames:true}}).then(function(records) {
    if (records.length === 0) {
      return;
    }
    var result = {};
    records.forEach(function(record) {
      var serverKey = record[serverKeyAttr.getServerName()];
      delete record[serverKeyAttr.getServerName()];
      result[serverKey] = record;
    });
    return result;
  });
  
};

/**
 * @private
 * @param {!wrm.data.Type} type
 * @return {!Array<wrm.data.meta.Attribute>}
 */
wrm.data.sync.ObjectPuller.prototype._retrieveAttributeOfSpecificType = function(type) {
  var attributes = this.getEntity().getAttributes();
  return attributes.filter(function(attribute) {
    return attribute.getType() === type;
  });
};




//== wrm/data/sync/ObjectPusher.js ============================================



/**
 * @internal
 * @constructor
 * @extends wrm.data.sync.AbstractObjectMover
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.DataRunner|!Object} dataStore
 * @param {!wrm.core.BackEndService} backEndService
 * @param {!wrm.Log} log
 */
wrm.data.sync.ObjectPusher = function(entity, dataStore, backEndService, log) {
  wrm.data.sync.AbstractObjectMover.call(this, entity, dataStore, log);
  
  /** @private */
  this._backEndService = backEndService;
};

extendConstructor(wrm.data.sync.ObjectPusher, wrm.data.sync.AbstractObjectMover);

/*
 * Value Preparation
 */

/**
 * @internal
 * @param {!Object} objectValues
 * @param {*} targetKey
 * @param {?string} token
 * @param {!wrm.data.DataContext=} dataContext
 * @return {!Promise<?Object>}
 */
wrm.data.sync.ObjectPusher.prototype.prepareRecordValues = function(objectValues, targetKey, token, dataContext) {
  var thisPusher = this;
  var localDataContext = dataContext || null;
  
  /* Prepare each value */
  var result = {};
  var preparePromises = [];
  this.getMappedAttributes().forEach(function(attr) {
    var value = objectValues[attr.getId()];
    if (value !== undefined) {
      preparePromises.push(thisPusher._prepareAttributeRecordValue(result, attr, value, targetKey, token, localDataContext));
    }
  });
  
  return Promise.all(preparePromises).then(function(writtenFlags) {
    var oneFieldSet = writtenFlags.indexOf(true) >= 0;
    return oneFieldSet ? result : null;
  });
};

/**
 * @private
 * @param {!Object} record
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*|Object} value
 * @param {*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise<boolean>|boolean}
 */
wrm.data.sync.ObjectPusher.prototype._prepareAttributeRecordValue = function(record, attribute, value, targetKey, token, localDataContext) {
  var log = this.getLog();
  
  var type = attribute.getType();
  
  /* Prepare binary values in a special way */
  if (type === wrm.data.Type.BLOB) {
    if (value === null || value instanceof wrm.data.Blob) {
      return this._prepareBinaryAttributeRecordValue(record, attribute, value, targetKey, token, localDataContext);
    }
    log.warn("Ignoring non-blob value");
    return false;
  }
  
  /* For other types, just set by server name after converting to record-friendly value */
  record[attribute.getServerName()] = wrm.data.sync.ObjectPusher.convertToRecordValue(type, value);
  return true;
};

/**
 * @private
 * @param {!Object} record
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {wrm.data.Blob} blob
 * @param {*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise<boolean>|boolean}
 */
wrm.data.sync.ObjectPusher.prototype._prepareBinaryAttributeRecordValue = function(record, attribute, blob, targetKey, token, localDataContext) {
  
  /* Emptying the value is done as with regular values */
  if (!blob) {
    record[attribute.getServerName()] = null;
    return true;
  }
  
  /* Determine the current server file id for the binary attribute */
  var serverFileIdMetaAttr = attribute.getMetaAttribute("serverFileId");
  return this.readTargetValue(targetKey, serverFileIdMetaAttr, localDataContext).then(function(currentServerFileId) {
    
    /*
     * If there is no current server file id, consider the value a new one and use the special "empty" server file id to ask for a
     * new binary slot. For using the same id, NOTHING must be put in the record, since only the server can set non-empty BLOBs.
     */
    if (!currentServerFileId) {
      record[attribute.getServerName()] = "empty";
      return true;
    } else {
      return false;
    }
  });
};

/**
 * @internal
 * @param {!wrm.data.Type} type
 * @param {*|Object} value
 * @return {*}
 */
wrm.data.sync.ObjectPusher.convertToRecordValue = function(type, value) {
  var Type = wrm.data.Type;
  
  /*
   * Server records support only some types (as they must be JSON-serializable); convert everything else to STRING
   */
  if (type !== Type.STRING && type !== Type.INTEGER && type !== Type.FLOAT && type !== Type.BOOLEAN) {
    type = Type.STRING;
  }
  
  return wrm.data.toSingle(type, value);
};

/*
 * Value Finalization
 */

/**
 * @internal
 * @param {?Object} resultRecord
 * @param {!Object} objectValues
 * @param {*} targetKey
 * @param {?string} token
 * @param {!wrm.data.DataContext=} dataContext
 * @return {!Array<!Promise>}
 */
wrm.data.sync.ObjectPusher.prototype.finalizeValues = function(resultRecord, objectValues, targetKey, token, dataContext) {
  var thisPusher = this;
  var localDataContext = dataContext || null;
  
  /* Finalize each value */
  var finalizePromises = [];
  this.getMappedAttributes().forEach(function(attr) {
    var value = objectValues[attr.getId()];
    if (value !== undefined) {
      var valuePromise = thisPusher._finalizeAttributeValue(resultRecord, attr, value, targetKey, token, localDataContext);
      if (valuePromise) {
        finalizePromises.push(valuePromise);
      }
    }
  });
  
  return finalizePromises;
};

/**
 * @private
 * @param {?Object} resultRecord
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*|Object} value
 * @param {*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise|undefined}
 */
wrm.data.sync.ObjectPusher.prototype._finalizeAttributeValue = function(resultRecord, attribute, value, targetKey, token, localDataContext) {
  var Type = wrm.data.Type;
  
  var type = attribute.getType();
  
  /* Finalize binary values in a special way */
  if (type === Type.BLOB) {
    if (value === null || value instanceof wrm.data.Blob) {
      return this._finalizeBinaryAttributeValue(resultRecord, attribute, value, targetKey, token, localDataContext);
    }
    return;
  }
  
  /* For other types, no finalization is required */
};

/**
 * @private
 * @param {?Object} resultRecord
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {wrm.data.Blob} blob
 * @param {*} targetKey
 * @param {?string} token
 * @param {?wrm.data.DataContext} localDataContext
 * @return {!Promise|undefined}
 */
wrm.data.sync.ObjectPusher.prototype._finalizeBinaryAttributeValue = function(resultRecord, attribute, blob, targetKey, token, localDataContext) {
  var thisPusher = this;
  var backEndService = this._backEndService;
  var log = this.getLog();
  
  /* Emptying the value does not require finalization */
  if (!blob) {
    return;
  }
  
  /* Require a token */
  if (token === null || token === undefined) {
    throw new Error("Token is required for finalizing non-null binary values");
  }
  var requiredToken = token;
  
  var attributeServerName = attribute.getServerName();
  var serverFileIdMetaAttr = attribute.getMetaAttribute("serverFileId");
  
  /* Get the actual (confirmed) server file id from the result record or from the target object (if the server did not change it) */
  var promise;
  if (resultRecord && resultRecord[attributeServerName]) {
    promise = Promise.resolve(resultRecord[attributeServerName]);
    delete resultRecord[attributeServerName];
  } else {
    promise = this.readTargetValue(targetKey, serverFileIdMetaAttr, localDataContext);
  }
  promise = promise.then(function(serverFileId) {
    
    /* Upload the BLOB to the back-end */
    return Promise.resolve().then(function() {
      return blob.read();
    }).then(function(byteArray) {
      var buffer = byteArray.buffer;
      var contentType = blob.getContentType();
      var fileName = blob.computeExternalFileName();
      
      if (log.isDebugEnabled()) {
        log.debug("Sending content for file", serverFileId, ": size " + buffer.byteLength + ", type " + contentType + ", fileName " + fileName);
      }
      
      return backEndService.uploadFile(requiredToken, serverFileId, {buffer:buffer, contentType:contentType || undefined, fileName:fileName || undefined})["catch"](function(e) {
        log.error("Failed upload of file", serverFileId, ":", e);
      });
    });
  });
  
  /* Set the new after-the-fact server file id on the target */
  return promise.then(function(newServerFileId) {
    return thisPusher.writeTargetValue(targetKey, serverFileIdMetaAttr, newServerFileId, localDataContext);
  });
};




//== wrm/util/ProgressMonitor.js ==============================================


/**
 * @interface
 */
wrm.util.ProgressMonitor = function() {
};

/**
 * @param {number} ticks
 */
wrm.util.ProgressMonitor.prototype.resize = function(ticks) {
};

/**
 * @param {number} ticks
 */
wrm.util.ProgressMonitor.prototype.worked = function(ticks) {
};

/**
 * @param {number} ticks
 * @return {!wrm.util.ProgressMonitor}
 */
wrm.util.ProgressMonitor.prototype.sub = function(ticks) {
};

/**
 * @return {undefined}
 */
wrm.util.ProgressMonitor.prototype.done = function() {
};




//== wrm/util/FakeProgressMonitor.js ==========================================



/**
 * @constructor
 * @implements {wrm.util.ProgressMonitor}
 */
wrm.util.FakeProgressMonitor = function() {
};

/** @override */
wrm.util.FakeProgressMonitor.prototype.resize = function(ticks) {
};

/** @override */
wrm.util.FakeProgressMonitor.prototype.worked = function(ticks) {
};

/** @override */
wrm.util.FakeProgressMonitor.prototype.sub = function(ticks) {
  return this;
};

/** @override */
wrm.util.FakeProgressMonitor.prototype.done = function() {
};

/**
 * @const
 */
wrm.util.FakeProgressMonitor.INSTANCE = new wrm.util.FakeProgressMonitor;




//== wrm/util/TaskQueue.js ====================================================


/**
 * @constructor
 * @param {{maxWorkers:(number|undefined)}=} options
 */
wrm.util.TaskQueue = function(options) {
  
  /**
   * @private
   * @type {!Array<{work:(function():?), priority:number, resolve:function(*), reject:function(*)}>}
   */
  this._tasks = [];
  
  /** @private */
  this._activeWorkers = 0;
  
  /** @private */
  this._maxWorkers = options && options.maxWorkers || 1;
  
  /** @private */
  this._suspended = false;
  
  /**
   * @private
   * @type {!Array<{resolve:function(*)}>}
   */
  this._idleWaiters = [];
};

/**
 * @const
 */
wrm.util.TaskQueue.DEFAULT_PRIORITY = 0;

/**
 * @template R
 * @param {function():(!Promise<R>)|function():R} work
 * @param {number=} priority
 * @return {!Promise<R>}
 */
wrm.util.TaskQueue.prototype.post = function(work, priority) {
  var thisQueue = this;
  
  return new Promise(function(resolve, reject) {
    var task = {work:work, priority:wrm.util.TaskQueue.DEFAULT_PRIORITY, resolve:resolve, reject:reject};
    thisQueue._enqueueTask(task);
  });
  
};

/**
 * @private
 * @param {{work:(function():?), priority:number, resolve:function(*), reject:function(*)}} task
 */
wrm.util.TaskQueue.prototype._enqueueTask = function(task) {
  
  /* Find the last task with a lower priority */
  var index = 0;
  for (var i = this._tasks.length - 1;i >= 0;i--) {
    if (this._tasks[i].priority >= task.priority) {
      index = i + 1;
      break;
    }
  }
  
  /* Insert or push at last position */
  this._tasks.splice(index, 0, task);
  
  /* Start one more worker (if already at the limit, no harm is done) */
  this._startWorker();
};

/**
 * @return {undefined}
 */
wrm.util.TaskQueue.prototype.suspend = function() {
  this._suspended = true;
  
  /* The workers will terminate gracefully by themselves */
};

/**
 * @return {undefined}
 */
wrm.util.TaskQueue.prototype.resume = function() {
  if (!this._suspended) {
    return;
  }
  this._suspended = false;
  
  /* Start as many workers as possible (should overflow the limit, no harm is done anyway) */
  var workerCount = Math.min(this._maxWorkers - this._activeWorkers, this._tasks.length);
  for (var i = 0;i < workerCount;i++) {
    this._startWorker();
  }
};

/**
 * @return {boolean}
 */
wrm.util.TaskQueue.prototype.isSuspended = function() {
  return this._suspended;
};

/**
 * @return {boolean}
 */
wrm.util.TaskQueue.prototype.isIdle = function() {
  return this._activeWorkers <= 0 && this._tasks.length <= 0;
};

/**
 * @private
 * @return {undefined}
 */
wrm.util.TaskQueue.prototype._startWorker = function() {
  if (this._suspended) {
    return;
  }
  if (this._activeWorkers < this._maxWorkers) {
    this._activeWorkers++;
    this._work();
  }
};

/**
 * @private
 * @return {undefined}
 */
wrm.util.TaskQueue.prototype._work = function() {
  var thisQueue = this;
  
  /* Stop working if nothing more to do */
  if (this._tasks.length <= 0) {
    this._activeWorkers--;
    if (this.isIdle()) {
      this._notifyIdleWaiters();
    }
    return;
  }
  
  /* Execute the next task at the front of the queue */
  var task = this._tasks.shift();
  Promise.resolve().then(function() {
    return task.work();
  }).then(function(result) {
    task.resolve(result);
  }, function(e) {
    task.reject(e);
  }).then(function() {
    thisQueue._work();
  });
};

/**
 * @return {!Promise}
 */
wrm.util.TaskQueue.prototype.waitForIdle = function() {
  if (this.isIdle()) {
    return Promise.resolve();
  }
  var idleWaiters = this._idleWaiters;
  return new Promise(function(resolve, reject) {
    idleWaiters.push({resolve:resolve});
  });
};

/**
 * @private
 * @return {undefined}
 */
wrm.util.TaskQueue.prototype._notifyIdleWaiters = function() {
  if (this._idleWaiters.length <= 0) {
    return;
  }
  var waiters = this._idleWaiters;
  this._idleWaiters = [];
  waiters.forEach(function(waiter) {
    waiter.resolve(undefined);
  });
};

/** @override */
wrm.util.TaskQueue.prototype.toString = function() {
  return "TaskQueue with " + this._tasks.length + " tasks";
};




//== wrm/data/sync/EntitySynchronizer.js ======================================



/**
 * @package
 * @constructor
 * @param {!wrm.core.ServerStore} serverStore
 * @param {string} token
 * @param {boolean} waitForAllValues
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.sync.ObjectPusher} pusher
 * @param {!wrm.data.sync.ObjectPuller} puller
 * @param {!wrm.data.sync.DataTrackerService} dataTrackerService
 * @param {!wrm.core.BackEndService} backEndService
 * @param {!wrm.util.TaskQueue} binaryValueProcessQueue
 * @param {!wrm.data.Purger} purger
 * @param {!wrm.data.sync.KeyResolver} keyResolver
 * @param {!wrm.data.DataRunner} dataRunner
 * @param {!wrm.data.ChangeListener} blobCacheListener
 * @param {function():!Promise} permitWaiter
 * @param {!wrm.core.Manager} manager
 */
wrm.data.sync.EntitySynchronizer = function(serverStore, token, waitForAllValues, dataContext, pusher, puller, dataTrackerService, backEndService, binaryValueProcessQueue, purger, keyResolver, dataRunner, blobCacheListener, permitWaiter, manager) {
  
  /** @private */
  this._serverStore = serverStore;
  
  /** @private */
  this._entity = serverStore.getEntity();
  
  /** @private */
  this._token = token;
  
  /** @private */
  this._waitForAllValues = waitForAllValues;
  
  /** @private */
  this._dataContext = dataContext;
  
  /** @private */
  this._pusher = pusher;
  
  /** @private */
  this._puller = puller;
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  /** @private */
  this._binaryValueProcessQueue = binaryValueProcessQueue;
  
  /** @private */
  this._purger = purger;
  
  /** @private */
  this._keyResolverListener = keyResolver.createChangeListener();
  
  /** @private */
  this._blobCacheListener = blobCacheListener;
  
  /**
   * @private
   * @type {!Object<string,!wrm.data.sync.AssociationAligner>}
   */
  this._assocAligners = {};
  
  /** @private */
  this._assocsAligner = this._createAssociationSetAligner(keyResolver, dataRunner);
  
  /** @private */
  this._concurrency = +Infinity;
  
  /** @private */
  this._selectConcurrency = +Infinity;
  
  /** @private */
  this._log = manager.getPlatform().createLog("wrm.data.sync.EntitySynchronizer", "[" + this._entity + "]");
  
  /** @private */
  this._permitWaiter = permitWaiter;
  
  /*
   * Per-synchronization state
   */
  
  /**
   * @private
   * @type {?wrm.data.DateTime}
   */
  this._sinceTimestamp = null;
  
  /**
   * @private
   * @type {boolean}
   */
  this._includeOutbound = true;
  
  /**
   * @private
   * @type {boolean}
   */
  this._includeInbound = true;
  
  /**
   * @private
   * @type {?wrm.data.DateTime}
   */
  this._fetchTimestamp = null;
  
  /**
   * @private
   * @type {boolean}
   */
  this._changed = false;
  
  /**
   * @private
   * @type {!Array<!wrm.util.PromisedValue>}
   */
  this._promisedValues = [];
  
};

/**
 * @private
 * @param {!wrm.data.sync.KeyResolver} keyResolver
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {!wrm.data.sync.AssociationSetAligner}
 */
wrm.data.sync.EntitySynchronizer.prototype._createAssociationSetAligner = function(keyResolver, dataRunner) {
  
  var entity = this._entity;
  
  /*
   * Get an aligner for each association attached to the entity via one of its roles. Keep a set for not counting an association more
   * than once (for example in the case of self-associations over a single entity).
   */
  var assocIds = {};
  var aligners = [];
  entity.getRoles().forEach(function(role) {
    
    /* Skip roles that do not lead to a server-mapped entity */
    if (!role.getInverseEntity().getServerName()) {
      return;
    }
    
    /* Retrieve role association, ignoring duplicates */
    var assoc = role.getAssociation();
    var assocId = assoc.getId();
    if (assocIds[assocId] === true) {
      return;
    }
    assocIds[assocId] = true;
    
    /* Reuse or create an association aligner */
    var aligner = this._assocAligners[assocId];
    if (!aligner) {
      aligner = new wrm.data.sync.AssociationAligner(assoc, keyResolver, this._purger, dataRunner);
      this._assocAligners[assocId] = aligner;
    }
    aligners.push(aligner);
  }, this);
  
  return new wrm.data.sync.AssociationSetAligner(aligners);
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.sync.EntitySynchronizer.prototype.getEntity = function() {
  return this._entity;
};

/*
 * Monitor
 */

/**
 * @param {!wrm.data.sync.Synchronizer.Monitor} monitor
 */
wrm.data.sync.EntitySynchronizer.prototype.setMonitor = function(monitor) {
  var EntitySynchronizer = wrm.data.sync.EntitySynchronizer;
  
  /* Prepare a worker that uses a 1-place queue (actually, it is a semaphore) */
  var atomicWorker = {fn:function() {
    var atomicQueue = new wrm.util.TaskQueue({maxWorkers:1});
    return function(fn) {
      return atomicQueue.post(fn.bind(this));
    };
  }(), inUse:false};
  
  /* Prepare a worker for network activity, tied to the external monitor */
  var networkWorker = {fn:monitor.workWithNetwork, inUse:false};
  
  /*
   * Atomic and tied to permits - Some methods must be run atomically because of the use of JayData, which does not support
   * parallelism. In addition, some methods require external permits to orchestrate with the synchronization of OTHER entities and
   * ensuring that all requirements for this entity are met.
   */
  this._doSerialSynchronization = this._monitorFunction(EntitySynchronizer.prototype._doSerialSynchronization, "_doSerialSynchronization", atomicWorker, this._permitWaiter);
  this._doSynchronizeOutbound = this._monitorFunction(EntitySynchronizer.prototype._doSynchronizeOutbound, "_doSynchronizeOutbound", atomicWorker, this._permitWaiter);
  this._finalizeUpdateAtomic = this._monitorFunction(EntitySynchronizer.prototype._finalizeUpdateAtomic, "_finalizeUpdateAtomic", atomicWorker);
  
  /* Network */
  this._fetchDiff = this._monitorFunction(EntitySynchronizer.prototype._fetchDiff, "_fetchDiff", networkWorker);
  this._fetchVisibleServerKeysDiff = this._monitorFunction(EntitySynchronizer.prototype._fetchVisibleServerKeysDiff, "_fetchVisibleServerKeysDiff", networkWorker);
  this._postCreateChange = this._monitorFunction(EntitySynchronizer.prototype._postCreateChange, "_postCreateChange", networkWorker);
  this._postDeleteChange = this._monitorFunction(EntitySynchronizer.prototype._postDeleteChange, "_postDeleteChange", networkWorker);
  this._postUpdateChange = this._monitorFunction(EntitySynchronizer.prototype._postUpdateChange, "_postUpdateChange", networkWorker);
};

/**
 * @private
 * @template R, F
 * @param {F} fn
 * @param {string} traceName
 * @param {{fn:function(function():R),inUse:boolean}} worker
 * @param {function():(!Promise)=} waiter
 * @return {F}
 */
wrm.data.sync.EntitySynchronizer.prototype._monitorFunction = function(fn, traceName, worker, waiter) {
  var $jscomp$this = this;
  
  /* Normalize the waiter function */
  if (!waiter) {
    waiter = function() {
      var resolvedPromise = Promise.resolve();
      return function() {
        return resolvedPromise;
      };
    }();
  } else {
    
    /* Add tracing to the passed waiter */
    if (TRACE) {
      var origWaiter = waiter;
      waiter = function() {
        $jscomp$this._log.debug(traceName, "awaiting permit");
        return origWaiter().finally(function() {
          $jscomp$this._log.debug(traceName, "granted permit");
        });
      };
    }
  }
  
  return function() {
    var $jscomp$this = this;
    if (worker.inUse) {
      return fn.apply(this, arguments);
    }
    
    var origThis = this;
    var origArgs = arguments;
    return waiter().then(function() {
      if (TRACE) {
        $jscomp$this._log.debug(traceName, "awaiting worker");
      }
      return worker.fn(function() {
        if (TRACE) {
          $jscomp$this._log.debug(traceName, "acquired worker");
        }
        worker.inUse = true;
        return fn.apply(origThis, origArgs);
      }).finally(function() {
        worker.inUse = false;
        if (TRACE) {
          $jscomp$this._log.debug(traceName, "released worker");
        }
      });
    });
  };
};

/**
 * @param {number} concurrency
 * @param {number} selectConcurrency
 */
wrm.data.sync.EntitySynchronizer.prototype.setConcurrency = function(concurrency, selectConcurrency) {
  this._concurrency = concurrency;
  this._selectConcurrency = selectConcurrency;
  
  this._assocsAligner.setSelectConcurrency(selectConcurrency);
};

/**
 * @private
 * @param {{since:(?wrm.data.DateTime|undefined), outbound:(boolean|undefined), inbound:(boolean|undefined)}=} options
 */
wrm.data.sync.EntitySynchronizer.prototype._reset = function(options) {
  this._sinceTimestamp = options && options.since || null;
  this._includeOutbound = options ? options.outbound !== false : true;
  this._includeInbound = options ? options.inbound !== false : true;
  this._changed = false;
  this._promisedValues = [];
  this._fetchTimestamp = null;
};

/**
 * @param {!wrm.util.ProgressMonitor} pm
 * @param {{since:(?wrm.data.DateTime|undefined), outbound:(boolean|undefined), inbound:(boolean|undefined)}=} options
 * @return {!Promise<{timestamp:?wrm.data.DateTime, changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype.synchronize = function(pm, options) {
  var thisEntitySynchronizer = this;
  var dataContext = this._dataContext;
  var keyResolverListener = this._keyResolverListener;
  var blobCacheListener = this._blobCacheListener;
  var purger = this._purger;
  var log = this._log;
  
  /* Reset the per-synchronization state */
  this._reset(options);
  
  log.info("Synchronizing", "(" + this._computeDescription() + ")");
  
  pm.resize((thisEntitySynchronizer._includeOutbound ? 1 : 0) + (thisEntitySynchronizer._includeInbound ? 115 : 0) + 2);
  
  dataContext.addChangeListener(keyResolverListener);
  dataContext.addChangeListener(blobCacheListener);
  dataContext.setExposedMetaAttributes("serverFileId");
  dataContext.setExposedMetaAttributes("status");
  
  /* Synchronize outbound changes of instances */
  var promise = Promise.resolve().then(function() {
    if (thisEntitySynchronizer._includeOutbound) {
      return thisEntitySynchronizer._doSynchronizeOutbound(pm.sub(1));
    }
  });
  
  /* Synchronize inbound changes of instances and align associations */
  promise = promise.then(function() {
    if (thisEntitySynchronizer._includeInbound) {
      return thisEntitySynchronizer._fetchDiff(pm.sub(5)).then(function(diff) {
        return thisEntitySynchronizer._doSerialSynchronization(diff, pm.sub(110));
      });
    }
  });
  
  /* Take the chance to purge data (e.g. from association alignment) */
  promise = promise.then(function() {
    return purger.purge(dataContext, pm.sub(2));
  });
  
  /* Cleanup in all cases */
  promise = promise.finally(function() {
    thisEntitySynchronizer._assocsAligner.reset();
    dataContext.removeChangeListener(blobCacheListener);
    dataContext.removeChangeListener(keyResolverListener);
    pm.done();
  });
  
  /* Return the new timestamp if all went right, otherwise the old one */
  return promise.then(function() {
    return {timestamp:thisEntitySynchronizer._fetchTimestamp || thisEntitySynchronizer._sinceTimestamp, changed:thisEntitySynchronizer._changed, promisedValues:thisEntitySynchronizer._promisedValues};
  });
};

/**
 * @private
 * @return {string}
 */
wrm.data.sync.EntitySynchronizer.prototype._computeDescription = function() {
  var inboundLimitation = this._sinceTimestamp ? "differentially since " + this._sinceTimestamp : "fully";
  if (this._includeInbound && this._includeOutbound) {
    return inboundLimitation;
  } else {
    if (this._includeInbound) {
      return "inbound only, " + inboundLimitation;
    } else {
      if (this._includeOutbound) {
        return "outbound only";
      }
    }
  }
  return "no-op";
};

/**
 * @private
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._doSynchronizeOutbound = function(pm) {
  var thisEntitySynchronizer = this;
  var entity = this._entity;
  var dataContext = this._dataContext;
  var log = this._log;
  var stats = new wrm.data.sync.EntitySyncStats;
  var hadChanges = false;
  
  /* Iterate and process all outbound changes */
  var changeCollector = this._dataTrackerService.createChangeCollector(dataContext, entity);
  var promise = function processChange() {
    return changeCollector.next().then(function(change) {
      if (!change) {
        return;
      }
      hadChanges = true;
      
      /* Post the change and get the resulting differences */
      var promise = Promise.resolve().then(function() {
        return thisEntitySynchronizer._postChange((change));
      });
      
      /* Apply the resulting differences to the entity */
      promise = promise.then(function(diff) {
        return thisEntitySynchronizer._applyDiff(diff, stats, false, "resulting", true, wrm.util.FakeProgressMonitor.INSTANCE);
      });
      
      return promise.then(function() {
        return processChange();
      });
    });
  }();
  
  return promise.then(function() {
    pm.done();
    if (hadChanges) {
      log.debug("Resulting differences applied", ":", stats);
    }
  }, function(e) {
    log.error("Error in outbound synchronization", e);
    throw e;
  });
};

/**
 * @private
 * @param {!wrm.data.sync.EntityDiff} diff
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._doSerialSynchronization = function(diff, pm) {
  var thisEntitySynchronizer = this;
  
  /* Synchronize inbound changes of instances */
  var promise = Promise.resolve().then(function() {
    return thisEntitySynchronizer._doSynchronizeInbound(diff, pm.sub(20));
  });
  
  /* Align associations attached to the entity */
  promise = promise.then(function() {
    return thisEntitySynchronizer._doAlignAssociations(pm.sub(80));
  });
  
  promise = promise.then(function() {
    thisEntitySynchronizer._fetchTimestamp = diff.timestamp;
  });
  
  return promise;
};

/**
 * @private
 * @param {!wrm.data.sync.EntityDiff} diff
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._doSynchronizeInbound = function(diff, pm) {
  var thisEntitySynchronizer = this;
  var log = this._log;
  
  var stats = new wrm.data.sync.EntitySyncStats;
  
  /* Apply differences to the entity */
  var promise = Promise.resolve().then(function() {
    return thisEntitySynchronizer._applyDiff(diff, stats, true, "inbound", false, pm.sub(75));
  });
  
  /* Fetch additional differences in visible keys (must be done AFTER the first apply) */
  promise = promise.then(function() {
    return thisEntitySynchronizer._fetchVisibleServerKeysDiff(diff.serverKeysHash, pm.sub(5));
  });
  
  /* Apply visibility differences to the entity */
  promise = promise.then(function(visibilityDiff) {
    return thisEntitySynchronizer._applyDiff(visibilityDiff, stats, false, null, false, pm.sub(20));
  });
  
  return promise.then(function() {
    log.debug("Inbound differences applied", ":", stats);
  }, function(e) {
    if (e.message.indexOf("operation is not allowed on class") !== -1) {
      log.debug("Skipped synchronization of due to missing permission");
      throw e;
    }
    log.error("Error in inbound synchronization", e);
    throw e;
  });
};

/**
 * @private
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 */
wrm.data.sync.EntitySynchronizer.prototype._doAlignAssociations = function(pm) {
  var $jscomp$this = this;
  var assocsAligner = this._assocsAligner;
  var log = this._log;
  
  /* Apply changes to each association */
  var changed = false;
  var aligners = assocsAligner.getAligners();
  pm.resize(aligners.length);
  var promise = assocsAligner.getAligners().reduce(function(chain, aligner) {
    var assoc = aligner.getAssociation();
    var stats = new wrm.data.sync.AssociationSyncStats;
    
    /* Apply differences to the association */
    chain = chain.then(function() {
      log.debug("Aligning association", assoc);
      return aligner.save($jscomp$this._dataContext, $jscomp$this._concurrency, stats);
    }).then(function() {
      return aligner.align($jscomp$this._dataContext, $jscomp$this._concurrency, stats);
    });
    
    return chain.then(function() {
      log.debug("Aligned association", assoc, ":", stats);
      changed = changed || stats.hasChanges();
      pm.worked(1);
    }, function(e) {
      log.error("Error in alignment of association", assoc, e);
      throw e;
    });
    
  }, Promise.resolve());
  
  return promise.then(function() {
    $jscomp$this._changed |= changed;
    pm.done();
  });
};

/*
 * Posting of Changes
 */

/**
 * @private
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise<!wrm.data.sync.EntityDiff>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._postChange = function(change) {
  this._log.debug("Posting", change);
  var ChangeType = wrm.data.sync.DataTrackerService.Change.Type;
  switch(change.getType()) {
    case ChangeType.CREATE:
      return this._postCreateChange(change);
    case ChangeType.UPDATE:
      return this._postUpdateChange(change);
    case ChangeType.DELETE:
      return this._postDeleteChange(change);
    default:
      throw new Error("Invalid change");;
  }
};

/**
 * @private
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise<!wrm.data.sync.EntityDiff>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._postCreateChange = function(change) {
  var thisEntitySynchronizer = this;
  var key = change.getKey();
  
  /* Create on the back-end */
  return Promise.resolve().then(function() {
    return thisEntitySynchronizer._prepareOutboundServerRecord(change);
  }).then(function(outboundRecord) {
    return thisEntitySynchronizer._serverStore.createEntityInstance(thisEntitySynchronizer._token, outboundRecord);
  }).then(function(record) {
    return thisEntitySynchronizer._finalizeOutboundValues(record, change).then(function() {
      
      /* Treat the resulting record as an "update" inbound difference */
      record["__KEY"] = key;
      return wrm.data.sync.EntityDiff.createFixed(null, [record], []);
    });
  });
};

/**
 * @private
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise<!wrm.data.sync.EntityDiff>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._postUpdateChange = function(change) {
  var thisEntitySynchronizer = this;
  var key = change.getKey();
  var serverKey = change.getServerKey();
  if (serverKey === null) {
    throw new Error("Server key required for posting an update");
  }
  
  /* Update on the back-end */
  return Promise.resolve().then(function() {
    return thisEntitySynchronizer._prepareOutboundServerRecord(change);
  }).then(function(outboundRecord) {
    if (outboundRecord) {
      return thisEntitySynchronizer._serverStore.updateEntityInstance(thisEntitySynchronizer._token, serverKey, outboundRecord);
    } else {
      return null;
    }
  }).then(function(record) {
    return thisEntitySynchronizer._finalizeOutboundValues(record, change).then(function() {
      if (!record) {
        return wrm.data.sync.EntityDiff.empty();
      }
      
      /* Treat the resulting record as an "update" inbound difference */
      record["__KEY"] = key;
      return wrm.data.sync.EntityDiff.createFixed(null, [record], []);
    });
  }, function(e) {
    
    /* Treat "not found" errors as a "delete" inbound difference */
    if (e instanceof wrm.core.NotFoundError) {
      return wrm.data.sync.EntityDiff.createFixed(null, [], [serverKey]);
    }
    
    throw e;
  });
};

/**
 * @private
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise<!wrm.data.sync.EntityDiff>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._postDeleteChange = function(change) {
  var serverKey = change.getServerKey();
  if (serverKey === null) {
    throw new Error("Server key required for posting a delete");
  }
  
  /* Delete on the back-end */
  return this._serverStore.deleteEntityInstance(this._token, serverKey).then(function() {
    
    /* No resulting difference */
    return wrm.data.sync.EntityDiff.createFixed(null, [], []);
  });
};

/**
 * @private
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise<!Object>}
 */
wrm.data.sync.EntitySynchronizer.prototype._prepareOutboundServerRecord = function(change) {
  var ChangeType = wrm.data.sync.DataTrackerService.Change.Type;
  if (change.getType() === ChangeType.DELETE) {
    return Promise.resolve(({}));
  }
  var thisEntitySynchronizer = this;
  var ObjectPusher = wrm.data.sync.ObjectPusher;
  var entity = change.getEntity();
  var attributeValues = change.getAttributeValues();
  var roleAddedServerKeys = change.getRoleAddedServerKeys();
  var roleRemovedServerKeys = change.getRoleRemovedServerKeys();
  
  var result = {};
  var oneFieldSet = false;
  var promise = Promise.resolve();
  
  /* Include all changed attribute values */
  if (attributeValues) {
    promise = promise.then(function() {
      return thisEntitySynchronizer._pusher.prepareRecordValues((attributeValues), change.getKey(), thisEntitySynchronizer._token, thisEntitySynchronizer._dataContext);
    }).then(function(attrRecordValues) {
      if (attrRecordValues) {
        angular.extend(result, attrRecordValues);
        oneFieldSet = true;
      }
    });
  }
  
  /* Include changed far keys of all mapped roles */
  entity.getRoles().forEach(function(role) {
    var roleServerName = role.getServerName();
    if (!roleServerName) {
      return;
    }
    
    var addedServerKeys = roleAddedServerKeys[role.getId()];
    var removedServerKeys = roleRemovedServerKeys[role.getId()];
    if (addedServerKeys && addedServerKeys.length > 0 || removedServerKeys && removedServerKeys.length > 0) {
      var farServerKeyAttr = role.getInverseEntity().getServerKeyAttribute();
      var roleDelta = {};
      if (addedServerKeys && addedServerKeys.length > 0) {
        roleDelta["added"] = addedServerKeys.map(function(serverKey) {
          return ObjectPusher.convertToRecordValue(farServerKeyAttr.getType(), serverKey);
        });
      }
      if (removedServerKeys && removedServerKeys.length > 0) {
        roleDelta["removed"] = removedServerKeys.map(function(serverKey) {
          return ObjectPusher.convertToRecordValue(farServerKeyAttr.getType(), serverKey);
        });
      }
      result[roleServerName] = roleDelta;
      oneFieldSet = true;
    }
  });
  
  return promise.then(function() {
    return oneFieldSet || change.getType() === ChangeType.CREATE ? result : null;
  });
};

/**
 * @private
 * @param {!Object} resultRecord
 * @param {!wrm.data.sync.DataTrackerService.Change} change
 * @return {!Promise}
 */
wrm.data.sync.EntitySynchronizer.prototype._finalizeOutboundValues = function(resultRecord, change) {
  if (change.getType() === wrm.data.sync.DataTrackerService.Change.Type.DELETE) {
    return Promise.resolve();
  }
  
  /* Finalize all changed values */
  var attributeValues = change.getAttributeValues();
  if (attributeValues) {
    return Promise.all(this._pusher.finalizeValues(resultRecord, attributeValues, change.getKey(), this._token, this._dataContext));
  }
  
  return Promise.resolve();
};

/*
 * Fetching of differences
 */

/**
 * @private
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise<!wrm.data.sync.EntityDiff>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._fetchDiff = function(pm) {
  var thisEntitySynchronizer = this;
  var serverStore = this._serverStore;
  var sinceTimestamp = this._sinceTimestamp;
  var token = this._token;
  
  /* If the server does not allow reads, exit with a fake "no changes" result */
  if (!this._serverStore.isServerReadable()) {
    return Promise.resolve(wrm.data.sync.EntityDiff.empty());
  }
  
  this._log.debug("Fetching inbound differences");
  var promise = Promise.resolve();
  if (sinceTimestamp) {
    
    /* Retrieve the changes to entity data since the indicated date-time */
    promise = promise.then(function() {
      return serverStore.retrieveEntityData(token, sinceTimestamp);
    }).then(function(data) {
      pm.done();
      return wrm.data.sync.EntityDiff.createIterable(data.timestamp, data.recordCount, data.recordPages, data.deletedKeys, data.keysHash);
    });
    
  } else {
    
    /* Select all server keys, to consider them as deleted */
    promise = promise.then(function() {
      return thisEntitySynchronizer._selectAllServerKeys();
    });
    
    /* Retrieve the full entity data */
    promise = promise.then(function(allServerKeys) {
      pm.worked(50);
      return serverStore.retrieveEntityData(token).then(function(data) {
        pm.done();
        return wrm.data.sync.EntityDiff.createIterable(data.timestamp, data.recordCount, data.recordPages, allServerKeys, data.keysHash);
      });
    });
  }
  
  return promise;
};

/**
 * @private
 * @param {?number} remoteKeysHash
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise<!wrm.data.sync.EntityDiff>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._fetchVisibleServerKeysDiff = function(remoteKeysHash, pm) {
  var thisEntitySynchronizer = this;
  var serverStore = this._serverStore;
  var log = this._log;
  
  /* If there is no server keys hash, there is no check to make and it can be assumed that no key exited or entered our scope */
  if (remoteKeysHash === null) {
    return Promise.resolve(wrm.data.sync.EntityDiff.empty());
  }
  
  /* Compute an hash from server keys that are SAVED LOCALLY */
  return Promise.resolve().then(function() {
    return thisEntitySynchronizer._selectAllServerKeys();
  }).then(function(allLocalKeys) {
    var localKeysHash = wrm.data.sync.computeKeysHash(allLocalKeys);
    
    /* If the hashes match, no key exited nor entered our scope */
    if (localKeysHash === remoteKeysHash) {
      return wrm.data.sync.EntityDiff.empty();
    }
    
    /* Compare saved server keys against the ones known to the server */
    log.debug("Instances have changed scope -", remoteKeysHash, "!\x3d", localKeysHash);
    return serverStore.retrieveEntityKeys(thisEntitySynchronizer._token).then(function(allRemoteKeys) {
      var keysDiff = wrm.util.obj.findValuesDiff(allLocalKeys, allRemoteKeys);
      
      /* Removed keys indicate instances that exited the scope */
      var removedKeys = keysDiff.removed;
      if (removedKeys.length > 0) {
        log.debug("Found", removedKeys.length, "instances that went out of scope");
      }
      
      /* Added keys indicate instances that entered the scope: fetch their records */
      var addedKeys = keysDiff.added;
      var addedRecordsPromise;
      if (addedKeys.length > 0) {
        log.debug("Found", addedKeys.length, "instances that came into scope");
        addedRecordsPromise = addedKeys.reduce(function(chain, addedKey) {
          return chain.then(function(addedRecords) {
            return serverStore.retrieveEntityInstanceData(thisEntitySynchronizer._token, addedKey).then(function(record) {
              addedRecords.push(record);
              return addedRecords;
            }, function(e) {
              if (e instanceof wrm.core.NotFoundError) {
                return;
              }
              throw e;
            });
          });
        }, Promise.resolve([]));
      } else {
        addedRecordsPromise = Promise.resolve([]);
      }
      
      return addedRecordsPromise.then(function(addedRecords) {
        pm.done();
        return wrm.data.sync.EntityDiff.createFixed(null, addedRecords, removedKeys);
      });
    });
    
  })["catch"](function(e) {
    log.error("Error fetching differences in visible keys", e);
    throw e;
  });
};

/**
 * @private
 * @return {!Promise<!Array<*>>}
 */
wrm.data.sync.EntitySynchronizer.prototype._selectAllServerKeys = function() {
  var entity = this._entity;
  return this._select(entity.getId(), {output:entity.getServerKeyAttribute().getId()});
};

/*
 * Application of differences
 */

/**
 * @private
 * @suppress {checkTypes}
 * @param {!wrm.data.sync.EntityDiff} diff
 * @param {!wrm.data.sync.EntitySyncStats} stats
 * @param {boolean} retryDownload
 * @param {?string} method
 * @param {boolean} waitForAllValues
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.EntitySynchronizer.prototype._applyDiff = function(diff, stats, retryDownload, method, waitForAllValues, pm) {
  var $jscomp$this = this;
  var waitAllValues = waitForAllValues || this._waitForAllValues;
  
  var promise = Promise.resolve();
  
  if (method) {
    this._log.debug("Applying " + method + " differences");
  }
  
  var deleteWork = diff.deletedServerKeys.length;
  var serverRecordsWork = diff.serverRecordCount;
  var finalizeWork = Math.ceil(serverRecordsWork / 10);
  pm.resize(deleteWork + serverRecordsWork + finalizeWork);
  
  var applier = new wrm.data.sync.EntityDiffApplier(this._entity, this._token, this._dataContext, this._puller, this._binaryValueProcessQueue, this._assocsAligner, retryDownload);
  applier.setConcurrency(this._concurrency, this._selectConcurrency);
  
  /* Delete all objects indicated by deleted keys (this handles both real and "replayed" deletes) */
  promise = promise.then(function() {
    return applier.deleteObjects(diff.deletedServerKeys, stats, pm.sub(deleteWork));
  });
  
  /* Create or update objects for which there is a server record (one page at a time) */
  promise = promise.then(function() {
    return wrm.util.AsyncIterator.forEach(diff.serverRecordPages, function(serverRecords) {
      return applier.createOrUpdateObjects(serverRecords, stats, waitAllValues, pm.sub(serverRecords.length));
    });
  });
  
  /* Finalize application (e.g. this handles additional retries) */
  promise = promise.then(function() {
    return applier.finalizeApplication(stats, waitAllValues, pm.sub(finalizeWork));
  }).then(function(applyResult) {
    Array.prototype.push.apply($jscomp$this._promisedValues, applyResult.promisedValues);
  });
  
  return promise.then(function() {
    $jscomp$this._changed |= stats.hasChanges();
  });
};

/**
 * @private
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.sync.EntitySynchronizer.prototype._select = function(entityId, options, parameters) {
  return this._dataContext.select(entityId, angular.extend({}, options, {outputConfig:{useNames:true}}), parameters);
};




//== wrm/data/sync/Synchronizer.js ============================================



/**
 * @package
 * @constructor
 * @param {!wrm.data.DataService} dataService
 * @param {!wrm.data.sync.DataTrackerService} dataTrackerService
 * @param {!wrm.core.BackEndService} backEndService
 * @param {!wrm.core.Manager} manager
 */
wrm.data.sync.Synchronizer = function(dataService, dataTrackerService, backEndService, manager) {
  var _CONFIG = wrm.data.sync.Synchronizer._CONFIG;
  
  /** @private */
  this._manager = manager;
  
  /** @private */
  this._dataService = dataService;
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  /** @private */
  this._dataRunner = new wrm.data.sync.UntrackedDataRunner(dataService);
  
  /** @private */
  this._backEndService = backEndService;
  
  /** @private {!Object<string,!wrm.core.ServerStore>} */
  this._serverStoreMap = {};
  
  /** @private */
  this._jobQueue = new wrm.util.TaskQueue;
  
  /** @private */
  this._keyResolver = new wrm.data.sync.KeyResolver;
  
  /** @private */
  this._blobCache = new wrm.data.sync.BlobCache(this._dataRunner);
  
  /** @private */
  this._binaryValueProcessQueue = new wrm.util.TaskQueue({maxWorkers:_CONFIG.maxBinaryDownloads});
  
  /** @private */
  this._purger = dataService.getPurger();
  
  /** @private */
  this._log = manager.getPlatform().createLog("wrm.data.sync.Synchronizer");
  
  /** @private {?Array<string>} */
  this._preferredOrder = null;
};

/**
 * @private
 */
wrm.data.sync.Synchronizer._CONFIG = {useParallel:true, maxParallelSyncs:4, perSyncConcurrency:100, perSyncSelectConcurrencyRatio:20, maxNetworkRequests:4, maxBinaryDownloads:2};

/**
 * @package
 * @const {number}
 */
wrm.data.sync.Synchronizer.CURRENT_VERSION = 1;

/**
 * @const
 */
wrm.data.sync.Synchronizer.DEFAULT_PRIORITY = wrm.util.TaskQueue.DEFAULT_PRIORITY;

/**
 * @package
 * @param {!Array<!wrm.data.meta.Entity>} entities
 * @return {boolean}
 */
wrm.data.sync.Synchronizer.prototype.checkAvailable = function(entities) {
  var thisSynchronizer = this;
  var isAvailable = true;
  entities.forEach(function(entity) {
    if (isAvailable) {
      isAvailable = thisSynchronizer._retrieveServerStore(entity).isServerAvailable();
    }
  });
  return isAvailable;
};

/**
 * @package
 * @return {boolean}
 */
wrm.data.sync.Synchronizer.prototype.isBackgroundDownloading = function() {
  return !this._binaryValueProcessQueue.isIdle();
};

/**
 * @package
 * @param {!wrm.data.sync.Synchronizer.Job} job
 * @param {number=} priority
 * @return {!Promise<{changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}>}
 */
wrm.data.sync.Synchronizer.prototype.synchronize = function(job, priority) {
  if (typeof priority === "undefined") {
    priority = wrm.data.sync.Synchronizer.DEFAULT_PRIORITY;
  }
  return this._jobQueue.post(this._runJob.bind(this, job), priority);
};

/**
 * @package
 * @typedef {{entities:!Array<!wrm.data.meta.Entity>, outbound:boolean, inbound:boolean, token:string, waitForAllValues:boolean,
 *          progressMonitor:!wrm.util.ProgressMonitor}}
 */
wrm.data.sync.Synchronizer.Job;

/**
 * @private
 * @param {wrm.data.sync.Synchronizer.Job} job
 * @return {!Promise<{changed:boolean, changedEntities:!Array<!wrm.data.meta.Entity>, promisedValues:!Array<!wrm.util.PromisedValue>}>}
 */
wrm.data.sync.Synchronizer.prototype._runJob = function(job) {
  var thisSynchronizer = this;
  var log = this._log;
  log.info("Synchronization started");
  
  /* Suspend binary value processing (e.g. BLOB downloads) to not interfere with transactions */
  this._binaryValueProcessQueue.suspend();
  
  return this._dataRunner.execute(function(dataContext) {
    var pm = job.progressMonitor;
    
    /* Create and store all Entity Synchronizer */
    var orchestrator = thisSynchronizer._createEntityOrchestrator(job);
    var entitySynchronizers = thisSynchronizer._createEntitySynchronizers(dataContext, job, orchestrator);
    pm.resize(entitySynchronizers.length);
    
    /* Synchronize all entities. Stop only in case of "forbidden" errors. Collect other errors. */
    var failedEntities = [], failErrorClass = null, changedEntities = [], promisedValues = [], lastError = null;
    function runSyncrhonizer(entitySynchronizer) {
      var entity = entitySynchronizer.getEntity();
      return Promise.resolve().then(function() {
        return thisSynchronizer._synchronizeEntity(entitySynchronizer, job, orchestrator, pm.sub(1));
      }).then(function(result) {
        if (result.changed) {
          changedEntities.push(entity);
        }
        Array.prototype.push.apply(promisedValues, result.promisedValues);
      })["catch"](function(e) {
        if (e instanceof wrm.core.ForbiddenError) {
          var errorMessage = e.message;
          if (errorMessage === "Invalid authorization token") {
            lastError = e;
            return;
          }
          if (errorMessage.indexOf("operation is not allowed on class") !== -1) {
            return;
          }
        }
        log.error("Entity", entity, "synchronization failed", e);
        if (!failErrorClass && e instanceof wrm.core.NetworkError) {
          failErrorClass = wrm.core.NetworkError;
        }
        failedEntities.push(entity);
      });
    }
    var promise;
    if (wrm.data.sync.Synchronizer._CONFIG.useParallel) {
      promise = Promise.all(entitySynchronizers.map(runSyncrhonizer));
    } else {
      promise = entitySynchronizers.reduce(function(chain, entitySynchronizer) {
        return chain.then(function() {
          return runSyncrhonizer(entitySynchronizer);
        });
      }, Promise.resolve());
    }
    promise = promise.then(function() {
      if (lastError) {
        throw lastError;
      }
    });
    
    /* Always cleanup after the core job */
    promise = promise.finally(function() {
      thisSynchronizer._keyResolver.clear();
      Promise.all(promisedValues).then(function() {
        thisSynchronizer._blobCache.clear();
      });
      thisSynchronizer._binaryValueProcessQueue.resume();
      pm.done();
    });
    
    /* Report errors occurred during synchronization as a single error */
    return promise.then(function() {
      if (failedEntities.length > 0) {
        throw new (failErrorClass || Error)("The following entities failed to synchronize: " + failedEntities);
      }
      return {changed:changedEntities.length > 0, changedEntities:changedEntities, promisedValues:promisedValues};
    });
  }, true).then(function(result) {
    if (result.changed > 0) {
      log.info("Synchronization finished - Changed local data of", result.changedEntities);
    } else {
      log.info("Synchronization finished - No changes to local data");
    }
    return result;
  })["catch"](function(e) {
    if (e instanceof wrm.core.ForbiddenError) {
      log.info("Synchronization halted (forbidden)");
    } else {
      log.error("Synchronization failed:", e);
    }
    throw e;
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @return {boolean}
 */
wrm.data.sync.Synchronizer.prototype.hasServerStore = function(entity) {
  return !!this._retrieveServerStore(entity);
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.core.ServerStore} serverStore
 */
wrm.data.sync.Synchronizer.prototype.registerServerStore = function(entity, serverStore) {
  this._serverStoreMap[entity.getId()] = serverStore;
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {?wrm.core.ServerStore}
 */
wrm.data.sync.Synchronizer.prototype._retrieveServerStore = function(entity) {
  return this._serverStoreMap[entity.getId()] || null;
};

/**
 * @package
 * @param {?Array<!wrm.data.meta.Entity>} entities
 */
wrm.data.sync.Synchronizer.prototype.setPreferredOrder = function(entities) {
  if (entities) {
    this._preferredOrder = entities.map(function(entity) {
      return entity.getId();
    });
  } else {
    this._preferredOrder = null;
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Promise<boolean>}
 */
wrm.data.sync.Synchronizer.prototype.hasOutboundChanges = function(entity) {
  var thisSynchronizer = this;
  return this._dataRunner.execute(function(dataContext) {
    var changeCollector = thisSynchronizer._dataTrackerService.createChangeCollector(dataContext, entity);
    return changeCollector.next().then(function(firstChange) {
      return !!firstChange;
    });
  });
};

/**
 * @private
 * @param {!wrm.data.sync.Synchronizer.Job} job
 * @return {!wrm.data.sync.EntityOrchestrator}
 */
wrm.data.sync.Synchronizer.prototype._createEntityOrchestrator = function(job) {
  var _CONFIG = wrm.data.sync.Synchronizer._CONFIG;
  var log = this._log;
  var preferredOrder = this._preferredOrder;
  
  /* Get all entities to synchronize, enforcing a preferred order if asked to */
  var entities = job.entities.slice();
  if (preferredOrder) {
    entities.forEach(function(entity) {
      if (preferredOrder.indexOf(entity.getId()) < 0) {
        log.warn("No order specified for", entity);
      }
    });
    entities.sort(function(entity1, entity2) {
      var i1 = preferredOrder.indexOf(entity1.getId());
      var i2 = preferredOrder.indexOf(entity2.getId());
      return i1 - i2;
    });
  }
  
  return new wrm.data.sync.EntityOrchestrator(entities, !!preferredOrder, _CONFIG.maxParallelSyncs);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.sync.Synchronizer.Job} job
 * @param {!wrm.data.sync.EntityOrchestrator} orchestrator
 * @return {!Array<!wrm.data.sync.EntitySynchronizer>}
 */
wrm.data.sync.Synchronizer.prototype._createEntitySynchronizers = function(dataContext, job, orchestrator) {
  var _CONFIG = wrm.data.sync.Synchronizer._CONFIG;
  
  /*
   * Work on all the entities. In SERIAL mode, use sorted entities so that the resulting entity synchronizers are sorted as well. Not
   * doing so would cause an immediate deadlock as the first entity synchronizer requires entities that are queued behind it.
   */
  var entities = _CONFIG.useParallel ? orchestrator.getEntities() : orchestrator.getSortedEntities();
  
  /* Create a synchronizer for each entity */
  var monitor = new wrm.data.sync.Synchronizer.Monitor;
  var result = [];
  entities.forEach(function(entity) {
    
    /* Do not synchronize un-mapped entities */
    var serverStore = this._retrieveServerStore(entity);
    if (!serverStore) {
      return;
    }
    
    var blobCacheListener = this._blobCache.createChangeListener();
    var pusher = new wrm.data.sync.ObjectPusher(entity, this._dataRunner, this._backEndService, this._log);
    var puller = new wrm.data.sync.ObjectPuller(entity, this._dataRunner, this._backEndService, this._log);
    puller.setBlobCache(this._blobCache);
    puller.setBinaryValueProcessQueue(this._binaryValueProcessQueue);
    
    var permitWaiter = orchestrator.notifySynchronizationStarted.bind(orchestrator, entity);
    var entitySynchronizer = new wrm.data.sync.EntitySynchronizer(serverStore, job.token, job.waitForAllValues, dataContext, pusher, puller, this._dataTrackerService, this._backEndService, this._binaryValueProcessQueue, this._purger, this._keyResolver, this._dataRunner, blobCacheListener, permitWaiter, this._manager);
    
    entitySynchronizer.setMonitor(monitor);
    entitySynchronizer.setConcurrency(_CONFIG.perSyncConcurrency, Math.max(1, Math.round(_CONFIG.perSyncConcurrency / _CONFIG.perSyncSelectConcurrencyRatio)));
    result.push(entitySynchronizer);
  }, this);
  return result;
};

/*
 * Single-entity synchronization logic
 */

/**
 * @private
 * @param {!wrm.data.sync.EntitySynchronizer} entitySynchronizer
 * @param {wrm.data.sync.Synchronizer.Job} job
 * @param {!wrm.data.sync.EntityOrchestrator} orchestrator
 * @param {!wrm.util.ProgressMonitor} pm
 * @return {!Promise<{changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is not valid).
 */
wrm.data.sync.Synchronizer.prototype._synchronizeEntity = function(entitySynchronizer, job, orchestrator, pm) {
  var thisSynchronizer = this;
  var entity = entitySynchronizer.getEntity();
  
  /* Synchronize since last timestamp, then save the new timestamp (unless an error occurs) */
  var since = this.getLastSynchronizationDateTime(entity);
  var promise = entitySynchronizer.synchronize(pm, {since:since, outbound:job.outbound, inbound:job.inbound}).then(function(result) {
    thisSynchronizer._setLastSynchronizationDateTime(entity, result.timestamp);
    return result;
  });
  return promise.finally(function() {
    orchestrator.notifySynchronizationFinished(entity);
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @return {?wrm.data.DateTime}
 */
wrm.data.sync.Synchronizer.prototype.getLastSynchronizationDateTime = function(entity) {
  var dict = this._dataService.getAuxiliaryDictionary();
  var s = dict.get(entity.getId() + ".lastSync");
  return s ? wrm.data.DateTime.fromString(s) : null;
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {?wrm.data.DateTime} dateTime
 */
wrm.data.sync.Synchronizer.prototype._setLastSynchronizationDateTime = function(entity, dateTime) {
  var dict = this._dataService.getAuxiliaryDictionary();
  if (dateTime) {
    dict.set(entity.getId() + ".lastSync", dateTime.toString());
    wrm.nav.SystemValues.lastSynchronizationTimestamp = dateTime;
  } else {
    dict.remove(entity.getId() + ".lastSync");
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 */
wrm.data.sync.Synchronizer.prototype.clearLastSynchronizationDateTime = function(entity) {
  this._setLastSynchronizationDateTime(entity, null);
};

/*
 * Monitor
 */

/**
 * @package
 * @constructor
 */
wrm.data.sync.Synchronizer.Monitor = function() {
  var _CONFIG = wrm.data.sync.Synchronizer._CONFIG;
  
  var networkQueue = new wrm.util.TaskQueue({maxWorkers:_CONFIG.maxNetworkRequests});
  
  /**
   * @template R
   * @param {function():R} fn
   * @return {!Promise<R>}
   */
  this.workWithNetwork = function(fn) {
    return networkQueue.post(fn.bind(this));
  };
};

/*
 * Clearing Outgoing Changes
 */

/**
 * @package
 * @param {!wrm.data.meta.RegularEntity} entity
 * @return {!Promise}
 */
wrm.data.sync.Synchronizer.prototype.clearOutgoingChanges = function(entity) {
  var thisSynchronizer = this;
  return this._dataService.execute(function(d) {
    var changeCollector = thisSynchronizer._dataTrackerService.createChangeCollector(d, entity);
    return function processChange() {
      return changeCollector.next().then(function(change) {
        if (!change) {
          return;
        }
        return processChange();
      });
    }();
  });
};




//== wrm/nav/Event.js =========================================================


/**
 * @constructor
 * @param {string} type
 * @param {?string=} specifier
 * @param {!Object.<string,*>=} parameters
 */
wrm.nav.Event = function(type, specifier, parameters) {
  
  /** @private */
  this._type = type;
  
  /** @private */
  this._specifier = specifier || null;
  
  /** @private */
  this._parameters = parameters || {};
  
  /**
   * @private
   * @type {wrm.Service}
   */
  this._target = null;
  
};

/**
 * @return {string}
 */
wrm.nav.Event.prototype.getName = function() {
  return this._specifier ? this._type + "." + this._specifier : this._type;
};

/**
 * @return {string}
 */
wrm.nav.Event.prototype.getType = function() {
  return this._type;
};

/**
 * @return {?string}
 */
wrm.nav.Event.prototype.getSpecifier = function() {
  return this._specifier;
};

/**
 * @return {!Object.<string,*>}
 */
wrm.nav.Event.prototype.getParameters = function() {
  return this._parameters;
};
/**
 * @param {!wrm.Service} target
 */
wrm.nav.Event.prototype.initTarget = function(target) {
  if (this._target) {
    throw new Error("Event already dispatched to a target");
  }
  this._target = target;
};
/**
 * @return {wrm.Service}
 */
wrm.nav.Event.prototype.getTarget = function() {
  return this._target;
};

/** @override */
wrm.nav.Event.prototype.toString = function() {
  return this.getName() + " " + JSON.stringify(this._parameters);
};




//== wrm/nav/Progress.js ======================================================


/**
 * @constructor
 * @param {?string} message
 */
wrm.nav.Progress = function(message) {
  
  /** @private */
  this._message = message;
};

/**
 * @return {?string}
 */
wrm.nav.Progress.prototype.getMessage = function() {
  return this._message;
};

/** @override */
wrm.nav.Progress.prototype.toString = function() {
  return 'Progress:"' + this._message + '"';
};




//== wrm/util/DefaultProgressMonitor.js =======================================



/**
 * @constructor
 * @implements {wrm.util.ProgressMonitor}
 * @param {function(number)} callback
 * @param {number=} minInterval
 */
wrm.util.DefaultProgressMonitor = function(callback, minInterval) {
  var $jscomp$this = this;
  
  /** @private */
  this._callback = callback;
  
  /** @private */
  this._minInterval = minInterval !== undefined ? minInterval : 1E3;
  
  /** @private {?number} */
  this._callbackTimeout = null;
  
  /** @private */
  this._fireCallbackBound = function() {
    $jscomp$this._fireCallback();
  };
  
  /** @private */
  this._ticks = 0;
  
  /** @private */
  this._totalTicks = 100;
  
  /** @private {number} */
  this._progress = 0;
};

/** @override */
wrm.util.DefaultProgressMonitor.prototype.resize = function(ticks) {
  this._totalTicks = Math.max(ticks, 1E-20);
  if (ticks <= 0) {
    this.done();
  }
};

/** @override */
wrm.util.DefaultProgressMonitor.prototype.worked = function(ticks) {
  var progress = ticks / this._totalTicks;
  this._ticks += ticks;
  this._contribute(progress);
};

/** @override */
wrm.util.DefaultProgressMonitor.prototype.sub = function(ticks) {
  var subProgress = ticks / this._totalTicks;
  this._ticks += ticks;
  return new wrm.util.DefaultProgressMonitor._Sub(this, subProgress);
};

/** @override */
wrm.util.DefaultProgressMonitor.prototype.done = function() {
  var progress = (this._totalTicks - this._ticks) / this._totalTicks;
  this._ticks = this._totalTicks;
  this._contribute(progress);
  if (this._callbackTimeout !== null) {
    GLOBAL.clearTimeout(this._callbackTimeout);
  }
};

/**
 * @private
 * @param {number} progress
 */
wrm.util.DefaultProgressMonitor.prototype._contribute = function(progress) {
  if (progress <= 0) {
    return;
  }
  this._progress += progress;
  if (this._callbackTimeout === null) {
    this._callbackTimeout = GLOBAL.setTimeout(this._fireCallbackBound, this._minInterval);
  }
};

/**
 * @private
 * @return {undefined}
 */
wrm.util.DefaultProgressMonitor.prototype._fireCallback = function() {
  this._callbackTimeout = null;
  try {
    this._callback(this._progress);
  } catch (e) {
    if (DEBUG) {
      console.error("Error in progress monitor callback", e);
    }
  }
};

/*
 * Sub-monitor
 */

/**
 * @private
 * @constructor
 * @implements {wrm.util.ProgressMonitor}
 * @param {!wrm.util.DefaultProgressMonitor} root
 * @param {number} fraction
 */
wrm.util.DefaultProgressMonitor._Sub = function(root, fraction) {
  
  /** @private */
  this._root = root;
  
  /** @private */
  this._fraction = fraction;
  
  /** @private */
  this._ticks = 0;
  
  /** @private */
  this._totalTicks = 100;
};

/** @override */
wrm.util.DefaultProgressMonitor._Sub.prototype.resize = function(ticks) {
  this._totalTicks = Math.max(ticks, 1E-20);
  if (ticks <= 0) {
    this.done();
  }
};

/** @override */
wrm.util.DefaultProgressMonitor._Sub.prototype.worked = function(ticks) {
  var progress = ticks / this._totalTicks * this._fraction;
  this._ticks += ticks;
  this._root._contribute(progress);
};

/** @override */
wrm.util.DefaultProgressMonitor._Sub.prototype.sub = function(ticks) {
  var subProgress = ticks / this._totalTicks * this._fraction;
  this._ticks += ticks;
  return new wrm.util.DefaultProgressMonitor._Sub(this._root, subProgress);
};

/** @override */
wrm.util.DefaultProgressMonitor._Sub.prototype.done = function() {
  var progress = (this._totalTicks - this._ticks) / this._totalTicks * this._fraction;
  this._ticks = this._totalTicks;
  this._root._contribute(progress);
};




//== wrm/data/sync/DataSyncService.js =========================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.data.sync.DataSyncService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /**
   * @private
   * @type {!wrm.data.sync.DataSyncUpdater}
   */
  this._updater;
  
  /**
   * @private
   * @type {!wrm.data.sync.DataTrackerService}
   */
  this._dataTrackerService;
  
  /**
   * @private
   * @type {!wrm.core.SecurityService}
   */
  this._securityService;
  
  /**
   * @private
   * @type {!wrm.core.BackEndService}
   */
  this._backEndService;
  
  /**
   * @private
   * @type {!wrm.l10n.LocalizationService}
   */
  this._l10nService;
  
  /**
   * @private
   * @type {?number}
   */
  this._lastAccessSynchroSerial = null;
  
  /** @private */
  this._nonPeriodicalSyncRunning = 0;
  
  /** @private */
  this._asyncErrorsSuppressed = false;
  
  /**
   * @private
   * @type {{changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}}
   */
  this._syncResult = {changed:false, promisedValues:[]};
  
  /*
   * UNSTABLE STATE tied to the data service: each of the following state variables is (re-)initialized for each data service change
   */
  
  /**
   * @private
   * @type {!wrm.data.DataService}
   */
  this._dataService;
  
  /**
   * @private
   * @type {?{onStartup:!Array<!wrm.data.meta.Entity>, onReopen:!Array<{entity:!wrm.data.meta.Entity, interval:number}>,
   *       onPeriod:!Array<{entity:!wrm.data.meta.Entity, interval:number}>}}
   */
  this._entityLists;
  
  /**
   * @private
   * @type {?wrm.data.sync.Synchronizer}
   */
  this._synchronizer;
  
  /* Stability control */
  
  /** @private */
  this._stable = false;
  
  /** @private */
  this._unstableInstance = new wrm.core.VolatileHolder(this);
};

extendConstructor(wrm.data.sync.DataSyncService, wrm.core.AbstractService);

/** @override */
wrm.data.sync.DataSyncService.prototype.initialize = function(descr) {
  var thisService = this;
  var manager = this.getManager();
  
  /* Get needed services */
  return Promise.all([manager.getDataTrackerService().then(function(dataTrackerService) {
    thisService._dataTrackerService = dataTrackerService;
  }), manager.getSecurityService().then(function(securityService) {
    thisService._securityService = securityService;
  }), manager.getBackEndService().then(function(backEndService) {
    thisService._backEndService = backEndService;
  }), manager.getLocalizationService().then(function(l10nService) {
    thisService._l10nService = l10nService;
  })]).then(function() {
    
    /* Prepare the helper update participant and register it */
    return manager.getUpdateService().then(function(updateService) {
      var updater = thisService._createUpdater();
      updateService.registerParticipant(wrm.data.sync.DataSyncService.UPDATE_ID, updater);
    });
  }).then(function() {
    
    /* Get the Data Service and track its instability AFTER other services */
    return manager.getDataService().then(function(dataService) {
      dataService.useUnstable(thisService._reinitFromDataService.bind(thisService, descr));
    });
  });
};

/**
 * @private
 * @return {!wrm.data.sync.DataSyncUpdater}
 */
wrm.data.sync.DataSyncService.prototype._createUpdater = function() {
  var currentVersion = wrm.data.sync.Synchronizer.CURRENT_VERSION;
  return new wrm.data.sync.DataSyncUpdater(currentVersion, this, this._securityService, this._backEndService, this._l10nService, this.getLog());
};

/**
 * @private
 * @param {!Object} descr
 * @param {!wrm.data.DataService} dataService
 * @param {boolean} stable
 */
wrm.data.sync.DataSyncService.prototype._reinitFromDataService = function(descr, dataService, stable) {
  this._dataService = dataService;
  if (stable) {
    this._entityLists = wrm.data.sync.DataSyncService._createEntityLists(descr["entities"], dataService.getMetadata());
  } else {
    this._entityLists = null;
  }
  this._synchronizer = null;
  
  this._stable = stable;
  this._unstableInstance.swap(stable ? null : new wrm.data.sync.UnstableDataSyncService(this));
};

/**
 * @private
 * @param {!Object} descr
 * @param {!wrm.data.meta.Metadata} metadata
 * @return {{onStartup:!Array<!wrm.data.meta.Entity>, onReopen:!Array<{entity:!wrm.data.meta.Entity, interval:number}>,
 *         onPeriod:!Array<{entity:!wrm.data.meta.Entity, interval:number}>}}
 */
wrm.data.sync.DataSyncService._createEntityLists = function(descr, metadata) {
  var result = {onStartup:[], onReopen:[], onPeriod:[]};
  
  /* Iterate all entity configuration descriptors and map entities by their supported synchronization types */
  Object.keys(descr).forEach(function(entityId) {
    var entity = metadata.getEntity(entityId);
    var configDescr = descr[entityId];
    
    if (configDescr["startup"] === true) {
      result.onStartup.push(entity);
    }
    if (typeof configDescr["reopen"] === "number") {
      result.onReopen.push({entity:entity, interval:configDescr["reopen"] * 6E4});
    }
    if (typeof configDescr["period"] === "number") {
      result.onPeriod.push({entity:entity, interval:configDescr["period"] * 6E4});
    }
  });
  
  return result;
};

/**
 * @const
 * @type {string}
 */
wrm.data.sync.DataSyncService.ID = "_datasync";

/**
 * @const
 * @type {string}
 */
wrm.data.sync.DataSyncService.UPDATE_ID = "datasync";

/*
 * Stability control
 */

/**
 * @protected
 * @return {undefined}
 */
wrm.data.sync.DataSyncService.prototype.handleUnstableUse = function() {
  throw new Error("The Data Sync Service is not stable");
};

/**
 * @internal
 * @param {function(!wrm.data.sync.DataSyncService,boolean)} callback
 */
wrm.data.sync.DataSyncService.prototype.useUnstable = function(callback) {
  this._unstableInstance.use(callback);
};

/*
 * Configuration
 */

/**
 * @internal
 * @param {!wrm.data.meta.Entity} entity
 * @return {boolean}
 */
wrm.data.sync.DataSyncService.prototype.hasServerStore = function(entity) {
  return this._getSynchronizer().hasServerStore(entity);
};

/**
 * @internal
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.core.ServerStore} serverStore
 */
wrm.data.sync.DataSyncService.prototype.registerServerStore = function(entity, serverStore) {
  this._getSynchronizer().registerServerStore(entity, serverStore);
};

/**
 * @internal
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Promise<boolean>}
 */
wrm.data.sync.DataSyncService.prototype.hasOutboundChanges = function(entity) {
  return this._getSynchronizer().hasOutboundChanges(entity);
};

/**
 * @private
 * @return {!wrm.data.sync.Synchronizer}
 */
wrm.data.sync.DataSyncService.prototype._getSynchronizer = function() {
  if (!this._synchronizer) {
    var synchronizer = new wrm.data.sync.Synchronizer(this._dataService, this._dataTrackerService, this._backEndService, this.getManager());
    this._dataService.getMetadata().getEntities().forEach(function(entity) {
      if (entity.getServerName()) {
        synchronizer.registerServerStore(entity, new wrm.data.sync.BackEndServerStore(entity, this._backEndService));
      }
    }, this);
    this._synchronizer = synchronizer;
  }
  return this._synchronizer;
};

/*
 * Synchronization actions
 */

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype.synchronizeOnStartup = function(state) {
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  var thisService = this;
  var log = this.getLog();
  
  var lastAuth = this._securityService.getLastAuth();
  this._lastAccessSynchroSerial = lastAuth && lastAuth.serial;
  
  /*
   * If there is a pending first synchronization, consider the trigger to be a "first startup", otherwise consider it to be a
   * "subsequent startup". A pending first synchronization may also be the result of an interrupted "first startup" or "first access"
   * synchronization that must now be resumed.
   */
  var takeAsFirst = false;
  if (this._isPendingFirstSynchronization()) {
    log.debug("Will perform a pending 'first' synchronization");
    takeAsFirst = true;
  }
  
  /* Do a first startup SYNC synchronization */
  if (takeAsFirst) {
    this._setPendingFirstSynchronization(true);
    return this._doSynchronizeSync(Trigger.FIRST_STARTUP, {}, state);
  }
  
  /*
   * Do a subsequent startup ASYNC synchronization. This includes the case of an interrupted "subsequent access" synchronization that
   * must now be resumed.
   */
  this._doSynchronizeAsync(Trigger.SUBSEQUENT_STARTUP, {}, state).then(function() {
    thisService.collectSuccessEvents(state);
  });
  return Promise.resolve((null));
};

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype.synchronizeDuringNavigation = function(state) {
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  var thisService = this;
  var log = this.getLog();
  
  /* If the user did re-authenticate, trigger an "on access" synchronization */
  var lastAuth = this._securityService.getLastAuth();
  var lastAccessSerial = lastAuth && lastAuth.serial;
  var lastAccessSynchroSerial = this._lastAccessSynchroSerial;
  if (lastAccessSerial !== lastAccessSynchroSerial) {
    this._lastAccessSynchroSerial = lastAccessSerial;
    
    /*
     * If the username changed or there is a pending first synchronization, consider the trigger to be a "first access", otherwise
     * consider it to be a "subsequent access"
     */
    var takeAsFirst = lastAuth.usernameChanged;
    if (!takeAsFirst && this._isPendingFirstSynchronization()) {
      log.debug("Will perform a pending 'first' synchronization");
      takeAsFirst = true;
    }
    
    /* Do a first access SYNC synchronization */
    if (takeAsFirst) {
      this._setPendingFirstSynchronization(true);
      return this._doSynchronizeSync(Trigger.FIRST_ACCESS, {}, state);
    }
    
    /* Do a subsequent access ASYNC synchronization (the promise is broken ON PURPOSE!) */
    this._doSynchronizeAsync(Trigger.SUBSEQUENT_ACCESS, {}, state).then(function() {
      thisService.collectSuccessEvents(state);
    });
    return Promise.resolve((null));
  }
  
  return Promise.resolve((null));
};

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype.synchronizeOnResume = function(state) {
  return this._doSynchronizeAsync(wrm.data.sync.DataSyncService._Trigger.RESUME, {}, state);
};

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.data.sync.DataSyncService.prototype.startPeriodicalSynchronization = function(state) {
  var thisService = this;
  return this.getManager().getAppService().then(function(appService) {
    appService.startTimer(thisService._syncrhonizePeriodically.bind(thisService), 3E4, state);
  });
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype._syncrhonizePeriodically = function(state) {
  return this._doSynchronizeAsync(wrm.data.sync.DataSyncService._Trigger.PERIOD, {}, state);
};

/**
 * @param {!wrm.data.sync.DataSyncService.Request} request
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype.synchronize = function(request, state) {
  return this._doSynchronizeSync(wrm.data.sync.DataSyncService._Trigger.REQUEST, request, state);
};

/**
 * @private
 * @typedef {{entities:(!Array<!wrm.data.meta.Entity>|undefined), outbound:(boolean|undefined), inbound:(boolean|undefined),
 *          token:(string|undefined)}}
 */
wrm.data.sync.DataSyncService.Request;

/**
 * @private
 * @param {wrm.data.sync.DataSyncService._Trigger} trigger
 * @param {!wrm.data.sync.DataSyncService.Request} request
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype._doSynchronizeSync = function(trigger, request, state) {
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  var DataSyncError = wrm.data.sync.DataSyncError;
  var thisService = this;
  var log = this.getLog();
  
  /* Do not synchronize over "non periodical" synchronizations */
  if (this._nonPeriodicalSyncRunning > 0 && trigger !== Trigger.REQUEST) {
    log.debug("Skipping synchronous synchronization during another synchronous attempt");
    return Promise.resolve((null));
  }
  if (trigger !== Trigger.PERIOD) {
    this._nonPeriodicalSyncRunning++;
  }
  
  /* Synchronize, then route depending on success/failure */
  return Promise.resolve().then(function() {
    return thisService._runSynchronization(trigger, request, false, state);
    
  }).then(function(result) {
    thisService._setSynchronizedOnceOnSync();
    if (trigger !== Trigger.PERIOD) {
      thisService._nonPeriodicalSyncRunning--;
    }
    thisService._handleNoError();
    thisService._finalizeSynchronization(result);
    return null;
    
  })["catch"](function(e) {
    if (trigger !== Trigger.PERIOD) {
      thisService._nonPeriodicalSyncRunning--;
    }
    var reason = e instanceof DataSyncError ? e.getReason() : DataSyncError.Reason.INTERNAL_ERROR;
    var retryFn = thisService._doSynchronizeSync.bind(thisService, trigger, request, state);
    return thisService._handleErrorSync(reason, trigger, retryFn, state);
  });
};

/**
 * @private
 * @param {wrm.data.sync.DataSyncService._Trigger} trigger
 * @param {!wrm.data.sync.DataSyncService.Request} request
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype._doSynchronizeAsync = function(trigger, request, state) {
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  var DataSyncError = wrm.data.sync.DataSyncError;
  var thisService = this;
  
  /* Do not synchronize if the back-end is unreachable */
  if (!this._backEndService.isReachable()) {
    return Promise.resolve((null));
  }
  
  /* Do not synchronize over "non periodical" synchronizations */
  if (this._nonPeriodicalSyncRunning > 0 && trigger !== Trigger.REQUEST) {
    return Promise.resolve((null));
  }
  if (trigger !== Trigger.PERIOD) {
    this._nonPeriodicalSyncRunning++;
  }
  
  /* Synchronize, then dispatch an appropriate event to signal success/failure */
  return Promise.resolve().then(function() {
    return thisService._runSynchronization(trigger, request, true, state);
    
  }).then(function(result) {
    if (trigger !== Trigger.PERIOD) {
      thisService._nonPeriodicalSyncRunning--;
    }
    thisService._handleNoError();
    thisService._finalizeSynchronization(result);
    return null;
    
  })["catch"](function(e) {
    if (trigger !== Trigger.PERIOD) {
      thisService._nonPeriodicalSyncRunning--;
    }
    var reason = e instanceof DataSyncError ? e.getReason() : DataSyncError.Reason.INTERNAL_ERROR;
    var retryFn = thisService._doSynchronizeAsync.bind(thisService, trigger, request, state);
    return thisService._handleErrorAsync(reason, trigger, retryFn, state);
  });
};

/**
 * @private
 * @param {{changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}} syncResult
 */
wrm.data.sync.DataSyncService.prototype._finalizeSynchronization = function(syncResult) {
  
  /* Notify the success of the synchronization */
  this._syncResult.changed = this._syncResult.changed || syncResult.changed;
  this._syncResult.promisedValues = this._syncResult.promisedValues.concat(syncResult.promisedValues);
};

/**
 * @return {boolean}
 */
wrm.data.sync.DataSyncService.prototype.isBackgroundDownloading = function() {
  return this._getSynchronizer().isBackgroundDownloading();
};

/**
 * @param {!wrm.nav.State} state
 */
wrm.data.sync.DataSyncService.prototype.collectSuccessEvents = function(state) {
  var log = this.getLog();
  
  /*
   * Do not collect events over "non periodical" synchronizations.
   * 
   * This is intended to avoid periodical synchronization ATTEMPTS picking up the results of other long-running synchronizations; in
   * the future a more ideal solution would be to have a structural handling of success events (begin + end) so that each overall
   * navigation can collect only its success events; this is not easily done from within the Runtime Manager because a single
   * navigation is broken up into multiple calls to various services.
   */
  if (this._nonPeriodicalSyncRunning) {
    return;
  }
  
  /* Throw a first event if there were changes */
  if (this._syncResult.changed) {
    state.dispatchEvent(new wrm.nav.Event("SynchronizationSuccess"));
  }
  
  /* Collect promised values that are yet to update, dispatching additional "incremental" events as pending values arrive */
  var pendingValues = this._syncResult.promisedValues.filter(function(promisedValue) {
    return promisedValue.isPending();
  });
  if (pendingValues.length > 0) {
    log.debug("Expecting", pendingValues.length, "pending values to update later");
    wrm.util.promiseAllIncrementally(pendingValues, 1E3, 5E3, function(values) {
      log.debug("Updated", values.length, "more pending values from previous synchronization");
      state.dispatchEvent(new wrm.nav.Event("SynchronizationSuccess"));
    });
  }
  
  this._syncResult.changed = false;
  this._syncResult.promisedValues = [];
};

/**
 * @internal
 * @return {undefined}
 */
wrm.data.sync.DataSyncService.prototype.scheduleFirstSynchronization = function() {
  this._setPendingFirstSynchronization(true);
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.DataSyncService.prototype._isPendingFirstSynchronization = function() {
  var dict = this.getManager().getPlatform().retrieveDictionary("_dataSync");
  return dict.get("pendingFirst") === "true";
};

/**
 * @private
 * @param {boolean} pending
 */
wrm.data.sync.DataSyncService.prototype._setPendingFirstSynchronization = function(pending) {
  var dict = this.getManager().getPlatform().retrieveDictionary("_dataSync");
  dict.set("pendingFirst", String(pending));
};

/**
 * @param {?Array<!wrm.data.meta.Entity>} entities
 */
wrm.data.sync.DataSyncService.prototype.setPreferredSynchronizationOrder = function(entities) {
  this._getSynchronizer().setPreferredOrder(entities);
};

/*
 * Actual synchronization
 */

/**
 * @private
 * @enum {string}
 */
wrm.data.sync.DataSyncService._Trigger = {FIRST_STARTUP:"first startup", SUBSEQUENT_STARTUP:"subsequent startup", FIRST_ACCESS:"first access", SUBSEQUENT_ACCESS:"subsequent access", RESUME:"resume", PERIOD:"period", REQUEST:"request"};

/**
 * @private
 * @param {wrm.data.sync.DataSyncService._Trigger} trigger
 * @param {!wrm.data.sync.DataSyncService.Request} request
 * @param {boolean} async
 * @param {!wrm.nav.State} state
 * @return {!Promise<{changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.data.sync.DataSyncError} with various reasons.
 */
wrm.data.sync.DataSyncService.prototype._runSynchronization = function(trigger, request, async, state) {
  var DataSyncError = wrm.data.sync.DataSyncError;
  var Reason = wrm.data.sync.DataSyncError.Reason;
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  var thisService = this;
  var log = this.getLog();
  
  var synchronizer = this._getSynchronizer();
  
  /* Determine the entities to synchronize */
  var entities;
  switch(trigger) {
    case Trigger.FIRST_STARTUP:
    ;
    case Trigger.FIRST_ACCESS:
      entities = this._getEntityLists().onStartup.slice();
      break;
    case Trigger.SUBSEQUENT_STARTUP:
    ;
    case Trigger.SUBSEQUENT_ACCESS:
      entities = this._filterTimedEntityList(this._getEntityLists().onReopen, synchronizer);
      break;
    case Trigger.RESUME:
      entities = this._filterTimedEntityList(this._getEntityLists().onReopen, synchronizer, wrm.data.DateTime.now());
      break;
    case Trigger.PERIOD:
      entities = this._filterTimedEntityList(this._getEntityLists().onPeriod, synchronizer, wrm.data.DateTime.now());
      break;
    case Trigger.REQUEST:
      entities = request.entities.slice() || [];
      break;
    default:
      if (DEBUG) {
        throw new Error("Unsupported trigger");
      }
      entities = [];
  }
  if (entities.length <= 0) {
    return (Promise.resolve({changed:false, promisedValues:[]}));
  }
  
  /* Check for server-stores availability */
  if (!synchronizer.checkAvailable(entities)) {
    return Promise.reject(new DataSyncError("Back-end not available", Reason.BACKEND_UNAVAILABLE));
  }
  
  /* Run synchronous synchronizations at a higher priority in order to avoid blocking the caller for a long time */
  var priority = async ? 0 : 10;
  
  /*
   * Allow re-access only if not triggered by an access, since that might cause an INFINITE LOOP, being the access itself one of the
   * conditions that triggers data synchronization.
   */
  var allowAccess = !this._isAccessTrigger(trigger);
  
  /* Prepare the actual synchronization request */
  var actualRequest = angular.extend({}, request, {entities:entities});
  var waitForAllValues = trigger === Trigger.REQUEST;
  
  log.debug("Attempting synchronization triggered by", trigger);
  this._reportSynchronizationProgress(true, state);
  return this._doRunSynchronization(allowAccess, waitForAllValues, synchronizer, actualRequest, priority).then(function(result) {
    thisService._reportSynchronizationProgress(false, state);
    if (trigger === Trigger.FIRST_STARTUP || trigger === Trigger.FIRST_ACCESS) {
      thisService._setPendingFirstSynchronization(false);
    }
    return result;
  }, function(e) {
    thisService._reportSynchronizationProgress(false, state);
    if (e instanceof DataSyncError) {
      throw e;
    } else {
      var reason = Reason.INTERNAL_ERROR;
      if (e instanceof wrm.core.ForbiddenError) {
        reason = Reason.FORBIDDEN;
      } else {
        if (e instanceof wrm.core.NetworkError) {
          reason = Reason.NETWORK_ERROR;
        }
      }
      throw new DataSyncError(e.message, reason);
    }
  });
};

/**
 * @private
 * @return {{onStartup:!Array<!wrm.data.meta.Entity>, onReopen:!Array<{entity:!wrm.data.meta.Entity, interval:number}>,
 *         onPeriod:!Array<{entity:!wrm.data.meta.Entity, interval:number}>}}
 */
wrm.data.sync.DataSyncService.prototype._getEntityLists = function() {
  if (!this._entityLists) {
    this.handleUnstableUse();
    throw new Error("Operation not available on unstable Data Sync Service");
  }
  return this._entityLists;
};

/**
 * @private
 * @param {boolean} allowAccess
 * @param {boolean} waitForAllValues
 * @param {!wrm.data.sync.Synchronizer} synchronizer
 * @param {!wrm.data.sync.DataSyncService.Request} request
 * @param {number} priority
 * @return {!Promise<{changed:boolean, promisedValues:!Array<!wrm.util.PromisedValue>}>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.data.sync.DataSyncError} with various reasons.
 */
wrm.data.sync.DataSyncService.prototype._doRunSynchronization = function(allowAccess, waitForAllValues, synchronizer, request, priority) {
  var DataSyncError = wrm.data.sync.DataSyncError;
  var Reason = wrm.data.sync.DataSyncError.Reason;
  var thisService = this;
  var log = this.getLog();
  
  /* Use a progress monitor that logs debug-level messages */
  var progressMonitor;
  if (log.isDebugEnabled()) {
    progressMonitor = new wrm.util.DefaultProgressMonitor(function(p) {
      log.debug("Synchronization progress:", (p * 100).toFixed(2) + "%");
    }, 1E4);
  } else {
    progressMonitor = wrm.util.FakeProgressMonitor.INSTANCE;
  }
  
  var requestedToken = request.token || null;
  var actionFunction = function(token) {
    var job = {entities:request.entities || [], outbound:request.outbound !== false, inbound:request.inbound !== false, token:token, waitForAllValues:waitForAllValues, progressMonitor:progressMonitor};
    return synchronizer.synchronize(job, priority);
  };
  
  /* First attempt: no access, using current authorizations */
  var forbiddenAtFirstAttempt = false;
  return Promise.resolve().then(function() {
    return thisService._actionAttempt(false, requestedToken, actionFunction)["catch"](function(e) {
      
      /* The user did appear to have a valid token but does not: IF ALLOWED ACCESS, treat this as a missing token */
      if (allowAccess && e instanceof wrm.core.ForbiddenError) {
        forbiddenAtFirstAttempt = true;
        log.debug("Authentication token appears to be no longer valid: will attempt to re-access");
        return {success:false, value:undefined};
      }
      
      throw e;
    });
  }).then(function(result) {
    if (result.success) {
      return result.value;
    }
    
    /* The user is not logged in and ACCESS IS NOT ALLOWED: raise an error */
    if (!allowAccess || !forbiddenAtFirstAttempt) {
      throw new DataSyncError("Not logged in", Reason.LOGGED_OUT);
    }
    
    /* Second attempt: with a FORCED ACCESS allowed by the 'catch' block above */
    return thisService._actionAttempt(true, requestedToken, actionFunction).then(function(result) {
      if (result.success) {
        return result.value;
      }
      
      /* The user does not have a valid token and access is not possible: raise an error */
      throw new DataSyncError("Not logged in and access denied", Reason.LOGGED_OUT_ACCESS_DENIED);
    });
  });
};

/**
 * @private
 * @template R
 * @param {boolean} forceAccess
 * @param {?string} forcedToken
 * @param {function(string):!Promise<R>} actionCallback
 * @return {!Promise<{success:boolean, value:(R|undefined)}>}
 */
wrm.data.sync.DataSyncService.prototype._actionAttempt = function(forceAccess, forcedToken, actionCallback) {
  var thisService = this;
  var securityService = this._securityService;
  
  /* First perform an access if asked to */
  var promise;
  if (forceAccess) {
    promise = securityService.access(false, wrm.nav.newInternalState());
  } else {
    promise = Promise.resolve(null);
  }
  
  /* Retrieve updated user information */
  return promise.then(function(accessRoute) {
    if (accessRoute !== null) {
      return {success:false, value:undefined};
    }
    
    /*
     * If just accessed, update the recorded last synchronization date/time in order to avoid triggering a useless access
     * synchronization later
     */
    if (forceAccess) {
      var newLastAuth = securityService.getLastAuth();
      thisService._lastAccessSynchroSerial = newLastAuth && newLastAuth.serial;
    }
    
    var internalPromise;
    if (forcedToken) {
      internalPromise = Promise.resolve(forcedToken);
    } else {
      internalPromise = securityService.retrieveCurrentToken();
    }
    
    /* Retrieve the current token */
    return internalPromise.then(function(token) {
      if (!token) {
        return {success:false, value:undefined};
      }
      
      /* Execute the action using the current token */
      return actionCallback(token).then(function(result) {
        return {success:true, value:result};
      });
    });
  });
};

/**
 * @private
 * @param {boolean} running
 * @param {!wrm.nav.State} state
 */
wrm.data.sync.DataSyncService.prototype._reportSynchronizationProgress = function(running, state) {
  var message = running ? this._l10nService.formatMessage("notification.synchronizationProgress") : null;
  state.reportProgress(new wrm.nav.Progress(message));
};

/**
 * @private
 * @return {boolean}
 */
wrm.data.sync.DataSyncService.prototype._hasSynchronizedOnceSync = function() {
  var dict = this._dataService.getAuxiliaryDictionary();
  return wrm.data.toBoolean(dict.get("synchronization.onceSync")) || false;
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.sync.DataSyncService.prototype._setSynchronizedOnceOnSync = function() {
  var dict = this._dataService.getAuxiliaryDictionary();
  dict.set("synchronization.onceSync", (wrm.data.toString(true)));
};

/*
 * Error handling
 */

/**
 * @private
 * @return {undefined}
 */
wrm.data.sync.DataSyncService.prototype._handleNoError = function() {
  this._asyncErrorsSuppressed = false;
};

/**
 * @private
 * @param {wrm.data.sync.DataSyncError.Reason} reason
 * @param {wrm.data.sync.DataSyncService._Trigger} trigger
 * @param {?function()} retryFunction
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype._handleErrorSync = function(reason, trigger, retryFunction, state) {
  var Reason = wrm.data.sync.DataSyncError.Reason;
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  var thisService = this;
  var securityService = this._securityService;
  
  /* Ignore missing logins at startup */
  if (reason === Reason.LOGGED_OUT && (trigger == Trigger.FIRST_STARTUP || trigger == Trigger.SUBSEQUENT_STARTUP)) {
    return Promise.resolve((null));
  }
  
  /* Prepare a dialog to decide the route to follow */
  var dialogFlavor, dialogActions;
  var dialogMessage = this._getErrorDialogMessage(reason);
  var startPanelId = state.getContextualStartPanelId();
  var accessing = this._isAccessTrigger(trigger);
  if (startPanelId) {
    
    /* If there is a start panel, the only option is to route back there */
    dialogFlavor = wrm.nav.Dialog.Flavor.NEGATIVE;
    dialogActions = [{label:"dialog.button.OK", callback:function() {
      var logoutPromise = accessing ? securityService.clearUser(false) : Promise.resolve();
      return logoutPromise.then(function() {
        state.stepImplicitly();
        return wrm.nav.Route.toService(startPanelId || undefined);
      });
    }}];
  } else {
    if (!this._hasSynchronizedOnceSync()) {
      
      /* With no start panel, ON FIRST ACCESS, give the option to retry before falling back to an interactive access */
      dialogFlavor = wrm.nav.Dialog.Flavor.NEGATIVE;
      dialogActions = [{label:"dialog.button.Retry", callback:function() {
        return null;
      }, "default":true}, {label:"dialog.button.Exit", callback:function() {
        return securityService.clearUser(false).then(function() {
          return securityService.access(true, state);
        });
      }}];
    } else {
      if (reason === Reason.LOGGED_OUT_ACCESS_DENIED) {
        
        /* With no start panel, ON SUBSEQUENT ACCESSES, when denied entrance, the only option is to access again */
        dialogFlavor = wrm.nav.Dialog.Flavor.NEGATIVE;
        dialogActions = [{label:"dialog.button.OK", callback:function() {
          return securityService.clearUser(false).then(function() {
            return securityService.access(true, state);
          });
        }}];
      } else {
        
        /* With no start panel, ON SUBSEQUENT ACCESSES, give the option to retry or to continue while ignoring errors */
        dialogFlavor = wrm.nav.Dialog.Flavor.CAUTIONAL;
        dialogActions = [{label:"dialog.button.Retry", callback:function() {
          return null;
        }, "default":true}, {label:"dialog.button.Continue", callback:function() {
          thisService._asyncErrorsSuppressed = true;
          retryFunction = null;
          return null;
        }}];
      }
    }
  }
  
  /* Present the dialog, then route away */
  return this._presentDialog(dialogFlavor, dialogMessage, dialogActions, state).then(function(route) {
    if (route) {
      return route;
    }
    
    /* Retry if possible */
    if (retryFunction) {
      return Promise.resolve(retryFunction());
    }
    
    return null;
  });
};

/**
 * @private
 * @param {wrm.data.sync.DataSyncError.Reason} reason
 * @param {wrm.data.sync.DataSyncService._Trigger} trigger
 * @param {?function()} retryFunction
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.data.sync.DataSyncService.prototype._handleErrorAsync = function(reason, trigger, retryFunction, state) {
  var Reason = wrm.data.sync.DataSyncError.Reason;
  var thisService = this;
  var securityService = this._securityService;
  
  /* Suppress errors if previously asked to */
  if (this._asyncErrorsSuppressed) {
    return Promise.resolve((null));
  }
  
  /* Prepare a dialog to decide the route to follow */
  var dialogFlavor, dialogActions;
  var dialogMessage = this._getErrorDialogMessage(reason);
  switch(reason) {
    case Reason.LOGGED_OUT:
    ;
    case Reason.BACKEND_UNAVAILABLE:
      return Promise.resolve((null));
    case Reason.FORBIDDEN:
      dialogFlavor = wrm.nav.Dialog.Flavor.NEGATIVE;
      dialogActions = [{label:"dialog.button.OK", callback:function() {
        return securityService.access(true, state);
      }}];
      break;
    case Reason.INTERNAL_ERROR:
    ;
    default:
      dialogFlavor = wrm.nav.Dialog.Flavor.CAUTIONAL;
      dialogActions = [{label:"dialog.button.Retry", callback:function() {
        return null;
      }, "default":true}, {label:"dialog.button.Continue", callback:function() {
        thisService._asyncErrorsSuppressed = true;
        return wrm.nav.Route.toNowhere();
      }}];
  }
  
  /* Present the dialog, then route away */
  return this._presentDialog(dialogFlavor, dialogMessage, dialogActions, state).then(function(route) {
    if (route) {
      return route;
    }
    
    /* Retry if possible */
    if (retryFunction) {
      return Promise.resolve(retryFunction());
    }
    
    return wrm.nav.Route.toNowhere();
  });
};

/**
 * @private
 * @param {wrm.data.sync.DataSyncService._Trigger} trigger
 * @return {boolean}
 */
wrm.data.sync.DataSyncService.prototype._isAccessTrigger = function(trigger) {
  var Trigger = wrm.data.sync.DataSyncService._Trigger;
  return trigger === Trigger.FIRST_ACCESS || trigger === Trigger.SUBSEQUENT_ACCESS;
};

/**
 * @private
 * @param {wrm.data.sync.DataSyncError.Reason} reason
 * @return {string}
 */
wrm.data.sync.DataSyncService.prototype._getErrorDialogMessage = function(reason) {
  var Reason = wrm.data.sync.DataSyncError.Reason;
  switch(reason) {
    case Reason.LOGGED_OUT_ACCESS_DENIED:
    ;
    case Reason.FORBIDDEN:
      return "notification.synchronizationForbidden";
    case Reason.NETWORK_ERROR:
      if (navigator.connection.type === Connection.NONE) {
        return "notification.synchronizationNetworkUnavailable";
      }
      return "notification.synchronizationNetworkError";
  }
  return "notification.synchronizationError";
};

/**
 * @private
 * @template R
 * @param {wrm.nav.Dialog.Flavor} flavor
 * @param {string} message
 * @param {!Array<{label:string, callback:(function():R|function():!Promise<R>), default:(boolean|undefined)}>} actions
 * @param {!wrm.nav.State} state
 * @return {!Promise<R>}
 */
wrm.data.sync.DataSyncService.prototype._presentDialog = function(flavor, message, actions, state) {
  var l10nService = this._l10nService;
  
  /* Localize messages and use indexes as choice values */
  var lMessage = l10nService.formatMessage(message);
  var choices = [];
  actions.forEach(function(action, i) {
    choices.push({label:l10nService.formatMessage(action.label), value:i, "default":action["default"]});
  });
  
  /* Present the dialog and run the action corresponding to the choice index */
  return state.presentDialog(new wrm.nav.Dialog(lMessage, flavor, choices)).then(function(result) {
    var actionIndex = result.value;
    return actions[actionIndex].callback();
  });
};

/*
 * Additional actions
 */

/**
 * @return {!Promise}
 */
wrm.data.sync.DataSyncService.prototype.clearOutgoingChanges = function() {
  var synchronizer = this._getSynchronizer();
  return this._dataService.getMetadata().getEntities().reduce(function(chain, entity) {
    if (entity instanceof wrm.data.meta.AuxEntity || entity instanceof wrm.data.meta.BridgeEntity || entity.getId() === wrm.Constants.USER_ENT_ID || entity.getId() === wrm.Constants.ROLE_ENT_ID) {
      return chain;
    }
    return chain.then(function() {
      return synchronizer.clearOutgoingChanges((entity));
    });
  }, Promise.resolve());
};

/**
 * @public
 * @param {!wrm.data.meta.Entity} entity
 */
wrm.data.sync.DataSyncService.prototype.clearLastSynchronizationDateTime = function(entity) {
  this._getSynchronizer().clearLastSynchronizationDateTime(entity);
};

/**
 * @private
 * @param {!Array<{entity:!wrm.data.meta.Entity, interval:number}>} entityList
 * @param {!wrm.data.sync.Synchronizer} synchronizer
 * @param {!wrm.data.DateTime=} currentDateTime
 * @return {!Array<!wrm.data.meta.Entity>}
 */
wrm.data.sync.DataSyncService.prototype._filterTimedEntityList = function(entityList, synchronizer, currentDateTime) {
  if (!currentDateTime) {
    return entityList.map(function(config) {
      return config.entity;
    });
  }
  
  var currentTimestamp = currentDateTime.asDate().valueOf();
  var entities = [];
  entityList.forEach(function(config) {
    var lastSyncDateTime = synchronizer.getLastSynchronizationDateTime(config.entity);
    var lastSyncTimestamp = lastSyncDateTime ? lastSyncDateTime.asDate().valueOf() : 0;
    if (currentTimestamp - lastSyncTimestamp > config.interval) {
      entities.push(config.entity);
    }
  });
  return entities;
};




//== wrm/core/SecurityService.js ==============================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.SecurityService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /** @private {boolean} */
  this._requireAllowRoles = descr["requireAllowRoles"];
  
  /** @private {string} */
  this._authScreen = this.getOptionalDescriptorValue(descr, "authScreen") || null;
  
  /** @private {?string} */
  this._authActionDef = this.getOptionalDescriptorValue(descr, "authActionDefinition") || null;
  
  /** @private {{packageName:string,groupId:string,teamId:string}} */
  this._accountManagerConfig = this.getOptionalDescriptorValue(descr, "accountManager") || {};
  
  /** @private */
  this._accountManagerAvailable = false;
  
  /** @private {!wrm.core.BackEndService} */
  this._backEndService;
  
  /** @private {?{serial:number, usernameChanged:boolean}} */
  this._lastAuth = null;
  
  /** @private {?Promise<!wrm.data.sync.DataSyncService>} */
  this._dataSyncService;
  
  /** @private {?Promise<?wrm.core.UserInfo>} */
  this._userInfo = null;
  
  /*
   * UNSTABLE STATE tied to the data service: each of the following state variables is (re-)initialized for each data service change
   */
  
  /** @private {!wrm.data.DataService} */
  this._dataService;
  
  /** @private {?wrm.data.meta.Entity} */
  this._userEntity;
  
  /** @private {?wrm.data.meta.Entity} */
  this._roleEntity;
  
  /** @private {?wrm.core.UserServerStore} */
  this._userServerStore;
};

extendConstructor(wrm.core.SecurityService, wrm.core.AbstractService);

/** @override */
wrm.core.SecurityService.prototype.initialize = function() {
  var $jscomp$this = this;
  var manager = this.getManager();
  var platform = manager.getPlatform();
  var log = this.getLog();
  
  /* Get needed services */
  return Promise.all([manager.getBackEndService().then(function(backEndService) {
    $jscomp$this._backEndService = backEndService;
  })]).then(function() {
    
    /* Get the Data Service and track its instability AFTER other services */
    return manager.getDataService().then(function(dataService) {
      dataService.useUnstable($jscomp$this._reinitFromDataService.bind($jscomp$this));
    });
  }).then(function() {
    
    /* Prepare the account manager */
    return $jscomp$this._initializeAccountManager();
  }).then(function() {
    
    /*
     * React to notification status changes by re-authenticating, so that the back-end is informed about possibly-changed device
     * parameters (e.g. the device notification identifier).
     */
    platform.addNotificationStatusListener(function() {
      log.debug("Platform notification status changed: attempting to re-authenticate");
      $jscomp$this._authenticateAgain().catch(function(e) {
        log.error("Error re-authenticating", e);
      });
    });
  }).then(function() {
    
    /* TODO Hack for feature 8962 */
    if ($jscomp$this._accountManagerAvailable) {
      return $jscomp$this._loadPlatformAuth();
    }
  });
};

/**
 * @const {string}
 */
wrm.core.SecurityService.ID = "_security";

/**
 * @private
 * @param {!wrm.data.DataService} dataService
 * @param {boolean} stable
 */
wrm.core.SecurityService.prototype._reinitFromDataService = function(dataService, stable) {
  this._dataService = dataService;
  this._userEntity = null;
  this._userServerStore = null;
};

/**
 * @private
 * @return {!wrm.data.meta.Entity}
 */
wrm.core.SecurityService.prototype._getUserEntity = function() {
  if (!this._userEntity) {
    this._userEntity = this._dataService.getMetadata().getEntity(wrm.Constants.USER_ENT_ID);
  }
  return this._userEntity;
};

/**
 * @private
 * @return {!wrm.data.meta.Entity}
 */
wrm.core.SecurityService.prototype._getRoleEntity = function() {
  if (!this._roleEntity) {
    this._roleEntity = this._dataService.getMetadata().getEntity(wrm.Constants.ROLE_ENT_ID);
  }
  return this._roleEntity;
};

/**
 * @private
 * @return {!wrm.core.UserServerStore}
 */
wrm.core.SecurityService.prototype._getUserServerStore = function() {
  if (!this._userServerStore) {
    this._userServerStore = new wrm.core.UserServerStore(this._getUserEntity(), this._backEndService);
  }
  return this._userServerStore;
};

/**
 * @private
 * @return {!Promise<!wrm.data.sync.DataSyncService>}
 */
wrm.core.SecurityService.prototype._getDataSyncService = function() {
  var $jscomp$this = this;
  if (!this._dataSyncService) {
    this._dataSyncService = this.getManager().getDataSyncService().then(function(dataSyncService) {
      var userEntity = $jscomp$this._getUserEntity();
      var userServerStore = $jscomp$this._getUserServerStore();
      dataSyncService.registerServerStore(userEntity, userServerStore);
      return dataSyncService;
    });
  }
  return this._dataSyncService;
};

/**
 * @internal
 * @return {?{serial:number, usernameChanged:boolean}}
 */
wrm.core.SecurityService.prototype.getLastAuth = function() {
  return this._lastAuth;
};

/**
 * @return {boolean}
 */
wrm.core.SecurityService.prototype.isUserServiceAvailable = function() {
  return !!this._getUserEntity().getServerName();
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.core.SecurityService.prototype.getUserEntity = function() {
  return this._getUserEntity();
};

/*
 * Permission checking
 */

/**
 * @param {!Array<string>} allowedRoles
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.SecurityService.prototype.checkPermission = function(allowedRoles, state) {
  var $jscomp$this = this;
  
  /* First attempt: no access, using DB data */
  return this._checkPermissionAttempt(false, false, allowedRoles, state).then(function(route) {
    if (!route) {
      return null;
    }
    
    /* Second attempt: with a forced access */
    return $jscomp$this._checkPermissionAttempt(true, false, allowedRoles, state).then(function(route) {
      if (!route) {
        return null;
      }
      
      /* Third attempt: with an interactive access */
      return $jscomp$this._checkPermissionAttempt(true, true, allowedRoles, state);
    });
  });
};

/**
 * @private
 * @param {boolean} forceAccess
 * @param {boolean} forceInteractiveAccess
 * @param {!Array<string>} allowedRoles
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.SecurityService.prototype._checkPermissionAttempt = function(forceAccess, forceInteractiveAccess, allowedRoles, state) {
  var $jscomp$this = this;
  
  /* First perform an access if asked to */
  var promise;
  if (forceAccess) {
    promise = this.access(forceInteractiveAccess, state);
  } else {
    promise = Promise.resolve(null);
  }
  
  /* Retrieve updated user information */
  return promise.then(function(accessRoute) {
    if (accessRoute !== null) {
      return accessRoute;
    }
    
    /* Check permissions on the new user information */
    return $jscomp$this.getUserInfo().then(function(userInfo) {
      if (!userInfo) {
        return wrm.nav.Route.toNowhere();
      }
      if (!$jscomp$this._hasPermission(userInfo, allowedRoles)) {
        return wrm.nav.Route.toNowhere();
      }
      return null;
    });
  });
};

/**
 * @private
 * @param {?wrm.core.UserInfo} userInfo
 * @param {!Array<string>} allowedRoles
 * @return {boolean}
 */
wrm.core.SecurityService.prototype._hasPermission = function(userInfo, allowedRoles) {
  
  /* If no specific role is allowed, all are. Having user information (i.e. being authenticate) is enough in this case */
  if (!this._requireAllowRoles && allowedRoles.length === 0) {
    return !!userInfo;
  }
  
  /* Grant permission if the user has at least one of the allowed roles */
  var userRoels = userInfo.getRoleNames();
  for (var i = 0;i < allowedRoles.length;i++) {
    if (userRoels.indexOf(allowedRoles[i]) >= 0) {
      return true;
    }
  }
  
  return false;
};

/*
 * Access
 */

/**
 * @param {boolean} forceInteractive
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.SecurityService.prototype.access = function(forceInteractive, state) {
  var $jscomp$this = this;
  
  /* Try automatic access, unless forced not to do so */
  var promise;
  if (!forceInteractive) {
    promise = this._accessAutomatic(state);
  } else {
    promise = Promise.resolve(false);
  }
  
  /* IF successful, OK; otherwise, fall back to interactive access */
  return promise.then(function(automaticAccessOK) {
    if (automaticAccessOK) {
      return null;
    }
    
    return $jscomp$this._accessInteractive(state);
  });
};

/**
 * @param {boolean} forceInteractive
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.SecurityService.prototype.accessAgain = function(forceInteractive, state) {
  var $jscomp$this = this;
  
  /* Load stored authentication info from the account manager */
  var promise = this._loadPlatformAuth();
  
  /* If there was something stored, force an access */
  return promise = promise.then(function(authInfo) {
    if (authInfo) {
      return $jscomp$this.access(forceInteractive, state);
    }
    
    /* Never accessed before: nowhere special to go */
    return null;
  });
};

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise<!wrm.nav.Route>}
 */
wrm.core.SecurityService.prototype.accessDefault = function(state) {
  return Promise.resolve(this._accessInteractive(state));
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Route}
 */
wrm.core.SecurityService.prototype._accessInteractive = function(state) {
  
  /* There has to be an authentication screen */
  if (!this._authScreen) {
    throw new Error("Authentication screen not available");
  }
  
  state.stepImplicitly();
  return wrm.nav.Route.toService(this._authScreen);
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<boolean>}
 */
wrm.core.SecurityService.prototype._accessAutomatic = function(state) {
  
  /* Automatic access is possible only when defined */
  if (!this._authActionDef) {
    return Promise.resolve(false);
  }
  var loginActionDefPromise = this.getManager().getActionDefinitionService(this._authActionDef);
  
  /* Retrieve the user credentials */
  return this._loadPlatformAuth().then(function(authInfo) {
    
    /* Fail if credentials are not available */
    if (!authInfo) {
      return false;
    }
    
    /* Execute the action definition and return a success/error code depending on its outcome */
    var input = {"username":authInfo.username, "password":authInfo.password};
    return loginActionDefPromise.then(function(actionDefService) {
      return actionDefService.execute(input, state);
    }).then(function(output) {
      return output.isSuccess();
    });
  });
  
};

/**
 * @return {!Promise<?string>}
 */
wrm.core.SecurityService.prototype.retrieveAuthUsername = function() {
  return this._loadPartialPlatformAuth().then(function(platformAuth) {
    return platformAuth.username;
  });
};

/**
 * @return {!Promise<boolean>}
 */
wrm.core.SecurityService.prototype.areAuthCredentialsComplete = function() {
  return this._loadPlatformAuth().then(function(authInfo) {
    return !!authInfo;
  });
};

/**
 * @param {string} username
 * @param {string} password
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype.setAuthCredentials = function(username, password) {
  var $jscomp$this = this;
  return this._loadPartialPlatformAuth().then(function(platformAuth) {
    return $jscomp$this._savePlatformAuth(username, password, platformAuth.token);
  });
};

/*
 * Authentication and user switching
 */

/**
 * @param {string=} username
 * @param {string=} password
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.AuthenticationErorr} (if the authentication fails).
 */
wrm.core.SecurityService.prototype.renewToken = function(username, password) {
  var $jscomp$this = this;
  
  /* Use saved credentials if one or both were not specified */
  if (username === undefined || password === undefined) {
    return this._loadPlatformAuth().then(function(platformAuth) {
      if (!platformAuth) {
        throw new Error("Incomplete auth credentials");
      }
      return $jscomp$this._doRenewToken(platformAuth.username, platformAuth.password);
    });
  }
  
  /* Use the supplied credentials */
  return this._doRenewToken(username, password);
};

/**
 * @private
 * @param {string} username
 * @param {string} password
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.AuthenticationErorr} (if the authentication fails).
 */
wrm.core.SecurityService.prototype._doRenewToken = function(username, password) {
  var $jscomp$this = this;
  
  /* Authenticate and save the new credentials and token in the platform */
  return this._authenticate(username, password).then(function(authResult) {
    return $jscomp$this._savePlatformAuth(username, password, authResult.token);
  });
};

/**
 * @return {!Promise<?string>}
 */
wrm.core.SecurityService.prototype.retrieveCurrentToken = function() {
  return this._loadPlatformAuth().then(function(platformAuth) {
    return platformAuth ? platformAuth.token : null;
  });
};

/**
 * @param {string} username
 * @param {string} password
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.AuthenticationErorr} (if the authentication fails).
 */
wrm.core.SecurityService.prototype.authenticateChangeUser = function(username, password) {
  var $jscomp$this = this;
  
  /* Determine whether the last accessed username is going to be different */
  var usernameChanged = username !== this._getLastUsername();
  
  /* Authenticate on the server */
  return this._authenticate(username, password).then(function(authResult) {
    
    /* Save user information in the database; save authentication on the platform */
    return $jscomp$this._replaceUserInfoFromServer(authResult.record, authResult.serverKey, authResult.token, authResult.roles).then(function() {
      $jscomp$this._setLastUsername(username);
      return $jscomp$this._savePlatformAuth(username, password, authResult.token);
    });
  }).then(function() {
    
    var lastAuthSerial = $jscomp$this._lastAuth && $jscomp$this._lastAuth.serial || 0;
    $jscomp$this._lastAuth = {serial:lastAuthSerial + 1, usernameChanged:usernameChanged};
  });
};

/**
 * @param {string} username
 * @param {string} password
 * @param {?string} token
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype.changeUser = function(username, password, token) {
  var $jscomp$this = this;
  
  /* Determine whether the last accessed username is going to be different */
  var usernameChanged = username !== this._getLastUsername();
  
  /* Save user information in the database; save authentication on the platform */
  return this._replaceUserInfoFromClient(username, null, {}, []).then(function() {
    $jscomp$this._setLastUsername(username);
    return $jscomp$this._savePlatformAuth(username, password, token);
  }).then(function() {
    
    var lastAuthSerial = $jscomp$this._lastAuth && $jscomp$this._lastAuth.serial || 0;
    $jscomp$this._lastAuth = {serial:lastAuthSerial + 1, usernameChanged:usernameChanged};
  });
};

/**
 * @private
 * @param {string} username
 * @param {string} password
 * @return {!Promise<{serverKey:*, token:string, roles:!Array<string>, record:!Object<string,*>}>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.AuthenticationErorr} (if the authentication fails).
 */
wrm.core.SecurityService.prototype._authenticate = function(username, password) {
  if (!this.isUserServiceAvailable()) {
    throw new Error("User services are not available");
  }
  
  /* Login using the back-end */
  return this._backEndService.loginUser(username, password);
};

/**
 * @private
 * @return {!Promise}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.AuthenticationErorr} (if the authentication fails).
 */
wrm.core.SecurityService.prototype._authenticateAgain = function() {
  var $jscomp$this = this;
  
  /* Load stored authentication info from the account manager */
  return this._loadPlatformAuth().then(function(authInfo) {
    
    /* If there was something stored, do an authentication */
    if (authInfo) {
      return $jscomp$this._authenticate(authInfo.username, authInfo.password);
    }
  });
};

/**
 * @param {boolean} includePlatformUsername
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype.clearUser = function(includePlatformUsername) {
  var $jscomp$this = this;
  return this._clearUserInfo().then(function() {
    
    /* Clear authentication information from the platform */
    return $jscomp$this._clearPlatformAuth(includePlatformUsername);
  });
};

/*
 * User information operations
 */

/**
 * @return {!Promise<?wrm.core.UserInfo>}
 */
wrm.core.SecurityService.prototype.getUserInfo = function() {
  if (!this._userInfo) {
    this._userInfo = this._doGetUserInfo();
  }
  return this._userInfo;
};

/**
 * @private
 * @return {!Promise<?wrm.core.UserInfo>}
 */
wrm.core.SecurityService.prototype._doGetUserInfo = function() {
  var $jscomp$this = this;
  return this._dataService.execute(function(d) {
    return $jscomp$this._selectUserAndRoles(d);
  }).then(function(data) {
    if (!data) {
      return null;
    }
    
    /* Construct a user information object holding all the data */
    var allRoleProperties = {};
    data.roleNames.forEach(function(roleName) {
      allRoleProperties[roleName] = {};
    });
    return new wrm.core.UserInfo(data.username, data.key, data.serverKey, data.properties, allRoleProperties);
  });
};

/**
 * @param {!Object} properties
 * @param {?string} oldPassword
 * @param {?string} newPassword
 * @return {!Promise<!wrm.core.UserInfo>}
 *         <p>
 *         <b>Rejected</b> with {@link wrm.core.ForbiddenErorr} (if the authentication token is no longer valid).
 */
wrm.core.SecurityService.prototype.updateUserInfo = function(properties, oldPassword, newPassword) {
  var $jscomp$this = this;
  var FAKE_USER_OID = 1;
  
  if (!this.isUserServiceAvailable()) {
    throw new Error("User services are not available");
  }
  
  var userEntity = this._getUserEntity();
  var userUsernameServerName = userEntity.getProperty(wrm.Constants.USER_USERNAME_ATT_ID).getServerName();
  if (!userUsernameServerName) {
    throw new Error("Username attribute is not server-mapped");
  }
  
  var store = {};
  var pusher = new wrm.data.sync.ObjectPusher(userEntity, store, this._backEndService, this.getLog());
  var userInfo = null, authInfo = null;
  
  /* Retrieve the current logged user info and the current authentication info */
  return Promise.try(function() {
    return Promise.all([$jscomp$this.getUserInfo(), $jscomp$this._loadPlatformAuth()]);
  }).then(function(userInfoAndAuthInfo) {
    userInfo = userInfoAndAuthInfo[0];
    authInfo = userInfoAndAuthInfo[1] || null;
    
    /* Must have a login and token to update the user */
    if (!userInfo || !authInfo) {
      throw new Error("Must be logged in to update user information");
    }
    
    /* Check the old password */
    if (!!newPassword && oldPassword !== authInfo.password) {
      throw new Error("Old password is invalid");
    }
    
    /*
     * Update on the back-end while backed by a memory object: we cannot modify the database before the back-end succeeds because
     * the contract of this method is to not change the local DB in case of errors.
     */
    store[FAKE_USER_OID] = angular.extend({}, userInfo.getProperties(), properties);
    return pusher.prepareRecordValues(properties, FAKE_USER_OID, authInfo.token);
  }).then(function(outboundRecord) {
    if (!outboundRecord && !newPassword) {
      return null;
    }
    return $jscomp$this._backEndService.updateUser(authInfo.token, userInfo.getServerKey(), oldPassword, newPassword, outboundRecord || {});
  }).then(function(updateResult) {
    if (!updateResult) {
      return;
    }
    
    /* Determine the final credentials and token that are valid after the update */
    var finalUsername = (updateResult.record[(userUsernameServerName)]);
    var finalPassword = (newPassword || authInfo.password);
    var finalToken = authInfo.token;
    
    return Promise.try(function() {
      return Promise.all(pusher.finalizeValues(updateResult.record, properties, FAKE_USER_OID, finalToken));
    }).then(function() {
      
      /*
       * Save the final in-memory state into the database. This is required for correctly applying the resulting record by using
       * the data synchronization, which implies an up-to-date DB. It is not possible to just apply the resulting record.
       */
      return $jscomp$this._replaceUserInfoFromClient(userInfo.getUsername(), userInfo.getServerKey(), store[FAKE_USER_OID], userInfo.getRoleNames());
    }).then(function() {
      
      /* Apply the actual server values to the database */
      return $jscomp$this._mergeUserInfoFromServer(updateResult.record, userInfo.getServerKey(), finalToken, userInfo.getRoleNames());
    }).then(function() {
      
      /* Update authentication information with the final ones */
      wrm.nav.SystemValues.token = finalToken;
      $jscomp$this._setLastUsername(finalUsername);
      return $jscomp$this._savePlatformAuth(finalUsername, finalPassword, finalToken);
    });
  }).then(function() {
    return $jscomp$this.getUserInfo();
  });
};

/**
 * @param {string} username
 * @param {string} password
 * @param {!Object} properties
 * @return {!Promise<!wrm.core.UserInfo>}
 */
wrm.core.SecurityService.prototype.registerUser = function(username, password, properties) {
  var $jscomp$this = this;
  var FAKE_USER_OID = 1;
  
  if (!this.isUserServiceAvailable()) {
    throw new Error("User services are not available");
  }
  
  var userEntity = this._getUserEntity();
  
  var store = {};
  var pusher = new wrm.data.sync.ObjectPusher(userEntity, store, this._backEndService, this.getLog());
  
  /*
   * Register on the back-end while backed by a memory object: we cannot modify the database before the back-end succeeds because the
   * contract of this method is to not change the local DB in case of errors.
   */
  return Promise.try(function() {
    store[FAKE_USER_OID] = properties;
    return pusher.prepareRecordValues(properties, FAKE_USER_OID, null);
  }).then(function(outboundRecord) {
    outboundRecord = outboundRecord || {};
    return $jscomp$this._backEndService.registerUser(username, password, outboundRecord);
  }).then(function(resultRecord) {
    return Promise.all(pusher.finalizeValues(resultRecord, properties, FAKE_USER_OID, null));
  }).then(function() {
    
    /* Save the final in-memory state into the database */
    return $jscomp$this._replaceUserInfoFromClient(username, null, store[FAKE_USER_OID], []);
  }).then(function() {
    return $jscomp$this.getUserInfo();
  });
};

/**
 * @private
 * @param {!Object<string,*>} record
 * @param {*} serverKey
 * @param {string} token
 * @param {!Array<string>} roleNames
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._mergeUserInfoFromServer = function(record, serverKey, token, roleNames) {
  var $jscomp$this = this;
  return this._dataService.execute(function(d) {
    
    /*
     * If the existing user (if any) has a different server key, delete it and proceed as if this was a replace. If the user has
     * the same server key, delete only its roles.
     */
    return $jscomp$this._selectExistingUserServerKey(d).then(function(existingUserServerKey) {
      if (existingUserServerKey !== serverKey) {
        return $jscomp$this._deleteUserAndRoles(d);
      }
      return $jscomp$this._deleteRoles(d);
    }).then(function() {
      
      /* Insert or update the user by synchronizing differentially. Insert roles in all cases */
      return $jscomp$this._synchronizeUserInbound(d, false, record, serverKey, token).then(function(userKey) {
        return $jscomp$this._insertRoles(d, roleNames, userKey).then(function() {
          
          /* Invalidate user info */
          $jscomp$this._userInfo = null;
          
          return userKey;
        });
      });
    });
  });
};

/**
 * @private
 * @param {!Object<string,*>} record
 * @param {*} serverKey
 * @param {string} token
 * @param {!Array<string>} roleNames
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._replaceUserInfoFromServer = function(record, serverKey, token, roleNames) {
  var $jscomp$this = this;
  return this._dataService.execute(function(d) {
    
    /* Delete existing user and roles */
    return $jscomp$this._deleteUserAndRoles(d).then(function() {
      
      /* Insert the user by synchronizing fully. Insert roles with direct queries */
      return $jscomp$this._synchronizeUserInbound(d, true, record, serverKey, token).then(function(userKey) {
        return $jscomp$this._insertRoles(d, roleNames, userKey).then(function() {
          
          /* Invalidate user info */
          $jscomp$this._userInfo = null;
          
          return userKey;
        });
      });
    });
  });
};

/**
 * @private
 * @param {string} username
 * @param {?*} serverKey
 * @param {!Object<string,*>} properties
 * @param {!Array<string>} roleNames
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._replaceUserInfoFromClient = function(username, serverKey, properties, roleNames) {
  var $jscomp$this = this;
  return this._dataService.execute(function(d) {
    
    /* Delete existing user and roles */
    return $jscomp$this._deleteUserAndRoles(d).then(function() {
      
      /* Insert the user and the roles with direct queries */
      return $jscomp$this._insertUser(d, username, serverKey, properties).then(function(userKey) {
        return $jscomp$this._insertRoles(d, roleNames, userKey).then(function() {
          
          /* Invalidate user info */
          $jscomp$this._userInfo = null;
          
          return userKey;
        });
      });
    });
  });
};

/**
 * @private
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._clearUserInfo = function() {
  var $jscomp$this = this;
  return this._dataService.execute(function(d) {
    return $jscomp$this._deleteUserAndRoles(d);
  }).then(function() {
    
    /* Invalidate user info */
    $jscomp$this._userInfo = null;
  });
};

/*
 * Low-level user information storage on DB
 */

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<?{key:*, username:string, properties:!Object<string,*>, serverKey:?*, roleNames:!Array<string>}>}
 */
wrm.core.SecurityService.prototype._selectUserAndRoles = function(dataContext) {
  var userEntity = this._getUserEntity();
  var userKeyAtt = userEntity.getKeyAttribute();
  var userUsernameAtt = userEntity.getAttribute(wrm.Constants.USER_USERNAME_ATT_ID);
  var userServerKeyAtt = userEntity.getServerKeyAttribute();
  var roleEntity = this._getRoleEntity();
  var roleNameAtt = roleEntity.getAttribute(wrm.Constants.ROLE_NAME_ATT_ID);
  
  /* Select the only user (it is always one because the user entity is "singleton") */
  return dataContext.selectOne(wrm.Constants.USER_ENT_ID, {outputConfig:{useNames:true}}).then(function(userObj) {
    if (!userObj) {
      return null;
    }
    
    /* Extract special attributes from the user object */
    var key = userObj[userKeyAtt.getName()];
    delete userObj[userKeyAtt.getName()];
    var username = userObj[userUsernameAtt.getName()];
    delete userObj[userUsernameAtt.getName()];
    var serverKey = null;
    if (userServerKeyAtt) {
      serverKey = userObj[userServerKeyAtt.getName()];
      delete userObj[userServerKeyAtt.getName()];
    }
    
    /* The remaining values are the extra "properties" of the user */
    var properties = {};
    userEntity.getAttributes().forEach(function(att) {
      if (att !== userKeyAtt && att !== userUsernameAtt && att !== userServerKeyAtt) {
        properties[att.getId()] = userObj[att.getName()];
      }
    });
    
    /* Select all connected roles */
    return dataContext.select(wrm.Constants.ROLE_ENT_ID, {outputConfig:{useNames:true}, filter:wrm.Constants.ROLE_USER_ROL_ID + "." + wrm.Constants.USER_OID_ATT_ID}, [key]).then(function(roleObjs) {
      
      /* Compute the list of role names */
      var roleNames = roleObjs.map(function(roleObj) {
        return roleObj[roleNameAtt.getName()];
      });
      
      return {key:key, username:username, properties:properties, serverKey:serverKey, roleNames:roleNames};
    });
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._deleteUserAndRoles = function(dataContext) {
  var innerPromise = [];
  innerPromise.push(dataContext["delete"](wrm.Constants.ROLE_ENT_ID));
  innerPromise.push(dataContext["delete"](wrm.Constants.USER_ENT_ID));
  return Promise.all(innerPromise);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._deleteRoles = function(dataContext) {
  var innerPromise = [];
  innerPromise.push(dataContext["delete"](wrm.Constants.ROLE_ENT_ID));
  return Promise.all(innerPromise);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<?*>}
 */
wrm.core.SecurityService.prototype._selectExistingUserKey = function(dataContext) {
  var userEntity = this._getUserEntity();
  return dataContext.selectOne(wrm.Constants.USER_ENT_ID, {outputConfig:{useNames:true}, output:userEntity.getKeyAttribute().getId()});
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<?*>}
 */
wrm.core.SecurityService.prototype._selectExistingUserServerKey = function(dataContext) {
  var userEntity = this._getUserEntity();
  return dataContext.selectOne(wrm.Constants.USER_ENT_ID, {outputConfig:{useNames:true}, output:userEntity.getServerKeyAttribute().getId()});
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} forceFull
 * @param {!Object<string,*>} record
 * @param {*} serverKey
 * @param {?string} token
 * @return {!Promise<*>}
 */
wrm.core.SecurityService.prototype._synchronizeUserInbound = function(dataContext, forceFull, record, serverKey, token) {
  var $jscomp$this = this;
  var userEntity = this._getUserEntity();
  
  /*
   * Place the server-originated user information into the server store, so that they can be synchronized inbound as if we were
   * communicating with a data service
   */
  var userServerStore = this._getUserServerStore();
  var recordWithKey = angular.extend({}, record);
  recordWithKey[userEntity.getServerKeyAttribute().getServerName()] = serverKey;
  userServerStore.setData(recordWithKey);
  
  /* Perform an inbound synchronization (this will consume the data set in the server store) */
  return this._getDataSyncService().then(function(dataSyncService) {
    if (forceFull) {
      dataSyncService.clearLastSynchronizationDateTime(userEntity);
    }
    return dataSyncService.synchronize({entities:[userEntity], token:token || undefined}, wrm.nav.newInternalState());
  }).then(function() {
    
    /*
     * Retrieve the local key of the inserted user. This must be done as a separate step because the insertion was done by the data
     * sync service and there is no way to know the key. Ideally, this would not be necessary if the clients did not require the
     * local key to be known. Note that the selection below will always yield at most 1 result because the user entity is
     * "singleton"
     */
    return $jscomp$this._selectExistingUserKey(dataContext);
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {string} username
 * @param {?*} serverKey
 * @param {!Object<string,*>} properties
 * @return {!Promise<*>}
 */
wrm.core.SecurityService.prototype._insertUser = function(dataContext, username, serverKey, properties) {
  var userEntity = this._getUserEntity();
  var userServerKeyAtt = userEntity.getServerKeyAttribute();
  
  /* Prepare an insert object with all user properties */
  var userObj = {};
  angular.extend(userObj, properties);
  userObj[wrm.Constants.USER_USERNAME_ATT_ID] = username;
  if (userServerKeyAtt) {
    userObj[userServerKeyAtt.getId()] = serverKey;
  }
  
  return dataContext.insert(wrm.Constants.USER_ENT_ID, userObj).then(function(keys) {
    return keys[0];
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Array<string>} roleNames
 * @param {*} userKey
 */
wrm.core.SecurityService.prototype._insertRoles = function(dataContext, roleNames, userKey) {
  
  /* Prepare an insert object for each role name */
  var roleObjs = roleNames.map(function(roleName, i) {
    var roleObj = {};
    roleObj[wrm.Constants.ROLE_OID_ATT_ID] = i + 1;
    roleObj[wrm.Constants.ROLE_NAME_ATT_ID] = roleName;
    roleObj[wrm.Constants.ROLE_USER_ROL_ID] = userKey;
    return roleObj;
  });
  
  return dataContext.insert(wrm.Constants.ROLE_ENT_ID, roleObjs);
};

/*
 * Local authentication info persistence
 */

/**
 * @private
 * @param {string} username
 */
wrm.core.SecurityService.prototype._setLastUsername = function(username) {
  var dict = this._dataService.getAuxiliaryDictionary();
  dict.set("_security.lastUsername", username);
};

/**
 * @private
 * @return {?string}
 */
wrm.core.SecurityService.prototype._getLastUsername = function() {
  var dict = this._dataService.getAuxiliaryDictionary();
  return dict.get("_security.lastUsername");
};

/*
 * Global authentication info persistence (cross-application)
 */

/**
 * @private
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._initializeAccountManager = function() {
  var $jscomp$this = this;
  var config = this._accountManagerConfig;
  
  var promises = [];
  var willBeAvailable = false;
  
  /* Set package */
  if (config.packageName) {
    willBeAvailable = true;
    promises.push(wrm.util.invokePlugin(accountmanager.setPackage.bind(accountmanager, config.packageName)));
  }
  
  /* Enable sharing */
  if (config.groupId && config.teamId) {
    willBeAvailable = true;
    promises.push(wrm.util.invokePlugin(accountmanager.enableSharing.bind(accountmanager, config.groupId, config.teamId)));
  }
  
  return Promise.all(promises).then(function() {
    $jscomp$this._accountManagerAvailable = willBeAvailable;
  });
};

/**
 * @private
 * @return {undefined}
 */
wrm.core.SecurityService.prototype._checkAccountManagerAvailable = function() {
  if (!this._accountManagerAvailable) {
    throw new Error("Account manager not available");
  }
};

/**
 * @private
 * @param {boolean} includeUsername
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._clearPlatformAuth = function(includeUsername) {
  if (DEBUG) {
    this._checkAccountManagerAvailable();
  }
  
  /* Set username, password and token together */
  var promises = [];
  if (includeUsername) {
    promises.push(wrm.util.invokePlugin(accountmanager.setUsername.bind(accountmanager, null)));
  }
  promises.push(wrm.util.invokePlugin(accountmanager.setPassword.bind(accountmanager, null)));
  promises.push(wrm.util.invokePlugin(accountmanager.setToken.bind(accountmanager, null)));
  wrm.nav.SystemValues.token = null;
  return Promise.all(promises);
};

/**
 * @private
 * @param {string} username
 * @param {string} password
 * @param {?string} token
 * @return {!Promise}
 */
wrm.core.SecurityService.prototype._savePlatformAuth = function(username, password, token) {
  if (DEBUG) {
    this._checkAccountManagerAvailable();
  }
  
  /* Set username, password and token together */
  var promises = [];
  promises.push(wrm.util.invokePlugin(accountmanager.setUsername.bind(accountmanager, username)));
  promises.push(wrm.util.invokePlugin(accountmanager.setPassword.bind(accountmanager, password)));
  promises.push(wrm.util.invokePlugin(accountmanager.setToken.bind(accountmanager, token)));
  wrm.nav.SystemValues.token = token;
  return Promise.all(promises);
};

/**
 * @private
 * @return {!Promise<{username:string,password:string,token:?string}|undefined>}
 */
wrm.core.SecurityService.prototype._loadPlatformAuth = function() {
  return (this._doLoadPlatformAuth(false));
};

/**
 * @private
 * @return {!Promise<{username:?string,password:?string,token:?string}>}
 */
wrm.core.SecurityService.prototype._loadPartialPlatformAuth = function() {
  return (this._doLoadPlatformAuth(true));
};

/**
 * @private
 * @param {boolean} allowPartial
 * @return {!Promise<{username:string,password:string,token:?string}|undefined>}
 */
wrm.core.SecurityService.prototype._doLoadPlatformAuth = function(allowPartial) {
  if (DEBUG) {
    this._checkAccountManagerAvailable();
  }
  
  /* Get username, password and token together */
  var promises = [];
  promises.push(wrm.util.invokePlugin(accountmanager.getUsername.bind(accountmanager)));
  promises.push(wrm.util.invokePlugin(accountmanager.getPassword.bind(accountmanager)));
  promises.push(wrm.util.invokePlugin(accountmanager.getToken.bind(accountmanager)));
  
  /* When all are got, return them in an object */
  return Promise.all(promises).then(function(results) {
    var username = results[0];
    var password = results[1];
    var token = results[2];
    
    wrm.nav.SystemValues.token = token;
    
    if (allowPartial || username && password) {
      return {username:username, password:password, token:token};
    }
    return null;
  });
};




//== wrm/data/DataMigrator.js =================================================


/**
 * @package
 * @constructor
 * @param {!wrm.Log} log
 */
wrm.data.DataMigrator = function(log) {
  
  /** @private */
  this._log = log;
};

/**
 * @param {!wrm.data.meta.MetadataDiff} diff
 * @param {!wrm.data.DataContext} dataContext return {!Promise}
 */
wrm.data.DataMigrator.prototype.migrate = function(diff, dataContext) {
  var changedEntities = diff.getChangedEntities();
  var replacedAssociations = diff.getReplacedAssociationsIdPairs();
  if (changedEntities.length <= 0 && replacedAssociations.length <= 0) {
    return Promise.resolve();
  }
  
  return Promise.resolve().then(function() {
    
    /* Migrate all changed entities */
    return changedEntities.reduce(function(chain, entityDiff) {
      return chain.then(function() {
        return this._migrateEntity(entityDiff, dataContext);
      }.bind(this));
    }.bind(this), Promise.resolve());
    
  }.bind(this)).then(function() {
    
    /* Migrate all replaced associations */
    return replacedAssociations.reduce(function(chain, assocIds) {
      return chain.then(function() {
        return this._migrateAssociation(assocIds, dataContext);
      }.bind(this));
    }.bind(this), Promise.resolve());
    
  }.bind(this));
};

/**
 * @private
 * @param {!wrm.data.meta.EntityDiff} entityDiff
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.DataMigrator.prototype._migrateEntity = function(entityDiff, dataContext) {
  var log = this._log;
  var metadata = dataContext.getMetadata();
  var queryFactory = dataContext.getQueryFactory();
  var entity = metadata.getEntity(entityDiff.getId());
  var keyAttr = entity.getKeyAttribute();
  
  var processedCount = 0;
  /** @type {!Array<{older:!wrm.data.meta.Attribute, newer:!wrm.data.meta.Attribute, failedCount:number}>} */
  var attrPairs = entityDiff.getReplacedAttributesIdPairs().map(function(attrIds) {
    return {older:metadata.getAttribute(attrIds.older), newer:metadata.getAttribute(attrIds.newer), failedCount:0};
  });
  attrPairs = attrPairs.filter(function(attrs) {
    
    /* Exclude migrating to file-stored BLOB attributes until they can be migrated (bug #11033) */
    if (!!entity.getServerName() && attrs.newer.getType() === wrm.data.Type.BLOB && attrs.newer.isOnFileSystem()) {
      log.warn("Skipping migration of values in", entity, "from", attrs.older, "to file-stored", attrs.newer, "(expecting to synchronize the files later)");
      return false;
    }
    
    return true;
  });
  if (attrPairs.length <= 0) {
    return Promise.resolve();
  }
  
  if (log.isDebugEnabled()) {
    log.debug("Migrating values in", entity, "\n" + attrPairs.map(function(attrs) {
      return " from " + attrs.older + " to " + attrs.newer;
    }).join("\n"));
  }
  
  /* Prepare the query for selecting values from the old attributes */
  var oldOutputs = {};
  attrPairs.map(function(attrs) {
    oldOutputs[attrs.older.getId()] = attrs.older.getId();
  });
  var oldSelectQuery = queryFactory.prepareSelect(entity.getId(), {output:oldOutputs, outputConfig:{useNames:true}, filter:[{property:entity.getKeyAttribute().getId(), valueInput:"_key"}]});
  
  /* Prepare the query for updating values into the new attributes */
  var newUpdateQuery = queryFactory.prepareNewUpdate(entity.getId(), {update:function(parameters) {
    var values = {};
    attrPairs.forEach(function(attrs) {
      var newValue = null;
      try {
        newValue = wrm.data.toSingle(attrs.newer.getType(), parameters[attrs.older.getId()]);
      } catch (e) {
        attrs.failedCount++;
      }
      values[attrs.newer.getId()] = newValue;
    });
    return values;
  }, filter:{property:keyAttr.getId(), valueInput:"_key"}});
  
  /* Select all keys of existing instances */
  return dataContext.select(entity.getId(), {output:keyAttr.getId(), outputConfig:{useNames:true}}).then(function(keys) {
    processedCount = keys.length;
    
    /* Update each instance by first selecting the old values and then updating/converting */
    return keys.reduce(function(chain, key) {
      return chain.then(function() {
        return oldSelectQuery.queryOne(dataContext, {"_key":key});
      }).then(function(oldValues) {
        oldValues["_key"] = key;
        return newUpdateQuery.executeGetChanged(dataContext, oldValues);
      });
    }, Promise.resolve());
  }).then(function() {
    
    /* Done */
    attrPairs.forEach(function(attrs) {
      if (attrs.failedCount > 0) {
        log.warn("Failed conversion of", attrs.failedCount, "value from", attrs.older, "to", attrs.newer);
      }
    });
    log.debug("Migration of values in", processedCount, "instances done");
  });
};

/**
 * @private
 * @param {{older:string,newer:string}} assocIds
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.DataMigrator.prototype._migrateAssociation = function(assocIds, dataContext) {
  var log = this._log;
  var metadata = dataContext.getMetadata();
  var queryFactory = dataContext.getQueryFactory();
  var oldAssoc = metadata.getAssociation(assocIds.older);
  var oldKeyAttr1 = oldAssoc.getEntity1().getKeyAttribute();
  var oldKeyAttr2 = oldAssoc.getEntity2().getKeyAttribute();
  var oldKeyRef1 = oldAssoc.getRole1().getId() + "." + oldKeyAttr1.getId();
  var oldKeyRef2 = oldAssoc.getRole2().getId() + "." + oldKeyAttr2.getId();
  var newAssoc = metadata.getAssociation(assocIds.newer);
  var newKeyAttr1 = newAssoc.getEntity1().getKeyAttribute();
  var newKeyAttr2 = newAssoc.getEntity2().getKeyAttribute();
  var newKeyRef1 = newAssoc.getRole1().getId() + "." + newKeyAttr1.getId();
  var newKeyRef2 = newAssoc.getRole2().getId() + "." + newKeyAttr2.getId();
  
  log.debug("Migrating connections from", oldAssoc, "to", newAssoc);
  
  var processedCount = 0;
  var failedCount = 0;
  
  /* Prepare the query for inserting tuples into the new association */
  var newInsertQuery = queryFactory.prepareNewAssociationInsert(newAssoc.getId(), function(parameters) {
    var values = {};
    try {
      values[newKeyRef1] = wrm.data.toSingle(newKeyAttr1.getType(), parameters["key1"]);
      values[newKeyRef2] = wrm.data.toSingle(newKeyAttr2.getType(), parameters["key2"]);
      return values;
    } catch (e) {
      failedCount++;
      return {};
    }
  });
  
  /* Select all tuples from the old association */
  return dataContext.selectAssociationNew(oldAssoc.getId(), {output:{"key1":oldKeyRef1, "key2":oldKeyRef2}, outputConfig:{useNames:true}}).then(function(oldTuples) {
    processedCount = oldTuples.length;
    
    /* Insert converted old tuples into the new association */
    return oldTuples.reduce(function(chain, oldTuple) {
      return chain.then(function() {
        return newInsertQuery.execute(dataContext, oldTuple);
      });
    }, Promise.resolve());
  }).then(function() {
    
    /* Done */
    if (failedCount > 0) {
      log.warn("Failed conversion of", failedCount, "connections");
    }
    log.debug("Migration of", processedCount, "connections done");
  });
};




//== wrm/data/JQuery.js =======================================================

/**
 * @constructor
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 */
wrm.data.JQuery = function(metadata, entityId) {
  
  /** @private */
  this._metadata = metadata;
  
  /** @private */
  this._entity = metadata.getEntity(entityId);
  
  /**
   * @private
   * @type {!Object.<string,boolean>}
   */
  this._includedRoles = {};
  
  /**
   * @private
   * @type {!Array.<!wrm.data.PropertyRef>}
   */
  this._includedRoleRefs = [];
  
  /**
   * @private
   * @type {!Array.<!wrm.data.ChangeListenerOld>}
   */
  this._changeListeners = [];
  
  /**
   * @private
   * @type {?wrm.data.JDChangeTracker}
   */
  this._changeTracker = null;
  
  /**
   * @private
   * @type {!Array.<!wrm.data.meta.Attribute>}
   */
  this._exposedMetaAttributes = [];
};

/**
 * @return {!wrm.data.meta.Entity}
 */
wrm.data.JQuery.prototype.getEntity = function() {
  return this._entity;
};

/**
 * @protected
 * @param {!wrm.data.PropertyRef} roleRef
 */
wrm.data.JQuery.prototype.addIncludedRole = function(roleRef) {
  if (DEBUG && (!roleRef || !(roleRef.getProperty() instanceof wrm.data.meta.Role))) {
    throw new Error("Invalid included role ref");
  }
  
  /* Keep the prefix of the role path that JayData can include */
  var rolePath = roleRef.getPhysicalRef().getRoles();
  rolePath = wrm.data.JDPropertyFiller.getIncludableRoles(rolePath);
  
  var added = this._doAddIncludedRole(rolePath.map(function(role) {
    return role.getName();
  }).join("."));
  
  if (added) {
    this._includedRoleRefs.push(roleRef);
  }
};

/**
 * @private
 * @param {string} resolvedRoleReference
 * @return {boolean}
 */
wrm.data.JQuery.prototype._doAddIncludedRole = function(resolvedRoleReference) {
  var added = this._includedRoles[resolvedRoleReference] !== true;
  this._includedRoles[resolvedRoleReference] = true;
  
  var lastDotIndex = resolvedRoleReference.lastIndexOf(".");
  if (lastDotIndex >= 0) {
    this._doAddIncludedRole(resolvedRoleReference.substring(0, lastDotIndex));
  }
  
  return added;
};

/**
 * @protected
 * @return {!Array.<string>}
 */
wrm.data.JQuery.prototype.getIncludedRoles = function() {
  return Object.keys(this._includedRoles);
};

/**
 * @protected
 * @return {!Array.<!wrm.data.PropertyRef>}
 */
wrm.data.JQuery.prototype.getIncludedRoleRefs = function() {
  return this._includedRoleRefs;
};

/**
 * @protected
 * @const
 * @param {!wrm.data.DataContext} dataContext
 */
wrm.data.JQuery.prototype.checkDataContext = function(dataContext) {
  if (dataContext.getMetadata() !== this._metadata) {
    throw new Error("The query was created against a different set of metadata");
  }
};

/**
 * @internal
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity=} entity
 * @return {!$data.EntitySet}
 */
wrm.data.JQuery.prototype.retrieveEntitySet = function(dataContext, entity) {
  return wrm.data.DataContextHelper.retrieveEntitySet(dataContext, entity || this._entity);
};

/**
 * @internal
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object} parameters
 * @return {?$data.Queryable}
 */
wrm.data.JQuery.prototype.createQueryable = function(dataContext, parameters) {
  var q = this.retrieveEntitySet(dataContext);
  
  /* Apply included roles */
  angular.forEach(this._includedRoles, function(b, includedRole) {
    q = q.include(includedRole);
  });
  
  return q;
};

/**
 * @internal
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object} object
 * @return {!$data.Entity}
 */
wrm.data.JQuery.prototype.includeInContext = function(dataContext, object) {
  return wrm.data.DataContextHelper.includeInContext(dataContext, object);
};

/**
 * @internal
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!$data.Queryable} queryable
 * @param {function(?=)} iterator
 * @return {!Promise.<!Array>}
 */
wrm.data.JQuery.prototype.iterateResults = function(dataContext, queryable, iterator) {
  return wrm.data.DataContextHelper.iterateResults(dataContext, queryable, iterator);
};

/**
 * @internal
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!$data.Queryable} queryable
 * @return {!Promise.<!Array>}
 */
wrm.data.JQuery.prototype.loadResults = function(dataContext, queryable) {
  return wrm.data.DataContextHelper.loadResults(dataContext, queryable);
};

/**
 * @internal
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JQuery.prototype.saveChanges = function(dataContext) {
  return wrm.data.DataContextHelper.saveChanges(dataContext);
};

/*
 * Listeners
 */

/**
 * @param {!wrm.data.ChangeListenerOld} changeListener
 */
wrm.data.JQuery.prototype.addChangeListener = function(changeListener) {
  this._changeListeners.push(changeListener);
};

/**
 * @param {!wrm.data.ChangeListenerOld} changeListener
 */
wrm.data.JQuery.prototype.removeChangeListener = function(changeListener) {
  for (var i = 0;i < this._changeListeners.length;i++) {
    if (this._changeListeners[i] === changeListener) {
      this._changeListeners.splice(i, 1);
      return;
    }
  }
};

/**
 * @protected
 * @return {boolean}
 */
wrm.data.JQuery.prototype.hasChangeListeners = function() {
  return this._changeListeners.length > 0;
};

/**
 * @protected
 * @param {!Object} newInstance
 */
wrm.data.JQuery.prototype.notifyInstanceInserted = function(newInstance) {
  var entity = this._entity;
  this._changeListeners.forEach(function(listener) {
    try {
      listener.instanceInserted(entity, newInstance);
    } catch (e) {
      console.error("Change listener failed", e);
    }
  });
};

/**
 * @protected
 * @param {!Object} oldInstance Instance that was updated, in its previous state.
 * @param {!Object} newInstance Instance that was updated, in its new state.
 */
wrm.data.JQuery.prototype.notifyInstanceUpdated = function(oldInstance, newInstance) {
  var entity = this._entity;
  this._changeListeners.forEach(function(listener) {
    try {
      listener.instanceUpdated(entity, oldInstance, newInstance);
    } catch (e) {
      console.error("Change listener failed", e);
    }
  });
};

/**
 * @protected
 * @param {!Object} oldInstance Instance that was deleted.
 */
wrm.data.JQuery.prototype.notifyInstanceDeleted = function(oldInstance) {
  var entity = this._entity;
  this._changeListeners.forEach(function(listener) {
    try {
      listener.instanceDeleted(entity, oldInstance);
    } catch (e) {
      console.error("Change listener failed", e);
    }
  });
};

/*
 * Change tracking
 */

/**
 * @package
 * @param {?wrm.data.JDChangeTracker} changeTracker
 */
wrm.data.JQuery.prototype.setChangeTracker = function(changeTracker) {
  this._changeTracker = changeTracker;
};

/**
 * @package
 * @return {?wrm.data.JDChangeTracker}
 */
wrm.data.JQuery.prototype.getChangeTracker = function() {
  return this._changeTracker;
};

/**
 * @package
 * @param {!$data.Entity} object
 * @return {!Promise.<!$data.Entity>}
 */
wrm.data.JQuery.prototype.enlistForInsert = function(object) {
  if (!this._changeTracker) {
    return Promise.resolve(object);
  }
  return this._changeTracker.enlistForInsert(object);
};

/**
 * @package
 * @param {!$data.Entity} object
 * @return {!Promise.<!$data.Entity>}
 */
wrm.data.JQuery.prototype.enlistForUpdate = function(object) {
  if (!this._changeTracker) {
    return Promise.resolve(object);
  }
  return this._changeTracker.enlistForUpdate(object);
};

/**
 * @package
 * @param {!$data.Entity} object
 * @return {!Promise.<!$data.Entity>}
 */
wrm.data.JQuery.prototype.enlistForDelete = function(object) {
  if (!this._changeTracker) {
    return Promise.resolve(object);
  }
  return this._changeTracker.enlistForDelete(object);
};

/*
 * Meta attributes
 */

/**
 * @param {...string} families
 */
wrm.data.JQuery.prototype.setExposedMetaAttributes = function(families) {
  var thisQuery = this;
  
  var attributes = [];
  Array.prototype.forEach.call(arguments, function(family) {
    thisQuery._entity.getAttributes().forEach(function(attr) {
      if (attr instanceof wrm.data.meta.RegularAttribute) {
        var metaAttr = attr.getMetaAttribute(family);
        if (metaAttr) {
          attributes.push(metaAttr);
        }
      }
    });
  });
  this._exposedMetaAttributes = attributes;
};

/**
 * @return {!Array.<!wrm.data.meta.Attribute>}
 */
wrm.data.JQuery.prototype.getExposedMetaAttributes = function() {
  return this._exposedMetaAttributes;
};




//== wrm/util/ObjectMapper.js =================================================


/**
 * @constructor
 * @param {!Object=} object
 */
wrm.util.ObjectMapper = function(object) {
  
  /**
   * @private
   * @type {!Object}
   */
  this._object = object || {};
  
  /** @private */
  this._flattenArrays = false;
};

/**
 * @return {!Object}
 */
wrm.util.ObjectMapper.prototype.getObject = function() {
  return this._object;
};

/**
 * @param {boolean} flattenArrays
 */
wrm.util.ObjectMapper.prototype.setFlattenArrays = function(flattenArrays) {
  this._flattenArrays = flattenArrays;
};

/**
 * @param {string|!Array.<string>} path
 * @return {*}
 */
wrm.util.ObjectMapper.prototype.getValue = function(path) {
  var result = undefined;
  this._walkValues(this._object, this._parseSteps(path), false, false, function(value) {
    result = value;
  });
  return result;
};

/**
 * @param {string|!Array.<string>} path
 * @return {!Array.<*>}
 */
wrm.util.ObjectMapper.prototype.getValues = function(path) {
  var flattenArrays = this._flattenArrays;
  var result = [];
  this._walkValues(this._object, this._parseSteps(path), false, true, function(value) {
    if (flattenArrays && angular.isArray(value)) {
      Array.prototype.push.apply(result, (value));
    } else {
      result.push(value);
    }
  });
  return result;
};

/**
 * @param {string|!Array.<string>} path
 * @param {*} value
 * @return {*}
 */
wrm.util.ObjectMapper.prototype.setValue = function(path, value) {
  var result = undefined;
  this._walkValues(this._object, this._parseSteps(path), true, false, function(oldValue, key, object) {
    object[key] = value;
    result = oldValue;
  });
  return result;
};

/**
 * @private
 * @param {string|!Array.<string>} path
 * @return {!Array.<string>}
 */
wrm.util.ObjectMapper.prototype._parseSteps = function(path) {
  if (!path || path.length <= 0) {
    throw new Error("Path is empty");
  }
  if (angular.isArray(path)) {
    return (path);
  }
  if (typeof path !== "string") {
    return [String(path)];
  }
  return path.split(".");
};

/**
 * @private
 * @param {*} target
 * @param {!Array.<string>} steps
 * @param {boolean} create
 * @param {boolean} multiple
 * @param {function(*,string=,!Object=)} callback
 */
wrm.util.ObjectMapper.prototype._walkValues = function(target, steps, create, multiple, callback) {
  if (typeof target !== "object") {
    throw new Error("Cannot access a single value across primitives");
  }
  if (angular.isArray(target)) {
    if (!multiple) {
      throw new Error("Cannot access a single value across arrays");
    }
    for (var i = 0;i < target.length;i++) {
      this._walkValues(target[i], steps, create, multiple, callback);
    }
    return;
  }
  
  var step = steps[0];
  
  if (steps.length > 1) {
    var nextTarget = target[step];
    if (create && !nextTarget) {
      target[step] = nextTarget = {};
    }
    if (nextTarget) {
      this._walkValues(nextTarget, steps.slice(1), create, multiple, callback);
    }
    return;
  }
  
  var value = target[step];
  if (create || value !== undefined) {
    callback(value, step, (target));
  }
};




//== wrm/data/LateFilteredQueryable.js ========================================



/**
 * @package
 * @constructor
 * @extends $data.Queryable
 * @param {!$data.Queryable} queryable
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<string>} includedRoleRefs
 * @param {!wrm.data.DataContext} dataContext
 */
wrm.data.LateFilteredQueryable = function(queryable, entity, includedRoleRefs, dataContext) {
  
  /** @private */
  this._queryable = queryable;
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._includedRoleRefs = includedRoleRefs;
  
  /** @private */
  this._dataContext = dataContext;
  
  /**
   * @private
   * @type {?function(!Object,!wrm.data.DataContext):!Promise.<boolean>}
   */
  this._filterFunction = null;
  
  /**
   * @private
   * @type {?function(!Object,!Object,!wrm.data.DataContext):!Promise}
   */
  this._mapperFunction = null;
  
  /**
   * @private
   * @type {?Object}
   */
  this._includedRolesTree = null;
  
  /**
   * @private
   * @type {?function(?):*}
   */
  this._mapFunction = null;
  
  /**
   * @private
   * @type {?number}
   */
  this._skipAmount = null;
  
  /**
   * @private
   * @type {?number}
   */
  this._takeAmount = null;
};

/**
 * @package
 * @param {function(!Object,!wrm.data.DataContext):!Promise.<boolean>} filterFunction
 */
wrm.data.LateFilteredQueryable.prototype.initFilterFunction = function(filterFunction) {
  if (this._filterFunction) {
    throw new Error("Filter function already initialized");
  }
  this._filterFunction = filterFunction;
};

/**
 * @package
 * @param {function(!Object,!Object,!wrm.data.DataContext):!Promise} mapperFunction
 */
wrm.data.LateFilteredQueryable.prototype.initMapperFunction = function(mapperFunction) {
  if (this._mapperFunction) {
    throw new Error("Includer function already initialized");
  }
  this._mapperFunction = mapperFunction;
};

/*
 * Forbidden operations
 */

/** @override */
wrm.data.LateFilteredQueryable.prototype.filter = function(predicate, thisArg) {
  throw new Error("Further filtering not possible");
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.removeAll = function(onResult, transaction) {
  throw new Error("RemoveAll not supported");
};

/*
 * Mutation operations fully delegated to the wrapped queryable
 */

/** @override */
wrm.data.LateFilteredQueryable.prototype.include = function(selector) {
  return this._wrap(this._queryable.include(selector));
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.orderBy = function(selector, thisArg) {
  return this._wrap(this._queryable.orderBy(selector, thisArg));
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.orderByDescending = function(selector, thisArg) {
  return this._wrap(this._queryable.orderByDescending(selector, thisArg));
};

/*
 * Mutation operations changing the state of this wrapper (implemented later during 'toArray')
 */

/** @override */
wrm.data.LateFilteredQueryable.prototype.map = function(projection, thisArg) {
  if (this._mapFunction) {
    throw new Error("Already called 'map' on this queryable");
  }
  
  /* Normalize the projection to a context-bound function */
  var mapFunction;
  var projectionFunction = this._normalizeLambdaFunction(true, projection);
  if (thisArg) {
    mapFunction = projectionFunction.bind(thisArg);
  } else {
    mapFunction = projectionFunction;
  }
  
  return this._wrap(this._queryable, {mapFunction:mapFunction});
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.skip = function(amount) {
  if (this._skipAmount !== null) {
    throw new Error("Already called 'skip' on this queryable");
  }
  return this._wrap(this._queryable, {skipAmount:amount});
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.take = function(amount) {
  if (this._takeAmount !== null) {
    throw new Error("Already called 'take' on this queryable");
  }
  return this._wrap(this._queryable, {takeAmount:amount});
};

/*
 * Query operations implemented atop the (re-implemented) 'toArray'
 */

/** @override */
wrm.data.LateFilteredQueryable.prototype.first = function(filterPredicate, onResult, transaction) {
  var filterFunction = this._normalizeLambdaFunction(!this._mapFunction, filterPredicate);
  return this._runQueryOperation(function(result) {
    for (var i = 0;i < result.length;i++) {
      var element = result[i];
      if (filterFunction(element)) {
        return element;
      }
    }
    throw new Error("Found no element");
  }, onResult, transaction);
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.single = function(filterPredicate, onResult, transaction) {
  var filterFunction = this._normalizeLambdaFunction(!this._mapFunction, filterPredicate);
  return this._runQueryOperation(function(result) {
    var foundElement = undefined;
    for (var i = 0;i < result.length;i++) {
      var element = result[i];
      if (filterFunction(element)) {
        if (foundElement === undefined) {
          foundElement = element;
        } else {
          throw new Error("Found more than one element");
        }
      }
    }
    if (foundElement === undefined) {
      throw new Error("Found no element");
    }
    return foundElement;
  }, onResult, transaction);
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.some = function(filterPredicate, onResult, transaction) {
  var filterFunction = this._normalizeLambdaFunction(!this._mapFunction, filterPredicate);
  return this._runQueryOperation(function(result) {
    return result.some(filterFunction);
  }, onResult, transaction);
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.every = function(filterPredicate, onResult, transaction) {
  var filterFunction = this._normalizeLambdaFunction(!this._mapFunction, filterPredicate);
  return this._runQueryOperation(function(result) {
    return result.every(filterFunction);
  }, onResult, transaction);
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.length = function(onResult, transaction) {
  return this._runQueryOperation(function(result) {
    return result.length;
  }, onResult, transaction);
};

/** @override */
wrm.data.LateFilteredQueryable.prototype.forEach = function(iterator, transaction) {
  return this._runQueryOperation(function(result) {
    result.forEach(iterator);
    return result;
  }, undefined, transaction);
};
/**
 * @private
 * @template R
 * @param {function(!Array):R} resultTransformer
 * @param {{success:(function(R)|undefined), error:(function(*)|undefined)}|function(R)=} onResult
 * @param {!$data.Transaction=} transaction
 * @return {!Promise.<R>}
 */
wrm.data.LateFilteredQueryable.prototype._runQueryOperation = function(resultTransformer, onResult, transaction) {
  var thisQueryable = this;
  
  /* Get all results and transform them */
  var promise = Promise.resolve().then(function() {
    return thisQueryable.toArray(undefined, transaction);
  }).then(function(result) {
    return resultTransformer(result);
  });
  
  /* Attach result handlers to the promise */
  if (onResult) {
    var successHandler, errorHandler;
    if (typeof onResult === "function") {
      successHandler = onResult;
      errorHandler = undefined;
    } else {
      successHandler = onResult.success || undefined;
      errorHandler = onResult.error || undefined;
    }
    promise = promise.then(successHandler, errorHandler);
  }
  
  return promise;
};

/*
 * Basic late-filtered query operation
 */

/** @override */
wrm.data.LateFilteredQueryable.prototype.toArray = function(onResult, transaction) {
  var dataContext = this._dataContext;
  var filterFunction = this._filterFunction;
  var mapperFunction = this._mapperFunction;
  var mapFunction = this._mapFunction || angular.identity;
  var toSkip = this._skipAmount || 0;
  var toTake = this._takeAmount !== null ? this._takeAmount : -1;
  
  /* Run the internal queryable, transforming the list of results */
  var results = [];
  var promise = this._queryable.toArray(onResult, transaction).then(function(allResults) {
    return allResults.reduce(function(chain, internalObject) {
      return chain.then(function() {
        if (filterFunction) {
          return filterFunction(internalObject, dataContext);
        }
        return true;
      }).then(function(filterResult) {
        
        /* Filter out objects not matching the filter */
        if (!filterResult) {
          return;
        }
        
        /* Check and update skip/take counters */
        if (toSkip > 0) {
          toSkip--;
          return;
        }
        if (toTake === 0) {
          return;
        } else {
          if (toTake > 0) {
            toTake--;
          }
        }
        
        /* Map on the external result */
        var object = mapFunction(internalObject);
        if (mapperFunction) {
          return mapperFunction(object, internalObject, dataContext).then(function() {
            results.push(object);
          });
        } else {
          results.push(object);
        }
      });
    }, Promise.resolve());
  });
  
  return promise.then(function() {
    return results;
  });
};

/*
 * Utilities
 */

/**
 * @package
 * @param {!$data.Queryable} queryable
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<string>} includedRoleRefs
 * @param {!wrm.data.DataContext} dataContext
 */
wrm.data.LateFilteredQueryable.wrap = function(queryable, entity, includedRoleRefs, dataContext) {
  if (queryable instanceof wrm.data.LateFilteredQueryable) {
    if (DEBUG) {
      if (queryable._entity !== entity || queryable._dataContext !== dataContext) {
        throw new Error("The late-filtered queryable being wrapped has a different configuration");
      }
    }
    return queryable;
  }
  return new wrm.data.LateFilteredQueryable(queryable, entity, includedRoleRefs, dataContext);
};

/**
 * @private
 * @param {!$data.Queryable} queryable
 * @param {{mapFunction:((?function(?):*)|undefined), skipAmount:(?number|undefined), takeAmount:(?number|undefined)}=} newFields
 * @return {!wrm.data.LateFilteredQueryable}
 */
wrm.data.LateFilteredQueryable.prototype._wrap = function(queryable, newFields) {
  if (DEBUG && queryable instanceof wrm.data.LateFilteredQueryable) {
    throw new Error("Must wrap a real queryable");
  }
  
  var wrapperQueryable = new wrm.data.LateFilteredQueryable(queryable, this._entity, this._includedRoleRefs, this._dataContext);
  wrapperQueryable._mapperFunction = this._mapperFunction;
  wrapperQueryable._filterFunction = this._filterFunction;
  
  if (newFields && newFields.mapFunction !== undefined) {
    wrapperQueryable._mapFunction = newFields.mapFunction;
  } else {
    wrapperQueryable._mapFunction = this._mapFunction;
  }
  
  if (newFields && newFields.skipAmount !== undefined) {
    wrapperQueryable._skipAmount = newFields.skipAmount;
  } else {
    wrapperQueryable._skipAmount = this._skipAmount;
  }
  
  if (newFields && newFields.takeAmount !== undefined) {
    wrapperQueryable._takeAmount = newFields.takeAmount;
  } else {
    wrapperQueryable._takeAmount = this._takeAmount;
  }
  
  return wrapperQueryable;
};

/**
 * @private
 * @template R
 * @param {boolean} safeInstanceAccess
 * @param {string|function(!Object):R=} expression
 * @return {function(!Object):R}
 */
wrm.data.LateFilteredQueryable.prototype._normalizeLambdaFunction = function(safeInstanceAccess, expression) {
  
  /* With no expression, return a trivial function */
  if (typeof expression === "undefined") {
    return function(it) {
      return true;
    };
  }
  
  /* Normalize the expression to a core function */
  var result;
  if (typeof expression === "function") {
    result = expression;
  } else {
    result = this._createCoreLambdaFunction(String(expression));
  }
  
  /* Provide safe access to the instance object (if asked to) */
  if (safeInstanceAccess) {
    result = this._createSafeLambdaFunction(result);
  }
  
  return result;
};

/**
 * @private
 * @template R
 * @param {function(!Object):R} coreFunction
 * @return {function(!Object):R}
 */
wrm.data.LateFilteredQueryable.prototype._createSafeLambdaFunction = function(coreFunction) {
  var createSafeInstanceObject = this._createSafeInstanceObject.bind(this);
  var isNullLikeValue = this._isNullLikeValue.bind(this);
  
  return function(it) {
    var ret = coreFunction(createSafeInstanceObject(it));
    if (isNullLikeValue(ret)) {
      return null;
    } else {
      if (typeof ret === "object") {
        Object.keys(ret).forEach(function(key) {
          if (isNullLikeValue(ret[key])) {
            ret[key] = null;
          }
        });
      }
    }
    return ret;
  };
};

/**
 * @private
 * @template R
 * @param {string} expression
 * @return {function(!Object):R}
 */
wrm.data.LateFilteredQueryable.prototype._createCoreLambdaFunction = function(expression) {
  return new Function(["it"], "return " + expression);
};

/**
 * @private
 * @param {!Object} it
 * @return {!Object}
 */
wrm.data.LateFilteredQueryable.prototype._createSafeInstanceObject = function(it) {
  var result = {};
  
  /* Copy the values of all properties */
  this._entity.getProperties().forEach(function(property) {
    var name = property.getName();
    result[name] = it[name];
  });
  
  /* Function for recursively filling in missing roles */
  function fillMissingRoles(object, roles) {
    for (var roleName in roles) {
      if (!roles.hasOwnProperty(roleName)) {
        continue;
      }
      
      /* Normalize the value to an empty object marked with a special property */
      var value = object[roleName];
      if (value === null || value === undefined) {
        value = {};
        Object.defineProperty(value, "_wr_null", {value:true});
        object[roleName] = value;
      }
      
      /* Fill in connected roles */
      fillMissingRoles(value, roles[roleName]);
    }
  }
  
  /* Fill in missing roles */
  fillMissingRoles(result, this._getIncludedRolesTree());
  
  return result;
};

/**
 * @private
 * @param {*} value
 * @return {boolean}
 */
wrm.data.LateFilteredQueryable.prototype._isNullLikeValue = function(value) {
  return !!value && value["_wr_null"] === true;
};

/**
 * @private
 * @return {!Object}
 */
wrm.data.LateFilteredQueryable.prototype._getIncludedRolesTree = function() {
  if (this._includedRolesTree) {
    return this._includedRolesTree;
  }
  
  var om = new wrm.util.ObjectMapper;
  this._includedRoleRefs.forEach(function(roleRef) {
    om.setValue(roleRef, {});
  });
  
  var tree = this._includedRolesTree = om.getObject();
  return tree;
};




//== wrm/data/KeyOnlyQueryable.js =============================================



/**
 * @package
 * @constructor
 * @extends $data.Queryable
 * @param {!$data.Queryable} queryable
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<number>} keyValues
 */
wrm.data.KeyOnlyQueryable = function(queryable, entity, keyValues) {
  
  /** @private */
  this._queryable = queryable;
  
  /**
   * @private
   * @type {!wrm.data.meta.Entity}
   */
  this._entity = entity;
  
  /**
   * @private
   * @type {!Array.<number>}
   */
  this._keyValues = keyValues;
  
};

/*
 * Forbidden operations
 */

/** @override */
wrm.data.KeyOnlyQueryable.prototype.filter = function(predicate, thisArg) {
  throw new Error("Further filtering not possible");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.removeAll = function(onResult, transaction) {
  throw new Error("RemoveAll not supported");
};

/*
 * Mutation operations fully delegated to the wrapped queryable
 */

/** @override */
wrm.data.KeyOnlyQueryable.prototype.include = function(selector) {
  throw new Error("Further include not possible");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.orderBy = function(selector, thisArg) {
  throw new Error("Further order not possible");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.orderByDescending = function(selector, thisArg) {
  throw new Error("Further order not possible");
};

/*
 * Mutation operations changing the state of this wrapper (implemented later during 'toArray')
 */

/** @override */
wrm.data.KeyOnlyQueryable.prototype.map = function(projection, thisArg) {
  throw new Error("Further map not possible");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.skip = function(amount) {
  throw new Error("Further skip not possible");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.take = function(amount) {
  throw new Error("Further take not possible");
};

/*
 * Query operations implemented atop the (re-implemented) 'toArray'
 */

/** @override */
wrm.data.KeyOnlyQueryable.prototype.first = function(filterPredicate, onResult, transaction) {
  throw new Error("First method not supported");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.single = function(filterPredicate, onResult, transaction) {
  throw new Error("Single method not supported");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.some = function(filterPredicate, onResult, transaction) {
  throw new Error("Some method not supported");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.every = function(filterPredicate, onResult, transaction) {
  throw new Error("Every method not supported");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.length = function(onResult, transaction) {
  throw new Error("Length method not supported");
};

/** @override */
wrm.data.KeyOnlyQueryable.prototype.forEach = function(iterator, transaction) {
  return this._runQueryOperation(function(result) {
    result.forEach(iterator);
    return result;
  }, transaction);
};
/**
 * @private
 * @template R
 * @param {function(!Array):R} resultTransformer
 * @param {!$data.Transaction=} transaction
 * @return {!Promise.<R>}
 */
wrm.data.KeyOnlyQueryable.prototype._runQueryOperation = function(resultTransformer, transaction) {
  var thisQueryable = this;
  
  /* Get all results and transform them */
  return Promise.resolve().then(function() {
    return thisQueryable.toArray(undefined, transaction);
  }).then(function(result) {
    return resultTransformer(result);
  });
};

/*
 * Fake toArray operation
 */

/** @override */
wrm.data.KeyOnlyQueryable.prototype.toArray = function(onResult, transaction) {
  var arrayResult = [];
  var entity = this._entity;
  var keyAttName = entity.getKeyAttribute().getName();
  var getType = function() {
    return entity.getName();
  };
  this._keyValues.forEach(function(keyValue) {
    var obj = {};
    obj[keyAttName] = keyValue;
    obj["getType"] = getType;
    arrayResult.push(obj);
  });
  return Promise.resolve(arrayResult);
};

/*
 * Utilities
 */

/**
 * @package
 * @param {!$data.Queryable} queryable
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<number>|number} keyValues
 */
wrm.data.KeyOnlyQueryable.wrap = function(queryable, entity, keyValues) {
  if (queryable instanceof wrm.data.KeyOnlyQueryable) {
    return queryable;
  }
  if (DEBUG) {
    if (!(queryable instanceof $data.EntitySet)) {
      throw new Error("Must receive an EntitySet");
    }
  }
  if (typeof keyValues === "number") {
    keyValues = [keyValues];
  }
  return new wrm.data.KeyOnlyQueryable(queryable, entity, keyValues);
};




//== wrm/data/FilteredQuery.js ================================================



/**
 * @constructor
 * @extends wrm.data.JQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {!Array.<string>|string=} includes
 * @param {!wrm.data.Condition|!wrm.data.Condition.Expression=} filter
 */
wrm.data.FilteredQuery = function(metadata, entityId, includes, filter) {
  wrm.data.JQuery.call(this, metadata, entityId);
  
  /* Process explicit included roles in options */
  this._processExplicitIncludes(includes);
  
  /** @private */
  this._condition = this._createCondition(metadata, entityId, filter);
  
  /**
   * @private
   * @type {boolean}
   */
  this._fastQuerySupport = false;
};

extendConstructor(wrm.data.FilteredQuery, wrm.data.JQuery);

/**
 * @private
 * @param {!Array.<string>|string=} includes
 */
wrm.data.FilteredQuery.prototype._processExplicitIncludes = function(includes) {
  if (!includes) {
    return;
  }
  
  if (!angular.isArray(includes)) {
    includes = [includes];
  }
  
  /* Resolve each include reference keep track of it */
  angular.forEach((includes), function(include) {
    var ref = wrm.data.PropertyRef.of(this.getEntity(), include);
    if (!(ref.getProperty() instanceof wrm.data.meta.Role)) {
      throw new Error("Cannot include non-role '" + include + "'");
    }
    this.addIncludedRole(ref);
  }, this);
};

/**
 * @private
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {!wrm.data.Condition|!wrm.data.Condition.Expression|undefined} filter
 * @return {?wrm.data.Condition}
 */
wrm.data.FilteredQuery.prototype._createCondition = function(metadata, entityId, filter) {
  if (!filter) {
    return null;
  }
  
  /* Constructs a condition object for the passed filter */
  var condition;
  if (filter instanceof wrm.data.Condition) {
    condition = filter;
  } else {
    condition = new wrm.data.Condition(metadata, entityId, filter);
  }
  
  /* Merge the included roles required by the conditions with the set of this query */
  angular.forEach(condition.getIncludedRoleRefs(), function(roleRef) {
    this.addIncludedRole(roleRef);
  }, this);
  
  return condition;
};

/**
 * @package
 * @return {?wrm.data.Condition}
 */
wrm.data.FilteredQuery.prototype.getCondition = function() {
  return this._condition;
};

/**
 * @override
 * @internal
 */
wrm.data.FilteredQuery.prototype.createQueryable = function(dataContext, parameters) {
  var q = wrm.data.FilteredQuery._super.createQueryable.call(this, dataContext, parameters);
  if (!q) {
    return null;
  }
  
  /* Apply a filter created by the condition */
  if (this._condition) {
    
    /* Use special light queryable if it is possible */
    var onlyKeyConditionInputName = this._condition.getOnlyKeyConditionInputName();
    if (this._fastQuerySupport && onlyKeyConditionInputName) {
      q = wrm.data.KeyOnlyQueryable.wrap(q, this.getEntity(), parameters[onlyKeyConditionInputName]);
      return q;
    }
    
    var filter = this._condition.createFilter(dataContext, parameters);
    if (filter.notApplicable) {
      return null;
    }
    if (filter.predicate) {
      q = q.filter(filter.predicate, filter.inputs);
    }
    if (filter.evaluator) {
      q = wrm.data.LateFilteredQueryable.wrap(q, this.getEntity(), this.getIncludedRoles(), dataContext);
      q.initFilterFunction(filter.evaluator);
    }
  }
  
  return q;
};

/**
 * @protected
 * @param {boolean} enable
 */
wrm.data.FilteredQuery.prototype.setFastQuery = function(enable) {
  this._fastQuerySupported = enable;
};




//== wrm/data/JDeleteQuery.js =================================================



/**
 * @constructor
 * @extends wrm.data.FilteredQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {{ include: (!Array<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=}
 *            options
 */
wrm.data.JDeleteQuery = function(metadata, entityId, options) {
  wrm.data.FilteredQuery.call(this, metadata, entityId, options && options.include, options && options.filter);
  
  /** @private */
  this._cascadeDeleteFunction = this._createCascadeDeleteFunction();
};

extendConstructor(wrm.data.JDeleteQuery, wrm.data.FilteredQuery);

/**
 * @private
 * @return {?function(!Array<*>, !wrm.data.DataContext):!Promise}
 */
wrm.data.JDeleteQuery.prototype._createCascadeDeleteFunction = function() {
  var entity = this.getEntity();
  
  /* Prepare cascade-delete functions */
  var roleCascadeDeleteFunctions = [];
  var assocIds = {};
  entity.getRoles().forEach(function(role) {
    
    /* Ignore roles from the same association (recursive associations) */
    var assoc = role.getAssociation();
    var assocId = assoc.getId();
    if (assocIds[assocId] === true) {
      return;
    }
    assocIds[assocId] = true;
    
    var accessor = wrm.data.RoleAccessor.get(role);
    if (accessor.isCascadeDeleteRequired()) {
      roleCascadeDeleteFunctions.push(accessor.cascadeDelete.bind(accessor));
    }
  });
  
  /* Prepare a single cascade-delete function */
  var cascadeDeleteFunction;
  if (roleCascadeDeleteFunctions.length > 0) {
    cascadeDeleteFunction = function(keys, dataContext) {
      return roleCascadeDeleteFunctions.reduce(function(chain, fn) {
        return chain.then(function() {
          return fn(keys, dataContext);
        });
      }, Promise.resolve());
    };
  } else {
    cascadeDeleteFunction = null;
  }
  
  return cascadeDeleteFunction;
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.JDeleteQuery.prototype.execute = function(dataContext, parameters) {
  var thisQuery = this;
  
  this.checkDataContext(dataContext);
  var entitySet = this.retrieveEntitySet(dataContext);
  var q = this.createQueryable(dataContext, parameters || {});
  if (!q) {
    return Promise.resolve(0);
  }
  
  /* Remove each matched object */
  var deletedObjects = [];
  var promise = Promise.resolve().then(function(updateFunction) {
    var deletePromise = Promise.resolve();
    return thisQuery.iterateResults(dataContext, (q), function(object) {
      
      /* Body */
      deletePromise = deletePromise.then(function() {
        return thisQuery.enlistForDelete(object);
      }).then(function(object) {
        entitySet.remove(object);
        
        /* Keep track of deleted objects */
        deletedObjects.push(object);
      });
    }).then(function() {
      return deletePromise;
    });
  });
  
  /* Save changes */
  promise = promise.then(function() {
    return thisQuery.saveChanges(dataContext);
  });
  
  /* Cascade along associations of deleted objects */
  promise = promise.then(function() {
    
    /* Collect the keys of all deleted objects */
    var keyAttName = thisQuery.getEntity().getKeyAttribute().getName();
    var deletedKeys = deletedObjects.map(function(object) {
      return object[keyAttName];
    });
    
    var postOperationPromises = [thisQuery._disconnectDeletedObjects(deletedKeys, dataContext)].concat(thisQuery._postDeleteBlobs(deletedKeys));
    return Promise.all(postOperationPromises);
  });
  
  return promise.then(function() {
    
    /* Notify listeners */
    if (thisQuery.hasChangeListeners()) {
      deletedObjects.forEach(thisQuery.notifyInstanceDeleted.bind(thisQuery));
    }
    
    /* Return the count of deleted objects */
    return deletedObjects.length;
  });
};

/**
 * @private
 * @param {!Array} deletedKeys
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDeleteQuery.prototype._disconnectDeletedObjects = function(deletedKeys, dataContext) {
  if (!this._cascadeDeleteFunction) {
    return Promise.resolve();
  }
  
  /* Execute all cascade functions */
  return this._cascadeDeleteFunction(deletedKeys, dataContext);
};

/**
 * @private
 * @param {!Array} deletedKeys
 * @return {!Array<Promise>}
 */
wrm.data.JDeleteQuery.prototype._postDeleteBlobs = function(deletedKeys) {
  var propertyPostSetPromises = [];
  propertyPostSetPromises.push(Promise.resolve());
  
  var attributes = this.getEntity().getAttributes();
  deletedKeys.forEach(function(keyValue) {
    var attributeFound = false;
    attributes.forEach(function(attribute) {
      if (!attributeFound && wrm.data.JDDataMover.isPostOperationRequired(attribute)) {
        attributeFound = true;
        propertyPostSetPromises.push(wrm.data.JDDataMover.postDelete(attribute, keyValue));
      }
    });
  });
  
  return propertyPostSetPromises;
};




//== wrm/data/JDDataMover.js ==================================================



/**
 * Internal logic for loading JayData values on insert/update objects and unloading them off result objects.
 * 
 * @package
 * @const
 */
wrm.data.JDDataMover = {};

/**
 * @package
 * @param {!Object} object
 * @param {!wrm.data.meta.Property} property
 * @param {*|!Array<*>} value
 * @return {!Promise|undefined}
 */
wrm.data.JDDataMover.load = function(object, property, value) {
  
  /* For arrays, load at each index of the value */
  if (angular.isArray(value)) {
    return value.reduce(function(chain, valueElement, index) {
      return chain.then(function() {
        return wrm.data.JDDataMover._doLoad(object, property, index, valueElement);
      });
    }, Promise.resolve());
  }
  
  /* For scalars, just load the value */
  return wrm.data.JDDataMover._doLoad(object, property, null, value);
};

/**
 * @private
 * @param {!Object} object
 * @param {!wrm.data.meta.Property} property
 * @param {?number} valueIndex
 * @param {*} value
 * @return {!Promise|undefined}
 */
wrm.data.JDDataMover._doLoad = function(object, property, valueIndex, value) {
  
  /* Special case for binary values */
  if (property instanceof wrm.data.meta.Attribute && value instanceof wrm.data.Blob) {
    return wrm.data.JDDataMover._loadBlob(object, property, valueIndex, value);
  }
  
  /* Default case: set the passed value by name */
  wrm.data.JDDataMover._set(object, property.getName(), valueIndex, value);
};

/**
 * @package
 * @param {!Array<!wrm.data.meta.Property>} properties
 * @return {!Array<!wrm.data.meta.Property>}
 */
wrm.data.JDDataMover.computeAdditionalUnloadProperties = function(properties) {
  var result = [];
  properties.forEach(function(property) {
    
    /* Special case for binary properties */
    if (property instanceof wrm.data.meta.Attribute && property.getType() === wrm.data.Type.BLOB) {
      wrm.data.JDDataMover._addBlobUnloadProperties(result, property);
    }
    
    /* Default case: no additional property */
  });
  return result;
};

/**
 * @package
 * @param {!Object} resultObject
 * @param {!wrm.data.meta.Property} property
 * @param {string} propertyId
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<*>|*}
 */
wrm.data.JDDataMover.unload = function(resultObject, property, propertyId, dataContext) {
  var mainRawValue = resultObject[propertyId];
  
  /* For arrays, unload at each index of the main raw value */
  if (angular.isArray(mainRawValue)) {
    return Promise.all(mainRawValue.map(function(elment, index) {
      return wrm.data.JDDataMover._doUnload(resultObject, property, propertyId, index, dataContext);
    }));
  }
  
  return wrm.data.JDDataMover._doUnload(resultObject, property, propertyId, null, dataContext);
};

/**
 * @private
 * @param {!Object} resultObject
 * @param {!wrm.data.meta.Property} property
 * @param {string} propertyId
 * @param {?number} valueIndex
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<*>|*}
 */
wrm.data.JDDataMover._doUnload = function(resultObject, property, propertyId, valueIndex, dataContext) {
  
  /* Read the raw value */
  var rawValue = wrm.data.JDDataMover._get(resultObject, propertyId, valueIndex);
  if (rawValue === undefined) {
    return undefined;
  }
  
  /* Special case for binary values */
  if (property instanceof wrm.data.meta.Attribute && property.getType() === wrm.data.Type.BLOB) {
    return wrm.data.JDDataMover._unloadBlob(resultObject, property, valueIndex, rawValue);
  }
  
  /* Default case for roles: use the raw value */
  if (property instanceof wrm.data.meta.Role) {
    return rawValue;
  }
  
  /* Default case: cast the raw value */
  return dataContext.castToSingleValue(property, rawValue);
};

/*
 * Blob
 */

/**
 * @private
 * @param {!Object} object
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?number} valueIndex
 * @param {!wrm.data.Blob} blob
 * @return {!Promise}
 */
wrm.data.JDDataMover._loadBlob = function(object, attribute, valueIndex, blob) {
  var attrName = attribute.getName();
  
  /* Set content type */
  var contentTypeAttr = attribute.getMetaAttribute("contentType");
  if (contentTypeAttr) {
    wrm.data.JDDataMover._set(object, contentTypeAttr.getName(), valueIndex, blob.getContentType());
  }
  
  /* Set file name */
  var fileNameAttr = attribute.getMetaAttribute("fileName");
  if (fileNameAttr) {
    wrm.data.JDDataMover._set(object, fileNameAttr.getName(), valueIndex, blob.getMetadata().fileName);
  }
  
  /* Set Availability status */
  var statusAttr = attribute.getMetaAttribute("status");
  if (statusAttr) {
    wrm.data.JDDataMover._set(object, statusAttr.getName(), valueIndex, blob.getMetadata().availabilityStatus);
  }
  
  if (!wrm.data.JDDataMover.isPostOperationRequired(attribute)) {
    
    /* Load contents */
    return blob.read().then(function(buffer) {
      wrm.data.JDDataMover._set(object, attrName, valueIndex, buffer);
    });
  } else {
    return Promise.resolve();
  }
};

/**
 * @private
 * @param {!Array<!wrm.data.meta.Property>} addedProperties
 * @param {!wrm.data.meta.Attribute} attribute
 */
wrm.data.JDDataMover._addBlobUnloadProperties = function(addedProperties, attribute) {
  
  /* Content type */
  var contentTypeAttr = attribute.getMetaAttribute("contentType");
  if (contentTypeAttr) {
    addedProperties.push(contentTypeAttr);
  }
  
  /* File name */
  var fileNameAttr = attribute.getMetaAttribute("fileName");
  if (fileNameAttr) {
    addedProperties.push(fileNameAttr);
  }
  
  /* Server File Id */
  var serverFileIdAttr = attribute.getMetaAttribute("serverFileId");
  if (serverFileIdAttr) {
    addedProperties.push(serverFileIdAttr);
  }
  
  /* Status */
  var statusAttr = attribute.getMetaAttribute("status");
  if (statusAttr) {
    addedProperties.push(statusAttr);
  }
};

/**
 * @private
 * @param {!Object} resultObject
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {?number} valueIndex
 * @param {!*} rawValue
 * @return {!Promise<!wrm.data.Blob>|!Promise<null>}
 */
wrm.data.JDDataMover._unloadBlob = function(resultObject, attribute, valueIndex, rawValue) {
  if (rawValue === null) {
    var statusAttr = attribute.getMetaAttribute("status");
    if (statusAttr && resultObject[statusAttr.getId()] !== wrm.data.AvailabilityStatus.AVAILABLE) {
      return Promise.resolve(new wrm.data.Blob(new Uint8Array([]), undefined, {availabilityStatus:resultObject[attribute.getMetaAttribute("status").getId()]}));
    }
    return Promise.resolve(null);
  }
  
  /* Extract content type */
  var contentType = undefined;
  var contentTypeAttr = attribute.getMetaAttribute("contentType");
  if (contentTypeAttr) {
    contentType = wrm.data.JDDataMover._get(resultObject, contentTypeAttr.getId(), valueIndex) || undefined;
  }
  
  /* Extract file name */
  var fileName = null;
  var fileNameAttr = attribute.getMetaAttribute("fileName");
  if (fileNameAttr) {
    fileName = wrm.data.JDDataMover._get(resultObject, fileNameAttr.getId(), valueIndex) || null;
  }
  
  /* Extract server file id */
  var serverFileId = null;
  var serverFileIdAttr = attribute.getMetaAttribute("serverFileId");
  if (serverFileIdAttr) {
    serverFileId = wrm.data.JDDataMover._get(resultObject, serverFileIdAttr.getId(), valueIndex) || null;
  }
  
  /* Extract server file id */
  var availabilityStatusCode = null;
  var availabilityStatusAttr = attribute.getMetaAttribute("status");
  if (availabilityStatusAttr) {
    availabilityStatusCode = wrm.data.JDDataMover._get(resultObject, availabilityStatusAttr.getId(), valueIndex) || null;
  }
  
  if (!wrm.data.JDDataMover.isPostOperationRequired(attribute)) {
    
    /* Invoke the BLOB converter directly with content type and metadata */
    return Promise.resolve(wrm.data.Converters.BLOB_CONVERTER(rawValue, contentType, {fileName:fileName, contentSignature:serverFileId, availabilityStatus:availabilityStatusCode}));
  } else {
    return wrm.data.JDDataMover._postRetrieveBlob((rawValue), contentType, fileName, serverFileId, availabilityStatusCode);
  }
};

/*
 * Utilities
 */

/**
 * @private
 * @param {!Object} object
 * @param {string} propertyId
 * @param {?number} valueIndex
 */
wrm.data.JDDataMover._get = function(object, propertyId, valueIndex) {
  if (valueIndex !== null) {
    var array = object[propertyId];
    return array && array[valueIndex];
  } else {
    return object[propertyId];
  }
};

/**
 * @private
 * @param {!Object} object
 * @param {string} propertyName
 * @param {?number} valueIndex
 * @param {*} value
 */
wrm.data.JDDataMover._set = function(object, propertyName, valueIndex, value) {
  if (valueIndex !== null) {
    object[propertyName][valueIndex] = value;
  } else {
    object[propertyName] = value;
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Attribute} attribute
 * @return {boolean}
 */
wrm.data.JDDataMover.isPostOperationRequired = function(attribute) {
  return attribute.isOnFileSystem();
};

/**
 * @package
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*} keyValue
 * @param {!wrm.data.Blob} blob
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDDataMover.postCreate = function(attribute, keyValue, blob, dataContext) {
  var path = wrm.data.JDDataMover._computePath(attribute, keyValue);
  var fileName = attribute.getId();
  return wrm.data.JDDataMover._retrieveFileEntry(path, fileName).then(function(fileEntry) {
    return wrm.data.JDDataMover._computeInsert(fileEntry, attribute, blob, keyValue, path, fileName, dataContext);
  });
};

/**
 * @private
 * @param {string} path
 * @param {string} contentType
 * @param {string} fileName
 * @param {?string} contentSignature
 * @param {?wrm.data.AvailabilityStatus} availabilityStatusCode
 * @return {!Promise}
 */
wrm.data.JDDataMover._postRetrieveBlob = function(path, contentType, fileName, contentSignature, availabilityStatusCode) {
  var pathAndFileName = /(^.+)[/]([^/]+)$/.exec(path);
  return wrm.data.JDDataMover._retrieveFileEntry(pathAndFileName[1], pathAndFileName[2]).then(function(fileEntry) {
    return new Promise(function(resolve, reject) {
      fileEntry.file(function(file) {
        resolve(wrm.data.Blob.fromFile(file, contentType, {fileName:fileName}));
      }, wrm.util.toErrorReject(reject));
    });
  });
};

/**
 * @package
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*} keyValue
 * @param {?wrm.data.Blob} blob
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDDataMover.postUpdate = function(attribute, keyValue, blob, dataContext) {
  if (blob) {
    return wrm.data.JDDataMover.postCreate(attribute, keyValue, blob, dataContext);
  } else {
    var path = wrm.data.JDDataMover._computePath(attribute, keyValue);
    var fileName = attribute.getId();
    return wrm.data.JDDataMover._retrieveFileEntry(path, fileName).then(function(fileEntry) {
      return wrm.data.JDDataMover._doDeleteEntry(fileEntry);
    });
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*} keyValue
 * @return {!Promise}
 */
wrm.data.JDDataMover.postDelete = function(attribute, keyValue) {
  var path = wrm.data.JDDataMover._computePath(attribute, keyValue);
  return wrm.data.JDDataMover._retrieveDirectoryEntry(path).then(function(directory) {
    return wrm.data.JDDataMover._doDeleteEntry(directory);
  });
};

/**
 * @private
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {*} keyValue
 * @return {string}
 */
wrm.data.JDDataMover._computePath = function(attribute, keyValue) {
  return wrm.blobDirectoryName + "/" + attribute.getEntity().getId() + "/" + keyValue + "/";
};

/**
 * @private
 * @param {string} path
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.data.JDDataMover._retrieveDirectoryEntry = function(path) {
  return wrm.util.fs.retrievePersistentDirectory().then(function(persistentDirEntry) {
    return wrm.util.fs.retrieveDirectory(persistentDirEntry, path);
  });
};

/**
 * @private
 * @param {string} path
 * @param {string} fileName
 * @return {!Promise<!FileEntry>}
 */
wrm.data.JDDataMover._retrieveFileEntry = function(path, fileName) {
  return wrm.data.JDDataMover._retrieveDirectoryEntry(path).then(function(directory) {
    return wrm.util.fs.createNamedFile(directory, fileName);
  });
};

/**
 * @private
 * @param {!Entry} entry
 * @return {!Promise}
 */
wrm.data.JDDataMover._doDeleteEntry = function(entry) {
  return wrm.util.fs.deleteEntry(entry);
};

/**
 * @private
 * @param {!FileEntry} fileEntry
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {!wrm.data.Blob} blob
 * @param {*} keyValue
 * @param {string} path
 * @param {string} fileName
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDDataMover._computeInsert = function(fileEntry, attribute, blob, keyValue, path, fileName, dataContext) {
  var entitySet = wrm.data.DataContextHelper.retrieveEntitySet(dataContext, attribute.getEntity());
  
  return blob.writeIntoFileEntry(fileEntry).then(function() {
    return entitySet.filter("it." + attribute.getEntity().getKeyAttribute().getName() + " \x3d\x3d\x3d this.key", {"key":keyValue}).first();
  }).then(function(obj) {
    obj = entitySet.attachOrGet(obj);
    obj[attribute.getName()] = path + fileName;
  });
};




//== wrm/data/DataContextHelper.js ============================================


/**
 * @package
 * @const
 */
wrm.data.DataContextHelper = {};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @param {!wrm.data.meta.Entity} entity
 * @return {!$data.EntitySet}
 */
wrm.data.DataContextHelper.retrieveEntitySet = function(dataContext, entity) {
  var entitySetName = entity.getSetName();
  var entitySet = wrm.data.DataContextHelper._getEntityContext(dataContext)[entitySetName];
  if (!entitySet) {
    throw new Error("Invalid entity set '" + entitySetName + "'");
  }
  return entitySet;
};

/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object} object
 * @return {!$data.Entity}
 */
wrm.data.DataContextHelper.includeInContext = function(dataContext, object) {
  return wrm.data.DataContextHelper._getEntityContext(dataContext).attachOrGet(object);
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!$data.EntityContext}
 */
wrm.data.DataContextHelper._getEntityContext = function(dataContext) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "getEntityContext");
};

/**
 * @package
 * @param {!wrm.data.DataContext} dataContext
 * @return {!$data.Transaction|undefined}
 */
wrm.data.DataContextHelper.getTransaction = function(dataContext) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "getTransaction");
};

/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!$data.Queryable} queryable
 * @param {function(?=)} iterator
 * @return {!Promise.<!Array>}
 */
wrm.data.DataContextHelper.iterateResults = function(dataContext, queryable, iterator) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "iterateResults", [queryable, iterator]);
};

/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!$data.Queryable} queryable
 * @return {!Promise.<!Array>}
 */
wrm.data.DataContextHelper.loadResults = function(dataContext, queryable) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "loadResults", [queryable]);
};

/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.DataContextHelper.saveChanges = function(dataContext) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "saveChanges");
};
/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.Database}
 */
wrm.data.DataContextHelper.getXDataDatabase = function(dataContext) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "getXDataDatabase");
};
/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} useNewishQueries
 * @return {!xdata.Transaction}
 */
wrm.data.DataContextHelper.getXDataTransaction = function(dataContext, useNewishQueries) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "getXDataTransaction", [false, useNewishQueries]);
};
/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {boolean} useNewishQueries
 * @return {!xdata.Transaction}
 */
wrm.data.DataContextHelper.getXDataTransactionNew = function(dataContext, useNewishQueries) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "getXDataTransaction", [true, useNewishQueries]);
};
/**
 * @package
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<!xdata.Session>}
 */
wrm.data.DataContextHelper.openXDataSession = function(dataContext) {
  return wrm.data.DataContextHelper._callDataContextMethod(dataContext, "openXDataSession");
};

/**
 * @private
 * @template R
 * @param {!wrm.data.DataContext} dataContext
 * @param {string} methodName
 * @param {!Array<*>=} args
 * @return {R}
 */
wrm.data.DataContextHelper._callDataContextMethod = function(dataContext, methodName, args) {
  
  /*
   * Pretty hacky, supporting only JDDataContext in the end. Ideally, operations requiring this method should be moved into the
   * DataContext interface (costly, since would require decoupling most of JayData).
   */
  
  if (DEBUG && !(methodName in dataContext)) {
    throw new Error("Unsupported data context");
  }
  
  return dataContext[methodName].apply(dataContext, args || []);
};




//== wrm/data/NewQueries.js ===================================================

wrm.data.NewQueries = {};


/*
 * Insert
 */

/**
 * @package
 * @param {!wrm.data.InsertQuery} oldQuery
 * @param {!Array.<(function(!Object):!Object)|!Object>} inserts
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array.<!*>>}
 */
wrm.data.NewQueries.insert = function(oldQuery, inserts, dataContext, parameters) {
  var entity = oldQuery.getEntity();
  var keyAttrName = entity.getKeyAttribute().getName();
  
  var tx = wrm.data.DataContextHelper.getXDataTransaction(dataContext, true);
  
  /* Prepare insert parameters by attribute NAME */
  var xparametersObjects = inserts.map(function(insert) {
    var insertValuesById;
    if (typeof insert === "function") {
      insertValuesById = insert(parameters);
    } else {
      insertValuesById = insert;
    }
    return wrm.data.NewQueries._convertAttributeKeys(entity, insertValuesById);
  });
  var xpropertyNames = Object.keys(xparametersObjects[0]);
  
  var xinsert = wrm.data.NewQueries._getXDataInsertQuery(entity, xpropertyNames, dataContext);
  
  /* Execute the query once for each group of values */
  return Promise.all(xparametersObjects.map(function(xparameters) {
    return xinsert.executeGetKey(tx, xparameters).then(function(key) {
      
      /* Notify listeners */
      if (oldQuery["hasChangeListeners"]()) {
        var object = angular.extend({}, xparameters);
        xparameters[keyAttrName] = key;
        oldQuery["notifyInstanceInserted"](xparameters);
      }
      
      return key;
    });
  }));
};

/**
 * @private
 * @type {!Object<string,!xdata.InsertQuery>}
 */
wrm.data.NewQueries._INSERT_QUERY_CACHE = {};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array<string>} xpropertyNames
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.InsertQuery}
 */
wrm.data.NewQueries._getXDataInsertQuery = function(entity, xpropertyNames, dataContext) {
  var cacheKey = String(entity.getMetadata().getVersion()) + "_" + entity.getId() + "_" + xpropertyNames.join(",");
  var insertQuery = wrm.data.NewQueries._INSERT_QUERY_CACHE[cacheKey];
  if (!insertQuery) {
    var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
    insertQuery = db.prepareInsert(entity.getSetName(), ({inserts:xpropertyNames.map(function(xpropertyName) {
      return {property:xpropertyName, valueInput:xpropertyName};
    })}));
    wrm.data.NewQueries._INSERT_QUERY_CACHE[cacheKey] = insertQuery;
  }
  return insertQuery;
};

/*
 * Update
 */

/**
 * @package
 * @param {!wrm.data.UpdateQuery} oldQuery
 * @param {(function(!Object):!Object)|!Object} update
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.NewQueries.update = function(oldQuery, update, dataContext, parameters) {
  return (wrm.data.NewQueries._update(oldQuery, update, true, dataContext, parameters));
};

/**
 * @package
 * @param {!wrm.data.UpdateQuery} oldQuery
 * @param {(function(!Object):!Object)|!Object} update
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise}
 */
wrm.data.NewQueries.updateNoResult = function(oldQuery, update, dataContext, parameters) {
  return wrm.data.NewQueries._update(oldQuery, update, false, dataContext, parameters);
};

/**
 * @private
 * @param {!wrm.data.UpdateQuery} oldQuery
 * @param {(function(!Object):!Object)|!Object} update
 * @param {boolean} withResult
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>|!Promise>}
 */
wrm.data.NewQueries._update = function(oldQuery, update, withResult, dataContext, parameters) {
  var entity = oldQuery.getEntity();
  var keyAttrName = entity.getKeyAttribute().getName();
  var condition = oldQuery.getCondition();
  
  var tx = wrm.data.DataContextHelper.getXDataTransaction(dataContext, true);
  
  /* Prepare update parameters by attribute NAME */
  var xparameters = function() {
    var updateValuesById;
    if (typeof update === "function") {
      updateValuesById = update(parameters);
    } else {
      updateValuesById = update;
    }
    return wrm.data.NewQueries._convertAttributeKeys(entity, updateValuesById);
  }();
  var xpropertyNames = Object.keys(xparameters);
  
  /* Add the key filtering parameter by attribute NAME */
  var useKeyFilter;
  if (condition) {
    var keyConditionInputName = condition.getOnlyKeyConditionInputName();
    if (keyConditionInputName !== null) {
      xparameters["_keyFilter"] = parameters[keyConditionInputName];
    } else {
      throw new Error("New queries support only conditions on the key attribute");
    }
    useKeyFilter = true;
  } else {
    useKeyFilter = false;
  }
  
  /* Get the XData update query (accepting values for all attributes by NAME) */
  var xupdate = wrm.data.NewQueries._getXDataUpdateQuery(entity, xpropertyNames, useKeyFilter, dataContext);
  
  /* Execute the query */
  return xupdate.execute(tx, xparameters).then(function() {
    
    /* Notify listeners */
    if (oldQuery["hasChangeListeners"]()) {
      var keys = xparameters["_keyFilter"];
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      keys.forEach(function(key) {
        var object = angular.extend({}, xparameters);
        xparameters[keyAttrName] = key;
        delete xparameters["_keyFilter"];
        oldQuery["notifyInstanceUpdated"]({}, object);
      });
    }
    
    if (withResult) {
      return keys;
    }
  });
};

/**
 * @private
 * @type {!Object<string,!xdata.UpdateQuery>}
 */
wrm.data.NewQueries._UPDATE_QUERY_CACHE = {};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array<string>} xpropertyNames
 * @param {boolean} useKeyFilter
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.UpdateQuery}
 */
wrm.data.NewQueries._getXDataUpdateQuery = function(entity, xpropertyNames, useKeyFilter, dataContext) {
  var cacheKey = String(entity.getMetadata().getVersion()) + "_" + entity.getId() + "_" + xpropertyNames.join(",") + (useKeyFilter ? "" : "_nofilter");
  var updateQuery = wrm.data.NewQueries._UPDATE_QUERY_CACHE[cacheKey];
  if (!updateQuery) {
    var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
    updateQuery = db.prepareUpdate(entity.getSetName(), ({updates:xpropertyNames.map(function(xpropertyName) {
      return {property:xpropertyName, valueInput:xpropertyName};
    }), filter:(useKeyFilter ? {property:entity.getKeyAttribute().getName(), valueInput:"_keyFilter"} : undefined)}));
    wrm.data.NewQueries._UPDATE_QUERY_CACHE[cacheKey] = updateQuery;
  }
  return updateQuery;
};

/*
 * Utilities
 */

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Object} object
 * @return {!Object}
 */
wrm.data.NewQueries._convertAttributeKeys = function(entity, object) {
  var result = {};
  var attrs = entity.getAttributes();
  for (var i = 0, len = attrs.length;i < len;i++) {
    var value = object[attrs[i].getId()];
    if (value !== undefined) {
      result[attrs[i].getName()] = value;
    }
  }
  var roles = entity.getRoles();
  for (var i = 0, len = roles.length;i < len;i++) {
    var role = roles[i];
    if (role.isForeignKey()) {
      var farKeyAttr = role.getInverseEntity().getKeyAttribute();
      var value = object[role.getId()];
      if (value !== undefined) {
        result[role.getName() + "." + farKeyAttr.getName()] = value;
      }
    }
  }
  return result;
};




//== wrm/data/RoleAccessor.js =================================================



/**
 * @package
 * @interface
 */
wrm.data.RoleAccessor = function() {
};

/**
 * @package
 * @param {!Object} object
 * @param {!Array|!Object|*} value
 * @param {!wrm.data.DataContext} dataContext
 * @return {boolean}
 */
wrm.data.RoleAccessor.prototype.set = ABSTRACT_METHOD;

/**
 * @package
 * @param {!Object} object
 * @param {!Array|!Object|*} value
 * @param {?wrm.data.JDChangeTracker} changeTracker
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.RoleAccessor.prototype.postSet = ABSTRACT_METHOD;

/**
 * @package
 * @return {boolean}
 */
wrm.data.RoleAccessor.prototype.isCascadeDeleteRequired = ABSTRACT_METHOD;

/**
 * @package
 * @param {!Array.<*>} deletedKeys
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.RoleAccessor.prototype.cascadeDelete = ABSTRACT_METHOD;

/**
 * @private
 * @const
 * @type {!Object.<string,!wrm.data.RoleAccessor>}
 */
wrm.data.RoleAccessor._CACHE = {};

/**
 * @package
 * @param {!wrm.data.meta.Role} role
 * @return {!wrm.data.RoleAccessor}
 */
wrm.data.RoleAccessor.get = function(role) {
  var RoleAccessor = wrm.data.RoleAccessor;
  var cacheKey = String(role.getMetadata().getVersion()) + "," + role.getId();
  var accessor = RoleAccessor._CACHE[cacheKey];
  if (!accessor) {
    if (role.isForeignKey()) {
      accessor = new RoleAccessor._CollapsedFK(role);
    } else {
      if (role.getInverseRole().isForeignKey()) {
        accessor = new RoleAccessor._CollapsedPK(role);
      } else {
        accessor = new RoleAccessor._Bridged(role);
      }
    }
    RoleAccessor._CACHE[cacheKey] = accessor;
  }
  return accessor;
};

/*
 * Base implementation
 */

/**
 * @private
 * @constructor
 * @param {!wrm.data.meta.Role} role
 */
wrm.data.RoleAccessor._Base = function(role) {
  
  /** @private */
  this._role = role;
};

/**
 * @private
 * @param {!Array|!Object|*} value
 * @param {!wrm.data.DataContext} dataContext
 * @return {?Object}
 */
wrm.data.RoleAccessor._Base.prototype._convertToSingleValue = function(value, dataContext) {
  return (dataContext.castToSingleValue(this._role, value));
};

/**
 * @private
 * @param {!Array|!Object|*} value
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Array.<!Object>}
 */
wrm.data.RoleAccessor._Base.prototype._convertToArrayValue = function(value, dataContext) {
  return dataContext.castToArrayValue(this._role, value);
};

/*
 * Collapsed associations on foreign-key side
 */

/**
 * @private
 * @constructor
 * @extends wrm.data.RoleAccessor._Base
 * @implements wrm.data.RoleAccessor
 * @param {!wrm.data.meta.Role} role
 */
wrm.data.RoleAccessor._CollapsedFK = function(role) {
  wrm.data.RoleAccessor._Base.call(this, role);
  
  /** @private */
  this._roleName = role.getName();
};

extendConstructor(wrm.data.RoleAccessor._CollapsedFK, wrm.data.RoleAccessor._Base);

/** @override */
wrm.data.RoleAccessor._CollapsedFK.prototype.set = function(object, value, dataContext) {
  var roleName = this._roleName;
  
  var farObject = this._convertToSingleValue(value, dataContext);
  
  /* Immediately set the far object */
  object[roleName] = farObject;
  return false;
};

/** @override */
wrm.data.RoleAccessor._CollapsedFK.prototype.postSet = function(object, value, changeTracker, dataContext) {
  
  /* Do nothing: the role is set directly on the foreign key side */
  return Promise.resolve();
};

/** @override */
wrm.data.RoleAccessor._CollapsedFK.prototype.isCascadeDeleteRequired = function() {
  return false;
};

/** @override */
wrm.data.RoleAccessor._CollapsedFK.prototype.cascadeDelete = function(deletedKeys, dataContext) {
  
  /* Do nothing: the role is unset directly on the foreign key side */
  return Promise.resolve();
};

/*
 * Collapsed associations on primary-key side
 */

/**
 * @private
 * @constructor
 * @extends wrm.data.RoleAccessor._Base
 * @implements wrm.data.RoleAccessor
 * @param {!wrm.data.meta.Role} role
 */
wrm.data.RoleAccessor._CollapsedPK = function(role) {
  wrm.data.RoleAccessor._Base.call(this, role);
  
  /** @private */
  this._keyName = role.getEntity().getKeyAttribute().getName();
  
  /** @private */
  this._farEntity = role.getInverseEntity();
  
  /** @private */
  this._farKeyName = this._farEntity.getKeyAttribute().getName();
  
  /** @private */
  this._farForeignKeyName = this._role.getInverseRole().getForeignKeyName();
};

extendConstructor(wrm.data.RoleAccessor._CollapsedPK, wrm.data.RoleAccessor._Base);

/** @override */
wrm.data.RoleAccessor._CollapsedPK.prototype.set = function(object, value, dataContext) {
  
  /* The role cannot be set directly on the primary key side: will require post-set */
  return true;
};

/** @override */
wrm.data.RoleAccessor._CollapsedPK.prototype.postSet = function(object, value, changeTracker, dataContext) {
  var DataContextHelper = wrm.data.DataContextHelper;
  var role = this._role;
  var keyName = this._keyName;
  var farKeyName = this._farKeyName;
  var farForeignKeyName = this._farForeignKeyName;
  
  var tx = DataContextHelper.getTransaction(dataContext);
  var farEntitySet = DataContextHelper.retrieveEntitySet(dataContext, this._farEntity);
  var farObjects = this._convertToArrayValue(value, dataContext);
  
  /* Collect the key of the near object */
  var nearKey = object[keyName];
  
  /* Collect all keys of far objects that are being set as value */
  var farKeys = {};
  farObjects.forEach(function(object) {
    var farKey = object[farKeyName];
    if (farKey === undefined || farKey === null) {
      throw new Error("One of the objects being connected has no key");
    }
    farKeys[farKey] = true;
  });
  
  /* Scan all connected objects, nulling out the foreign keys of those that are no longer connected */
  var promise = farEntitySet.filter("it." + farForeignKeyName + " \x3d\x3d\x3d this.nearKey", {"nearKey":nearKey}).forEach(function(farObject) {
    var farKey = farObject[farKeyName];
    if (farKeys[farKey] === true) {
      delete farKeys[farKey];
    } else {
      DataContextHelper.includeInContext(dataContext, farObject);
      farObject[farForeignKeyName] = null;
      if (changeTracker) {
        changeTracker.trackRemovedRoleValue(role, nearKey, farKey);
      }
    }
  }, tx);
  
  /* Connect all new objects that were not already connected */
  promise = promise.then(function() {
    farObjects.forEach(function(farObject) {
      var farKey = farObject[farKeyName];
      if (farKeys[farKey] === true) {
        farObject = farEntitySet.attachOrGet(farObject);
        farObject[farForeignKeyName] = nearKey;
        if (changeTracker) {
          changeTracker.trackAddedRoleValue(role, nearKey, farKey);
        }
      }
    });
  });
  
  return promise.then(function() {
    return DataContextHelper.saveChanges(dataContext);
  });
};

/** @override */
wrm.data.RoleAccessor._CollapsedPK.prototype.isCascadeDeleteRequired = function() {
  return true;
};

/** @override */
wrm.data.RoleAccessor._CollapsedPK.prototype.cascadeDelete = function(keys, dataContext) {
  var DataContextHelper = wrm.data.DataContextHelper;
  var farForeignKeyName = this._farForeignKeyName;
  
  var tx = DataContextHelper.getTransaction(dataContext);
  var farEntitySet = DataContextHelper.retrieveEntitySet(dataContext, this._farEntity);
  
  /* Scan all connected objects, nulling out the foreign keys */
  var promise = farEntitySet.filter("it." + farForeignKeyName + " in this.nearKeys", {"nearKeys":keys}).forEach(function(farObject) {
    DataContextHelper.includeInContext(dataContext, farObject);
    farObject[farForeignKeyName] = null;
  }, tx);
  
  return promise.then(function() {
    return DataContextHelper.saveChanges(dataContext);
  });
};

/*
 * Bridged associations
 */

/**
 * @private
 * @constructor
 * @extends wrm.data.RoleAccessor._Base
 * @implements wrm.data.RoleAccessor
 * @param {!wrm.data.meta.Role} role
 */
wrm.data.RoleAccessor._Bridged = function(role) {
  wrm.data.RoleAccessor._Base.call(this, role);
  
  /** @private */
  this._keyName = role.getEntity().getKeyAttribute().getName();
  
  /** @private */
  this._farKeyName = role.getInverseEntity().getKeyAttribute().getName();
  
  /* Extract information about the association bridge */
  var assoc = role.getAssociation();
  var bridgeEntity = assoc.getBridgeEntity();
  var nearBridgeRole = role === assoc.getRole1() ? bridgeEntity.getRole1() : bridgeEntity.getRole2();
  var farBridgeRole = role === assoc.getRole1() ? bridgeEntity.getRole2() : bridgeEntity.getRole1();
  
  /** @private */
  this._bridgeEntity = bridgeEntity;
  
  /** @private */
  this._nearBridgeRoleName = nearBridgeRole.getName();
  
  /** @private */
  this._farBridgeRoleName = farBridgeRole.getName();
  
  /** @private */
  this._nearBridgeForeignKeyName = nearBridgeRole.getForeignKeyName();
  
  /** @private */
  this._farBridgeForeignKeyName = farBridgeRole.getForeignKeyName();
};

extendConstructor(wrm.data.RoleAccessor._Bridged, wrm.data.RoleAccessor._Base);

/** @override */
wrm.data.RoleAccessor._Bridged.prototype.set = function(object, value, dataContext) {
  
  /* The role cannot be set directly for bridge associations: will require post-set */
  return true;
};

/** @override */
wrm.data.RoleAccessor._Bridged.prototype.postSet = function(object, value, changeTracker, dataContext) {
  var DataContextHelper = wrm.data.DataContextHelper;
  var role = this._role;
  var keyName = this._keyName;
  var farKeyName = this._farKeyName;
  var nearBridgeRoleName = this._nearBridgeRoleName;
  var farBridgeRoleName = this._farBridgeRoleName;
  var nearBridgeForeignKeyName = this._nearBridgeForeignKeyName;
  var farBridgeForeignKeyName = this._farBridgeForeignKeyName;
  
  var tx = DataContextHelper.getTransaction(dataContext);
  var bridgeEntitySet = DataContextHelper.retrieveEntitySet(dataContext, this._bridgeEntity);
  var farObjects = this._convertToArrayValue(value, dataContext);
  
  /* Collect the key of the near object */
  var nearKey = object[keyName];
  
  /* Collect all keys of far objects that are being set as value */
  var farKeys = {};
  farObjects.forEach(function(object) {
    var farKey = object[farKeyName];
    if (farKey === undefined || farKey === null) {
      throw new Error("One of the objects being connected has no key");
    }
    farKeys[farKey] = true;
  });
  
  /* Scan all connected bridge objects, removing those that refer to objects that are no longer connected */
  var keyAttributeName = this._bridgeEntity.getKeyAttribute().getName();
  var promise = bridgeEntitySet.map("{" + keyAttributeName + ":it." + keyAttributeName + ", " + farBridgeForeignKeyName + ":it." + farBridgeForeignKeyName + "}").filter("it." + nearBridgeForeignKeyName + " \x3d\x3d\x3d this.nearKey", {"nearKey":nearKey}).forEach(function(bridgeObject) {
    var farKey = bridgeObject[farBridgeForeignKeyName];
    if (farKeys[farKey] === true) {
      delete farKeys[farKey];
    } else {
      bridgeEntitySet.remove(bridgeObject);
      if (changeTracker) {
        changeTracker.trackRemovedRoleValue(role, nearKey, farKey);
      }
    }
  }, tx);
  
  /* Create bridge referring to all new objects that were not already connected */
  promise = promise.then(function() {
    farObjects.forEach(function(farObject) {
      var farKey = farObject[farKeyName];
      if (farKeys[farKey] === true) {
        var bridgeObject = {};
        bridgeObject[nearBridgeRoleName] = object;
        bridgeObject[farBridgeRoleName] = farObject;
        bridgeEntitySet.add(bridgeObject);
        if (changeTracker) {
          changeTracker.trackAddedRoleValue(role, nearKey, farKey);
        }
      }
    });
  });
  
  return promise.then(function() {
    return DataContextHelper.saveChanges(dataContext);
  });
};

/** @override */
wrm.data.RoleAccessor._Bridged.prototype.isCascadeDeleteRequired = function() {
  return true;
};

/** @override */
wrm.data.RoleAccessor._Bridged.prototype.cascadeDelete = function(keys, dataContext) {
  var DataContextHelper = wrm.data.DataContextHelper;
  var nearBridgeForeignKeyName = this._nearBridgeForeignKeyName;
  
  var tx = DataContextHelper.getTransaction(dataContext);
  var bridgeEntitySet = DataContextHelper.retrieveEntitySet(dataContext, this._bridgeEntity);
  
  /* Scan all connected bridge objects, removing them */
  var promise = bridgeEntitySet.filter("it." + nearBridgeForeignKeyName + " in this.nearKeys", {"nearKeys":keys}).forEach(function(bridgeObject) {
    bridgeEntitySet.remove(bridgeObject);
  }, tx);
  
  return promise.then(function() {
    return DataContextHelper.saveChanges(dataContext);
  });
};




//== wrm/data/InsertQuery.js ==================================================



/**
 * @constructor
 * @extends wrm.data.JQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {!Array<(function(!Object):!Object)|!Object>|(function(!Object):!Object)|!Object} insert
 */
wrm.data.InsertQuery = function(metadata, entityId, insert) {
  wrm.data.JQuery.call(this, metadata, entityId);
  
  /**
   * @private
   * @type {!Array<(function(!Object):!Object)|!Object>}
   */
  this._inserts;
  
  /* Store the values to insert in an array */
  if (angular.isArray(insert)) {
    this._inserts = insert.slice(0);
  } else {
    if (insert) {
      this._inserts = [insert];
    } else {
      throw new Error("Insert values not specified");
    }
  }
};

extendConstructor(wrm.data.InsertQuery, wrm.data.JQuery);

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.InsertQuery.prototype.execute = function(dataContext, parameters) {
  if (parameters && parameters["useNewishQueries"]) {
    return wrm.data.NewQueries.insert(this, this._inserts, dataContext, parameters);
  }
  
  var thisQuery = this;
  
  this.checkDataContext(dataContext);
  var keyAttribute = this.getEntity().getKeyAttribute();
  var keyAttributeName = keyAttribute && keyAttribute.getName();
  var entitySet = this.retrieveEntitySet(dataContext);
  
  /** @type {!Array<function():!Promise>} */
  var postInsertFunctions = [];
  
  /* Insert each object in the entity set */
  var insertedObjects = [];
  var parametersObj = parameters || {};
  var promise = Promise.all(this._inserts.map(function(insert) {
    
    /* Body */
    var insertObjectsPromise = thisQuery._createInsertObjects(dataContext, insert, parametersObj);
    return insertObjectsPromise.then(function(objs) {
      var object = entitySet.add(objs.propertyInserts);
      if (objs.postInsertFunction) {
        postInsertFunctions.push(objs.postInsertFunction.bind(null, object));
      }
      return thisQuery.enlistForInsert(object);
    }).then(function(object) {
      
      /* Keep track of added objects */
      insertedObjects.push(object);
    });
  }));
  
  /* Save changes */
  promise = promise.then(function() {
    return thisQuery.saveChanges(dataContext);
  });
  
  /* Run post-insert functions, then save changes again */
  promise = promise.then(function() {
    return postInsertFunctions.reduce(function(chain, fn) {
      return chain.then(function() {
        return fn();
      });
    }, Promise.resolve());
  }).then(function() {
    if (postInsertFunctions.length > 0) {
      return thisQuery.saveChanges(dataContext);
    }
  });
  
  return promise.then(function() {
    
    /* Notify listeners */
    if (thisQuery.hasChangeListeners()) {
      insertedObjects.forEach(thisQuery.notifyInstanceInserted.bind(thisQuery));
    }
    
    /* Collect the (now available) keys of all inserted objects and return them */
    return insertedObjects.map(function(object) {
      return keyAttributeName ? object[keyAttributeName] : null;
    });
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {(function(!Object):!Object)|!Object} insert
 * @param {!Object} parameters
 * @return {!Promise<{propertyInserts:!Object, postInsertFunction:?function(!Object):!Promise}>}
 */
wrm.data.InsertQuery.prototype._createInsertObjects = function(dataContext, insert, parameters) {
  var JDDataMover = wrm.data.JDDataMover;
  var entity = this.getEntity();
  var changeTracker = this.getChangeTracker();
  
  /* Compute actual insert values from insert functions */
  var insertValues;
  if (typeof insert === "function") {
    insertValues = insert(parameters);
  } else {
    insertValues = insert;
  }
  
  /* Prepare inserted values (by NAME) converted to the correct type and a additional post-insert functions */
  var propertyInserts = {};
  var propertyPostSetFunctions = [];
  var loadPromises = [];
  angular.forEach(insertValues, function(value, propertyId) {
    var property = entity.getProperty(propertyId, true);
    if (property instanceof wrm.data.meta.Role) {
      var accessor = wrm.data.RoleAccessor.get(property);
      var postSetRequired = accessor.set(propertyInserts, value, dataContext);
      if (postSetRequired) {
        propertyPostSetFunctions.push(function(object) {
          return accessor.postSet(object, value, changeTracker, dataContext);
        });
      }
    } else {
      var postSetRequired = JDDataMover.isPostOperationRequired((property));
      var convertedValue = dataContext.castToSingleValue(property, value);
      loadPromises.push(JDDataMover.load(propertyInserts, property, convertedValue));
      if (postSetRequired && convertedValue) {
        propertyPostSetFunctions.push(function(object) {
          return JDDataMover.postCreate((property), object[property.getEntity().getKeyAttribute().getName()], (convertedValue), dataContext);
        });
      }
    }
  });
  
  /* Prepare a single post-insert function */
  var postInsertFunction;
  if (propertyPostSetFunctions.length > 0) {
    postInsertFunction = function(object) {
      return propertyPostSetFunctions.reduce(function(chain, fn) {
        return chain.then(function() {
          return fn(object);
        });
      }, Promise.resolve());
    };
  } else {
    postInsertFunction = null;
  }
  
  return Promise.all(loadPromises).then(function() {
    return {propertyInserts:propertyInserts, postInsertFunction:postInsertFunction};
  });
};




//== wrm/data/XDConfiguration.js ==============================================


/**
 * @package
 * @constructor
 * @class Helper class to install on a xdata.Query query the required listeners. Its content is immutable, i.e. you need to create a
 *        new instance if you need to change it.
 * @param {Array<wrm.data.ChangeListener>} changeListener
 */
wrm.data.XDConfiguration = function(changeListener) {
  
  /**
   * @private
   * @readonly
   * @type {Array<wrm.data.ChangeListener>}
   */
  this._changeListeners = changeListener.slice();
};

/**
 * @param {xdata.Query} query
 * @param {!wrm.data.meta.Entity|!wrm.data.meta.Association} entityOrAssoc
 */
wrm.data.XDConfiguration.prototype.configureQuery = function(query, entityOrAssoc) {
  query.clearChangeTrackers();
  
  this._changeListeners.forEach(function(listener) {
    var changeTracker;
    if (entityOrAssoc instanceof wrm.data.meta.Entity) {
      changeTracker = listener.getEntityListener((entityOrAssoc));
    } else {
      if (entityOrAssoc instanceof wrm.data.meta.Association) {
        changeTracker = listener.getAssociationListener((entityOrAssoc));
      } else {
        throw new Error("Unsupported element " + entityOrAssoc);
      }
    }
    
    if (changeTracker !== null) {
      query.addChangeTracker(changeTracker);
    }
  });
};






//== wrm/data/AbstractDataContext.js ==========================================



/**
 * @package
 * @constructor
 * @implements wrm.data.DataContext
 * @param {!wrm.data.DataService} dataService
 */
wrm.data.AbstractDataContext = function(dataService) {
  
  /** @private */
  this._dataService = dataService;
  
  /**
   * @private
   * @type {!Array.<!wrm.data.ChangeListener>}
   */
  this._changeListeners = [];
  
  /**
   * @private
   * @type {!Array.<string>}
   */
  this._exposedMetaAttributeFamilies = [];
  
  /**
   * @private
   * @type {!wrm.data.XDConfiguration}
   */
  this._xdConfiguration = new wrm.data.XDConfiguration([]);
};

/** @override */
wrm.data.AbstractDataContext.prototype.getMetadata = function() {
  return this._dataService.getMetadata();
};

/**
 * @package
 * @return {!wrm.data.DataService}
 */
wrm.data.AbstractDataContext.prototype.getDataService = function() {
  return this._dataService;
};

/** @override */
wrm.data.AbstractDataContext.prototype.getQueryFactory = function() {
  return this._dataService;
};

/**
 * @override
 * @const
 */
wrm.data.AbstractDataContext.prototype.castToSingleValue = function(property, value) {
  value = wrm.data.toAnySingle(value);
  if (value !== undefined) {
    value = this.doCastValue(property, value);
  }
  return value;
};

/**
 * @override
 * @const
 */
wrm.data.AbstractDataContext.prototype.castToArrayValue = function(property, value) {
  value = wrm.data.toAnyArray(value);
  for (var i = 0;i < value.length;i++) {
    value[i] = this.doCastValue(property, value[i]);
  }
  return value;
};

/**
 * @protected
 * @param {!wrm.data.meta.Property} property
 * @param {*|null|undefined} value
 * @return {*|null|undefined}
 */
wrm.data.AbstractDataContext.prototype.doCastValue = ABSTRACT_METHOD;

/** @override */
wrm.data.AbstractDataContext.prototype.addChangeListener = function(changeListener) {
  this._changeListeners.push(changeListener);
  this._xdConfiguration = new wrm.data.XDConfiguration(this._changeListeners);
};

/** @override */
wrm.data.AbstractDataContext.prototype.removeChangeListener = function(changeListener) {
  for (var i = 0;i < this._changeListeners.length;i++) {
    if (this._changeListeners[i] === changeListener) {
      this._changeListeners.splice(i, 1);
      return;
    }
  }
};

/**
 * @return {!wrm.data.XDConfiguration}
 */
wrm.data.AbstractDataContext.prototype.getQueryConfiguration = function() {
  return this._xdConfiguration;
};

/** @override */
wrm.data.AbstractDataContext.prototype.disableChangeTracking = function() {
};

/** @override */
wrm.data.AbstractDataContext.prototype.isChangeTrackingEnabled = function() {
  return false;
};

/** @override */
wrm.data.AbstractDataContext.prototype.setExposedMetaAttributes = function(families) {
  this._exposedMetaAttributeFamilies = Array.prototype.slice.call(arguments);
};

/**
 * @protected
 * @param {!wrm.data.JQuery} query
 */
wrm.data.AbstractDataContext.prototype.configureQuery = function(query) {
  if (this._changeListeners.length > 0) {
    this._changeListeners.forEach(function(newListener) {
      var listener = new wrm.data.ChangeListenerOld(newListener);
      query.addChangeListener(listener);
    });
  }
  if (this._exposedMetaAttributeFamilies.length > 0) {
    query.setExposedMetaAttributes.apply(query, this._exposedMetaAttributeFamilies);
  }
};
/**
 * @protected
 * @param {!wrm.data.Query<!wrm.data.meta.Entity>} query
 */
wrm.data.AbstractDataContext.prototype.configureQueryNew = function(query) {
  if (this._changeListeners.length > 0 && !(query instanceof wrm.data.XSelectQuery || query instanceof wrm.data.XDeleteQuery)) {
    throw new Error("Change listening not possible with new queries");
  }
  if (this._exposedMetaAttributeFamilies.length > 0 && !(query instanceof wrm.data.XSelectQuery || query instanceof wrm.data.XDeleteQuery)) {
    throw new Error("Exposing meta-attributes is not supported with new queries");
  }
};

/**
 * @protected
 * @template R
 * @param {!wrm.data.JQuery} query
 * @param {!Promise.<R>} resultPromise
 * @return {!Promise.<R>}
 */
wrm.data.AbstractDataContext.prototype.interceptQueryResult = function(query, resultPromise) {
  return resultPromise;
};
/**
 * @protected
 * @template R
 * @param {!wrm.data.Query<!wrm.data.meta.Entity>} query
 * @param {!Promise<R>} resultPromise
 * @return {!Promise<R>}
 */
wrm.data.AbstractDataContext.prototype.interceptQueryResultNew = function(query, resultPromise) {
  return resultPromise;
};

/**
 * @override
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.AbstractDataContext.prototype.select = function(entityId, options, parameters) {
  var query = this._dataService.prepareSelect(entityId, options);
  this.configureQueryNew(query);
  return this.interceptQueryResultNew(query, query.query(this, parameters));
};

/**
 * @override
 * @param {string} entityId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<?Object|*>}
 */
wrm.data.AbstractDataContext.prototype.selectOne = function(entityId, options, parameters) {
  var query = this._dataService.prepareSelect(entityId, options);
  this.configureQueryNew(query);
  return this.interceptQueryResultNew(query, query.queryOne(this, parameters));
};
/**
 * @override
 * @deprecated
 * @param {string} entityId
 * @param {{ output: (!Object.<string,string>|!Array.<string>|string|undefined), distinct: (boolean|undefined), include:
 *            (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined), order:
 *            (!Array.<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined), limit:
 *            ({begin:number,count:number}|number|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<!Array.<!Object|*>>}
 */
wrm.data.AbstractDataContext.prototype.selectOld = function(entityId, options, parameters) {
  var query = this._dataService.prepareOldSelect(entityId, options);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.query(this, parameters));
};
/**
 * @override
 * @deprecated
 * @param {string} entityId
 * @param {{ output: (!Object.<string,string>|!Array.<string>|string|undefined), distinct: (boolean|undefined), include:
 *            (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined), order:
 *            (!Array.<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined), limit:
 *            ({begin:number,count:number}|number|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<?Object|*>}
 */
wrm.data.AbstractDataContext.prototype.selectOneOld = function(entityId, options, parameters) {
  var query = this._dataService.prepareOldSelect(entityId, options);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.queryOne(this, parameters));
};

/**
 * @override
 * @param {string} entityId
 * @param {!Array.<!Object>|!Object} insert
 * @param {!Object=} parameters
 * @return {!Promise.<!Array.<!*>>}
 */
wrm.data.AbstractDataContext.prototype.insert = function(entityId, insert, parameters) {
  var query = this._dataService.prepareInsert(entityId, insert);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.execute(this, parameters));
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.AbstractDataContext.prototype.insertNew = function(entityId, insert, parameters) {
  var query = this._dataService.prepareNewInsert(entityId, insert);
  return query.execute(this, parameters);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.insertGetChangedNew = function(entityId, insert, parameters) {
  var query = this._dataService.prepareNewInsert(entityId, insert);
  return query.executeGetChanged(this, parameters);
};

/**
 * @override
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array.<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<!Array.<!*>>}
 */
wrm.data.AbstractDataContext.prototype.update = function(entityId, options, parameters) {
  var query = this._dataService.prepareUpdate(entityId, options);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.execute(this, parameters));
};

/**
 * @override
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array.<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 * @param {!Object=} parameters
 * @return {!Promise.<undefined>}
 */
wrm.data.AbstractDataContext.prototype.updateNoResult = function(entityId, options, parameters) {
  var query = this._dataService.prepareUpdate(entityId, options);
  this.configureQuery(query);
  return query.executeNoResult(this, parameters);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.AbstractDataContext.prototype.updateNew = function(entityId, options, parameters) {
  var query = this._dataService.prepareNewUpdate(entityId, options);
  return query.execute(this, parameters);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.updateGetChangedNew = function(entityId, options, parameters) {
  var query = this._dataService.prepareNewUpdate(entityId, options);
  return query.executeGetChanged(this, parameters);
};
/**
 * @deprecated
 * @override
 * @param {string} entityId
 * @param {{ include: (!Array.<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=}
 *            options
 * @param {!Object=} parameters
 * @return {!Promise.<number>}
 */
wrm.data.AbstractDataContext.prototype.deleteOld = function(entityId, options, parameters) {
  var query = this._dataService.prepareOldDelete(entityId, options);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.execute(this, parameters));
};

/**
 * @override
 * @param {string} entityId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.AbstractDataContext.prototype["delete"] = function(entityId, options, parameters) {
  var entity = this._dataService.getMetadata().getEntity(entityId);
  var useOld = false;
  entity.getAttributes().forEach(function(attr) {
    if (attr.getType() === wrm.data.Type.BLOB) {
      useOld = true;
    }
  });
  if (useOld) {
    return this.deleteOld(entityId, options, parameters);
  }
  
  var query = this._dataService.prepareDelete(entityId, options);
  this.configureQueryNew(query);
  return this.interceptQueryResultNew(query, query.execute(this, parameters));
};

/**
 * @override
 * @param {string} entityId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.deleteGetChanged = function(entityId, options, parameters) {
  var entity = this._dataService.getMetadata().getEntity(entityId);
  var useOld = false;
  entity.getAttributes().forEach(function(attr) {
    if (attr.getType() === wrm.data.Type.BLOB) {
      useOld = true;
    }
  });
  if (useOld) {
    return this.deleteGetChangedOld(entityId, options, parameters);
  }
  
  var query = this._dataService.prepareDelete(entityId, options);
  this.configureQueryNew(query);
  return this.interceptQueryResultNew(query, query.executeGetChanged(this, parameters));
};
/**
 * @internal
 * @deprecated
 * @param {string} entityId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.deleteGetChangedOld = function(entityId, options, parameters) {
  var query = this._dataService.prepareOldDelete(entityId, options);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.execute(this, parameters)).then(function(count) {
    return Promise.resolve(count > 0);
  });
};

/**
 * @override
 * @param {string} entityId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.AbstractDataContext.prototype.deleteGetCount = function(entityId, options, parameters) {
  var entity = this._dataService.getMetadata().getEntity(entityId);
  var useOld = false;
  entity.getAttributes().forEach(function(attr) {
    if (attr.getType() === wrm.data.Type.BLOB) {
      useOld = true;
    }
  });
  if (useOld) {
    return this.deleteGetCountOld(entityId, options, parameters);
  }
  
  var query = this._dataService.prepareDelete(entityId, options);
  this.configureQueryNew(query);
  return this.interceptQueryResultNew(query, query.executeGetCount(this, parameters));
};
/**
 * @internal
 * @deprecated
 * @param {string} entityId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.AbstractDataContext.prototype.deleteGetCountOld = function(entityId, options, parameters) {
  var query = this._dataService.prepareOldDelete(entityId, options);
  this.configureQuery(query);
  return this.interceptQueryResult(query, query.execute(this, parameters));
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.AbstractDataContext.prototype.selectAssociationNew = function(assocId, options, parameters) {
  var query = this._dataService.prepareNewAssociationSelect(assocId, options);
  return query.query(this, parameters);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise.<?Object|*>}
 */
wrm.data.AbstractDataContext.prototype.selectAssociationOneNew = function(assocId, options, parameters) {
  var query = this._dataService.prepareNewAssociationSelect(assocId, options);
  return query.queryOne(this, parameters);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.insertAssociationNew = function(assocId, insert, parameters) {
  var query = this._dataService.prepareNewAssociationInsert(assocId, insert);
  return query.execute(this, parameters);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.updateAssociationNew = function(assocId, options, parameters) {
  var query = this._dataService.prepareNewAssociationUpdate(assocId, options);
  return query.execute(this, parameters);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.AbstractDataContext.prototype.deleteAssociationNew = function(assocId, options, parameters) {
  var query = this._dataService.prepareNewAssociationDelete(assocId, options);
  return query.executeGetChanged(this, parameters);
};




//== wrm/data/JDChangeTracker.js ==============================================


/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.DataRunner} dataRunner
 * @param {!wrm.data.sync.DataTrackerService} dataTrackerService
 */
wrm.data.JDChangeTracker = function(entity, dataRunner, dataTrackerService) {
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._dataRunner = dataRunner;
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  /** @private */
  this._keyAttributeName = entity.getKeyAttribute().getName();
  
  /** @private */
  this._serverKeyAttributeName = entity.getServerKeyAttribute() && entity.getServerKeyAttribute().getName();
  
  /* Construct information about the properties to monitor updates */
  var monitorInfo = this._createUpdateMonitorInfo(entity);
  
  /** @private */
  this._monitoredAttributesByName = monitorInfo.attributes;
  
  /** @private */
  this._monitoredRolesByName = monitorInfo.roles;
  
  /** @private */
  this._monitoredRolesIds = monitorInfo.roleIds;
  
  /** @private */
  this._roleValuesSelectQuery = this._createRoleValuesSelectQuery(entity, monitorInfo.roleIds, dataRunner);
  
  /* Enlisted changes */
  
  /**
   * @private
   * @type {!Array.<{key:(*|undefined)}>}
   */
  this._inserts = [];
  
  /**
   * @private
   * @type {!Array.<{key:*, attributes:!Object.<string,!wrm.data.meta.Attribute>}>}
   */
  this._updates = [];
  
  /**
   * @private
   * @type {!Array.<{key:*, serverKey:?*}>}
   */
  this._deletes = [];
  
  /**
   * @private
   * @type {!Object.<string,!Object.<string,{nearKey:*, farKey:*}>>}
   */
  this._assocAdditions = {};
  
  /**
   * @private
   * @type {!Object.<string,!Object.<string,{nearKey:*, farKey:*}>>}
   */
  this._assocRemovals = {};
  
  /**
   * @private
   * @type {!Object.<string,{key:*, oldServerKey:?*, newServerKey:?*}>}
   */
  this._serverKeyUpdates = {};
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {{attributes:!Object.<string,!wrm.data.meta.Attribute>, roles:!Object.<string,!wrm.data.meta.Role>,
 *         roleIds:!Array.<string>}}
 */
wrm.data.JDChangeTracker.prototype._createUpdateMonitorInfo = function(entity) {
  var serverKeyAttribute = entity.getServerKeyAttribute();
  
  /* Monitor all attributes */
  var attributesMap = {};
  entity.getAttributes().forEach(function(attr) {
    if (attr === serverKeyAttribute) {
      return;
    }
    attributesMap[attr.getName()] = attr;
  });
  
  /* Monitor roles that have their foreign key on the entity */
  var rolesMap = {}, roleIds = [];
  entity.getRoles().forEach(function(role) {
    if (role.isForeignKey()) {
      rolesMap[role.getName()] = role;
      roleIds.push(role.getId());
    }
  });
  
  return {attributes:attributesMap, roles:rolesMap, roleIds:roleIds};
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!Array.<string>} roleIds
 * @param {!wrm.data.DataRunner} dataRunner
 * @return {!wrm.data.JSelectQuery}
 */
wrm.data.JDChangeTracker.prototype._createRoleValuesSelectQuery = function(entity, roleIds, dataRunner) {
  
  /* Prepare a query that selects all roles by the (local) key of an instance */
  return dataRunner.prepareOldSelect(entity.getId(), {output:roleIds, filter:[{property:entity.getKeyAttribute().getId(), valueInput:"key"}]});
};

/*
 * Enlisting of CUD objects
 */

/**
 * @package
 * @param {!$data.Entity} object
 * @return {!Promise.<!$data.Entity>}
 */
wrm.data.JDChangeTracker.prototype.enlistForInsert = function(object) {
  var thisTracker = this;
  var keyAttributeName = this._keyAttributeName;
  
  var entry = {key:undefined};
  this._inserts.push(entry);
  
  /* Add a listener on the JayData entity to record key assignment at the time of creation */
  this._observePropertyChanges(object, function(object, data) {
    
    /* Record assigned key */
    if (data.propertyName === keyAttributeName && data.newValue !== null) {
      entry.key = data.newValue;
      thisTracker._trackTuplesForKeyInit(object);
    }
  });
  
  return Promise.resolve(object);
};

/**
 * @package
 * @param {!$data.Entity} object
 * @return {!Promise.<!$data.Entity>}
 */
wrm.data.JDChangeTracker.prototype.enlistForUpdate = function(object) {
  var thisTracker = this;
  var monitoredAttributesByName = this._monitoredAttributesByName;
  var monitoredRolesByName = this._monitoredRolesByName;
  var roleValuesSelectQuery = this._roleValuesSelectQuery;
  var serverKeyAttributeName = this._serverKeyAttributeName;
  
  var key = this._extractKey(object);
  
  /*
   * Obtain the values of all monitored roles since we may need them in the callback below but cannot count on them to be available
   * since the JayData Entity object being updated may have been selected WITHOUT including said roles
   */
  var roleValues = null;
  var roleValuesPromise = this._dataRunner.execute(function(dataContext) {
    return roleValuesSelectQuery.queryOne(dataContext, {"key":key}).then(function(resultingRoleValues) {
      roleValues = resultingRoleValues;
    });
  });
  
  var entry = {key:key, attributes:{}};
  this._updates.push(entry);
  
  /* Add a listener on the JayData entity to record all changed properties */
  this._observePropertyChanges(object, function(object, data) {
    var propertyName = data.propertyName;
    
    var oldValue;
    var newValue = data.newValue;
    
    /* Record updated attributes */
    var attribute = monitoredAttributesByName[propertyName];
    if (attribute) {
      oldValue = data.oldValue;
      if (newValue !== oldValue) {
        entry.attributes[attribute.getId()] = attribute;
      }
      return;
    }
    
    /* Record updated roles */
    var role = monitoredRolesByName[propertyName];
    if (role) {
      oldValue = roleValues[propertyName];
      if (newValue !== oldValue) {
        thisTracker._trackTuplesForRoleUpdate(object, role, oldValue, (newValue));
      }
      return;
    }
    
    /* Record changed server key */
    if (propertyName === serverKeyAttributeName) {
      oldValue = data.oldValue;
      thisTracker._trackServerKeyUpdate(object, oldValue, newValue);
      return;
    }
  });
  
  /* Ensure that the caller does not go one with updating until role values are available */
  return roleValuesPromise.then(function() {
    return object;
  });
};

/**
 * @package
 * @param {!$data.Entity} object
 * @return {!Promise.<!$data.Entity>}
 */
wrm.data.JDChangeTracker.prototype.enlistForDelete = function(object) {
  var key = this._extractKey(object);
  var serverKey = this._extractServerKey(object);
  this._deletes.push({key:key, serverKey:serverKey});
  return Promise.resolve(object);
};

/**
 * @private
 * @param {!$data.Entity} object
 * @param {function(!$data.Entity,{propertyName:string, oldValue:(?*|undefined), newValue:?*})} callback
 */
wrm.data.JDChangeTracker.prototype._observePropertyChanges = function(object, callback) {
  object["propertyChanged"]["attach"](callback);
};

/*
 * Association tracking (indirectly, through keys and roles)
 */

/**
 * @private
 * @param {!$data.Entity} object
 */
wrm.data.JDChangeTracker.prototype._trackTuplesForKeyInit = function(object) {
  var thisTracker = this;
  var entity = this._entity;
  var monitoredRolesIds = this._monitoredRolesIds;
  
  /* Collect key on NEAR side of the association, after the change */
  var newKey = this._extractKey(object);
  
  /* Process each object on the FAR side of all associations whose roles are monitored */
  monitoredRolesIds.forEach(function(roleId) {
    var farObject = object[roleId];
    if (!farObject) {
      return;
    }
    var role = entity.getRole(roleId);
    var farEntity = role.getInverseEntity();
    var farKey = thisTracker._extractKey(farObject, farEntity);
    
    thisTracker._trackAddedAssociationTuple(role, newKey, farKey);
  });
};

/**
 * @private
 * @param {!$data.Entity} object
 * @param {!wrm.data.meta.Role} role
 * @param {?$data.Entity} oldValue
 * @param {?$data.Entity} newValue
 */
wrm.data.JDChangeTracker.prototype._trackTuplesForRoleUpdate = function(object, role, oldValue, newValue) {
  var thisTracker = this;
  
  if (oldValue === newValue) {
    return;
  }
  
  /* Collect key on BOTH sides of the association, before and after the change */
  var farEntity = role.getInverseEntity();
  var nearKey = this._extractKey(object);
  var oldFarKey = oldValue ? this._extractKey(oldValue, farEntity) : null;
  var newFarKey = newValue ? this._extractKey(newValue, farEntity) : null;
  
  if (oldFarKey !== null) {
    thisTracker._trackRemovedAssociationTuple(role, nearKey, oldFarKey);
  }
  if (newFarKey !== null) {
    thisTracker._trackAddedAssociationTuple(role, nearKey, newFarKey);
  }
};

/*
 * Association tracking (directly, from role changes notified from the outside)
 */

/**
 * @package
 * @param {!wrm.data.meta.Role} role
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.JDChangeTracker.prototype.trackAddedRoleValue = function(role, nearKey, farKey) {
  if (role.getEntity() === this._entity) {
    this._trackAddedAssociationTuple(role, nearKey, farKey);
  }
};

/**
 * @package
 * @param {!wrm.data.meta.Role} role
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.JDChangeTracker.prototype.trackRemovedRoleValue = function(role, nearKey, farKey) {
  if (role.getEntity() === this._entity) {
    this._trackRemovedAssociationTuple(role, nearKey, farKey);
  }
};

/*
 * Association tracking (internal methods)
 */

/**
 * @private
 * @param {!wrm.data.meta.Role} role
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.JDChangeTracker.prototype._trackAddedAssociationTuple = function(role, nearKey, farKey) {
  this._trackAssociationChange(this._assocAdditions, this._assocRemovals, role, nearKey, farKey);
};

/**
 * @private
 * @param {!wrm.data.meta.Role} role
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.JDChangeTracker.prototype._trackRemovedAssociationTuple = function(role, nearKey, farKey) {
  this._trackAssociationChange(this._assocRemovals, this._assocAdditions, role, nearKey, farKey);
};

/**
 * @private
 * @param {!Object.<string,!Object.<string,{nearKey:*, farKey:*}>>} addMap
 * @param {!Object.<string,!Object.<string,{nearKey:*, farKey:*}>>} removeMap
 * @param {!wrm.data.meta.Role} role
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.JDChangeTracker.prototype._trackAssociationChange = function(addMap, removeMap, role, nearKey, farKey) {
  var roleId = role.getId();
  var mapKey = String(nearKey) + "###" + String(farKey);
  
  /* Remove from the 'remove' map (if present) */
  var removeSubMap = removeMap[roleId];
  if (removeSubMap) {
    delete removeSubMap[mapKey];
  }
  
  /* Add to the 'add' map (always) */
  var addSubMap = addMap[roleId];
  if (!addSubMap) {
    addMap[roleId] = addSubMap = {};
  }
  addSubMap[mapKey] = {nearKey:nearKey, farKey:farKey};
};

/**
 * @private
 * @param {!$data.Entity} object
 * @param {?*} oldServerKey
 * @param {?*} newServerKey
 */
wrm.data.JDChangeTracker.prototype._trackServerKeyUpdate = function(object, oldServerKey, newServerKey) {
  var key = this._extractKey(object);
  var mapKey = String(key);
  
  var update = this._serverKeyUpdates[mapKey];
  if (!update) {
    this._serverKeyUpdates[mapKey] = update = {key:key, oldServerKey:oldServerKey, newServerKey:newServerKey};
  } else {
    update.newServerKey = newServerKey;
  }
};

/*
 * Change submission
 */

/**
 * @package
 * @return {!Promise}
 */
wrm.data.JDChangeTracker.prototype.submitChanges = function() {
  var entity = this._entity;
  var dataTrackerService = this._dataTrackerService;
  var assocAdditions = this._assocAdditions;
  var assocRemovals = this._assocRemovals;
  var serverKeyUpdates = this._serverKeyUpdates;
  
  /*
   * Report all changes to the Data Tracker Service in an order that is expected to minimize trouble; in practice, first report
   * creates/updates, than report changes to associations and finally report deletions
   */
  
  var promise = Promise.resolve();
  
  /* Report entity creations */
  if (this._inserts.length > 0) {
    promise = this._inserts.reduce(function(chain, insert) {
      
      /* Skip inserts that somehow ended up with no key */
      if (insert.key === undefined) {
        return chain;
      }
      
      return chain.then(function() {
        return dataTrackerService.trackEntityCreate(entity, insert.key);
      });
    }, promise);
  }
  
  /* Report entity updates */
  if (this._updates.length > 0) {
    promise = this._updates.reduce(function(chain, update) {
      
      /* Determine which attributes were updated */
      var updatedAttributes = Object.keys(update.attributes).map(function(attrId) {
        return update.attributes[attrId];
      });
      if (updatedAttributes.length <= 0) {
        return chain;
      }
      
      return chain.then(function() {
        return dataTrackerService.trackEntityUpdate(entity, update.key, updatedAttributes);
      });
    }, promise);
  }
  
  /* Report server key updates */
  promise = Object.keys(serverKeyUpdates).reduce(function(chain, mapKey) {
    var update = serverKeyUpdates[mapKey];
    
    return chain.then(function() {
      return dataTrackerService.trackEntityServerKeyUpdate(entity, update.key, update.oldServerKey, update.newServerKey);
    });
  }, promise);
  
  /* Report association changes (connections/disconnections) */
  promise = entity.getRoles().reduce(function(chain, role) {
    var roleId = role.getId();
    var additions = assocAdditions[roleId];
    var removals = assocRemovals[roleId];
    if (!additions && !removals) {
      return chain;
    }
    
    var assoc = role.getAssociation();
    var inverted = role !== assoc.getRole1();
    
    /* Report association removals */
    if (removals) {
      Object.keys(removals).forEach(function(mapKey) {
        var removal = removals[mapKey];
        var key1 = inverted ? removal.farKey : removal.nearKey;
        var key2 = inverted ? removal.nearKey : removal.farKey;
        chain = chain.then(function() {
          return dataTrackerService.trackAssociationRemove(assoc, key1, key2);
        });
      });
    }
    
    /* Report association additions */
    if (additions) {
      Object.keys(additions).forEach(function(mapKey) {
        var addition = additions[mapKey];
        var key1 = inverted ? addition.farKey : addition.nearKey;
        var key2 = inverted ? addition.nearKey : addition.farKey;
        chain = chain.then(function() {
          return dataTrackerService.trackAssociationAdd(assoc, key1, key2);
        });
      });
    }
    
    return chain;
  }, promise);
  
  /* Report entity deletes */
  if (this._deletes.length > 0) {
    promise = this._deletes.reduce(function(chain, deletey) {
      return chain.then(function() {
        return dataTrackerService.trackEntityDelete(entity, deletey.key, deletey.serverKey);
      });
    }, promise);
  }
  
  /*
   * Clear changes (no need to do this after the promise chain, since all information about changes is not stored in the closures of
   * the various 'then' handlers)
   */
  this._clearChanges();
  
  return promise;
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.JDChangeTracker.prototype.discardChanges = function() {
  this._clearChanges();
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.JDChangeTracker.prototype._clearChanges = function() {
  this._inserts = [];
  this._updates = [];
  this._deletes = [];
  this._assocAdditions = {};
  this._assocRemovals = {};
  this._serverKeyUpdates = {};
};

/*
 * Utilities
 */

/**
 * @private
 * @param {!$data.Entity} object
 * @param {!wrm.data.meta.Entity=} entity
 * @return {*}
 */
wrm.data.JDChangeTracker.prototype._extractKey = function(object, entity) {
  var keyAttributeName = !entity ? this._keyAttributeName : entity.getKeyAttribute().getName();
  var key = object[keyAttributeName];
  if (!key) {
    throw new Error("Object has no key");
  }
  return key;
};

/**
 * @private
 * @param {!$data.Entity} object
 * @param {!wrm.data.meta.Entity=} entity
 * @return {?*}
 */
wrm.data.JDChangeTracker.prototype._extractServerKey = function(object, entity) {
  var serverKeyAttributeName = !entity ? this._serverKeyAttributeName : entity.getServerKeyAttribute() && entity.getServerKeyAttribute().getName();
  var serverKey = serverKeyAttributeName ? object[serverKeyAttributeName] : null;
  return serverKey !== undefined ? serverKey : null;
};




//== wrm/data/TrackingListener.js =============================================



/**
 * @constructor
 * @implements wrm.data.ChangeListener
 * @param {wrm.data.sync.DataTrackerService} dataTrackerService
 */
wrm.data.TrackingListener = function(dataTrackerService) {
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  /**
   * @private
   * @type {!Array.<{key:(*|undefined)}>}
   */
  this._inserts = [];
  
  /**
   * @private
   * @type {!Array.<{key:*, attributes:!Object.<string,!wrm.data.meta.Attribute>}>}
   */
  this._updates = [];
  
  /**
   * @private
   * @type {!Array.<{key:*, serverKey:?*}>}
   */
  this._deletes = [];
  
  /**
   * @private
   * @type {!Array.<{assoc:!wrm.data.meta.Association, nearKey:*, farKey:*}>}
   */
  this._assocAdditions = [];
  
  /**
   * @private
   * @type {!Array.<{assoc:!wrm.data.meta.Association, nearKey:*, farKey:*}>}
   */
  this._assocRemovals = [];
  
};

/** @override */
wrm.data.TrackingListener.prototype.getEntityListener = function(entity) {
  /* Construct information about the properties to monitor updates */
  var monitorInfo = this._createEntityMonitorInfo(entity);
  
  var changeTracker = new wrm.data.TrackingListener._EntityChangeTracker(entity, monitorInfo, this._dataTrackerService, this);
  return changeTracker;
};

/** @override */
wrm.data.TrackingListener.prototype.getAssociationListener = function(assoc) {
  var changeTracker = new wrm.data.TrackingListener._AssocChangeTracker(assoc, this._dataTrackerService, this);
  return changeTracker;
};

/**
 * @package
 * @return {!Promise}
 */
wrm.data.TrackingListener.prototype.submitChanges = function() {
  var promise = Promise.resolve();
  var dataTrackerService = this._dataTrackerService;
  
  /* Report entity creations */
  if (this._inserts.length > 0) {
    promise = this._inserts.reduce(function(chain, insert) {
      
      /* Skip inserts that somehow ended up with no key */
      if (insert.key === undefined) {
        return chain;
      }
      
      return chain.then(function() {
        return dataTrackerService.trackEntityCreate(insert.entity, insert.key);
      });
    }, promise);
  }
  
  /* Report entity updates */
  if (this._updates.length > 0) {
    promise = this._updates.reduce(function(chain, update) {
      
      /* Determine which attributes were updated */
      var updatedAttributes = Object.keys(update.attributes).map(function(attrId) {
        return update.attributes[attrId];
      });
      if (updatedAttributes.length <= 0) {
        return chain;
      }
      
      return chain.then(function() {
        return dataTrackerService.trackEntityUpdate(update.entity, update.key, updatedAttributes);
      });
    }, promise);
  }
  
  /* Report association removals */
  if (this._assocRemovals.length > 0) {
    promise = this._assocRemovals.reduce(function(chain, assoc) {
      
      return chain.then(function() {
        return dataTrackerService.trackAssociationRemove(assoc.assoc, assoc.farKey, assoc.nearKey);
      });
    }, promise);
  }
  
  /* Report association additions */
  if (this._assocAdditions.length > 0) {
    promise = this._assocAdditions.reduce(function(chain, assoc) {
      
      return chain.then(function() {
        return dataTrackerService.trackAssociationAdd(assoc.assoc, assoc.farKey, assoc.nearKey);
      });
    }, promise);
  }
  
  /* Report entity deletes */
  if (this._deletes.length > 0) {
    promise = this._deletes.reduce(function(chain, deletey) {
      return chain.then(function() {
        return dataTrackerService.trackEntityDelete(deletey.entity, deletey.key, deletey.serverKey);
      });
    }, promise);
  }
  
  /*
   * Clear changes (no need to do this after the promise chain, since all information about changes is not stored in the closures of
   * the various 'then' handlers)
   */
  this._clearChanges();
  
  return promise;
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.TrackingListener.prototype.discardChanges = function() {
  this._clearChanges();
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 */
wrm.data.TrackingListener.prototype.enlistForInsert = function(entity, key) {
  this._inserts.push({entity:entity, key:key});
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {*} serverKey
 */
wrm.data.TrackingListener.prototype.enlistForDelete = function(entity, key, serverKey) {
  this._deletes.push({entity:entity, key:key, serverKey:serverKey});
};

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @param {*} key
 * @param {!Array<*>} updateAttributes
 */
wrm.data.TrackingListener.prototype.enlistForUpdate = function(entity, key, updateAttributes) {
  this._updates.push({entity:entity, key:key, attributes:updateAttributes});
};

/**
 * @package
 * @param {!wrm.data.meta.Association} assoc
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.TrackingListener.prototype.trackAddedRoleValue = function(assoc, nearKey, farKey) {
  this._assocAdditions.push({assoc:assoc, nearKey:nearKey, farKey:farKey});
};

/**
 * @package
 * @param {!wrm.data.meta.Association} assoc
 * @param {*} nearKey
 * @param {*} farKey
 */
wrm.data.TrackingListener.prototype.trackRemovedRoleValue = function(assoc, nearKey, farKey) {
  this._assocRemovals.push({assoc:assoc, nearKey:nearKey, farKey:farKey});
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.TrackingListener.prototype._clearChanges = function() {
  this._inserts = [];
  this._updates = [];
  this._deletes = [];
  this._assocAdditions = [];
  this._assocRemovals = [];
};

/**
 * @private
 * @param {wrm.data.meta.Entity} entity
 * @return {Object}
 */
wrm.data.TrackingListener.prototype._createEntityMonitorInfo = function(entity) {
  var serverKeyAttribute = entity.getServerKeyAttribute();
  
  /* Monitor all attributes */
  var attributesMap = {};
  entity.getAttributes().forEach(function(attr) {
    if (attr === serverKeyAttribute) {
      return;
    }
    attributesMap[attr.getName()] = attr;
  });
  
  return attributesMap;
};

/**
 * @private
 * @constructor
 * @extends wrm.data.XDChangeTrackerAdapter
 * @param {!wrm.data.meta.Entity} entity
 * @param {Object} monitorInfo
 * @param {wrm.data.sync.DataTrackerService} dataTrackerService
 * @param {wrm.data.TrackingListener} trackingListener
 */
wrm.data.TrackingListener._EntityChangeTracker = function(entity, monitorInfo, dataTrackerService, trackingListener) {
  
  /** @private */
  this._monitorInfo = monitorInfo;
  
  /** @private */
  this._entity = entity;
  
  /** @private */
  this._keyAttributeName = entity.getKeyAttribute().getName();
  
  /** @private */
  this._serverKeyAttributeName = entity.getServerKeyAttribute() && entity.getServerKeyAttribute().getName();
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  this.tracked = [entity.getKeyAttribute().getName()];
  if (entity.getServerKeyAttribute()) {
    this.tracked.push(entity.getServerKeyAttribute().getName());
  }
  
  this.trackedOld = [entity.getKeyAttribute().getName()];
  if (entity.getServerKeyAttribute()) {
    this.trackedOld.push(entity.getServerKeyAttribute().getName());
  }
  
  /** @private */
  this._trackingListener = trackingListener;
};

/** @override */
wrm.data.TrackingListener._EntityChangeTracker.prototype.afterInsert = function(values) {
  var key = this._extractKey(values, this._entity);
  this._trackingListener.enlistForInsert(this._entity, key);
};

/** @override */
wrm.data.TrackingListener._EntityChangeTracker.prototype.afterUpdate = function(values, valuesOld) {
  var key = this._extractKey(values, this._entity);
  
  var updatedAttributes = [];
  /* Record updated attributes */
  Object.keys(values).forEach(function(propertyName) {
    var attribute = this._monitorInfo[propertyName];
    if (attribute) {
      var newValue = values[propertyName];
      var oldValue = valuesOld[propertyName];
      if (newValue !== oldValue) {
        updatedAttributes.push(attribute);
      }
    }
  });
  this._trackingListener.enlistForUpdate(this._entity, key, updatedAttributes);
};

/** @override */
wrm.data.TrackingListener._EntityChangeTracker.prototype.afterDelete = function(values) {
  var key = this._extractKey(values, this._entity);
  var serverKey = this._extractServerKey(values, this._entity);
  this._trackingListener.enlistForDelete(this._entity, key, serverKey);
};

/**
 * @private
 * @param {!Object} object
 * @param {!wrm.data.meta.Entity=} entity
 * @return {*}
 */
wrm.data.TrackingListener._EntityChangeTracker.prototype._extractKey = function(object, entity) {
  var keyAttributeName = !entity ? this._keyAttributeName : entity.getKeyAttribute().getName();
  var key = object[keyAttributeName];
  if (!key) {
    throw new Error("Object has no key");
  }
  return key;
};

/**
 * @private
 * @param {!Object} object
 * @param {!wrm.data.meta.Entity=} entity
 * @return {?*}
 */
wrm.data.TrackingListener._EntityChangeTracker.prototype._extractServerKey = function(object, entity) {
  var serverKeyAttributeName = !entity ? this._serverKeyAttributeName : entity.getServerKeyAttribute() && entity.getServerKeyAttribute().getName();
  var serverKey = serverKeyAttributeName ? object[serverKeyAttributeName] : null;
  return serverKey !== undefined ? serverKey : null;
};

/**
 * @private
 * @constructor
 * @extends wrm.data.XDChangeTrackerAdapter
 * @param {!wrm.data.meta.Association} assoc
 * @param {wrm.data.sync.DataTrackerService} dataTrackerService
 * @param {wrm.data.TrackingListener} trackingListener
 */
wrm.data.TrackingListener._AssocChangeTracker = function(assoc, dataTrackerService, trackingListener) {
  
  /** @private */
  this._assoc = assoc;
  
  var nearRole = assoc.getRole1().isForeignKey() ? assoc.getRole1() : assoc.getRole2();
  var farRole = assoc.getRole1().isForeignKey() ? assoc.getRole2() : assoc.getRole1();
  
  this._nearKey = nearRole.getId() + "." + nearRole.getEntity().getKeyAttribute().getName();
  this._farKey = farRole.getId() + "." + farRole.getEntity().getKeyAttribute().getName();
  
  this.tracked = [this._nearKey, this._farKey];
  this.trackedOld = [this._nearKey, this._farKey];
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  /** @private */
  this._trackingListener = trackingListener;
};

/** @override */
wrm.data.TrackingListener._AssocChangeTracker.prototype.afterInsert = function(values) {
};

/** @override */
wrm.data.TrackingListener._AssocChangeTracker.prototype.afterUpdate = function(values, valuesOld) {
};

/** @override */
wrm.data.TrackingListener._AssocChangeTracker.prototype.afterDelete = function(values) {
  if (!values.hasOwnProperty(this._nearKey) || !values.hasOwnProperty(this._farKey)) {
  } else {
    var nearKeyValue = values[this._nearKey];
    var farKeyValue = values[this._farKey];
    this._trackingListener.trackRemovedRoleValue(this._assoc, nearKeyValue, farKeyValue);
  }
};




//== wrm/data/JDDataContext.js ================================================



/**
 * @package
 * @constructor
 * @extends wrm.data.AbstractDataContext
 * @param {!$data.EntityContext} entityContext
 * @param {?$data.Transaction} transaction
 * @param {?wrm.data.sync.DataTrackerService} dataTrackerService
 * @param {!wrm.data.DataService} dataService
 */
wrm.data.JDDataContext = function(entityContext, transaction, dataTrackerService, dataService) {
  wrm.data.AbstractDataContext.call(this, dataService);
  
  /** @private */
  this._entityContext = entityContext;
  
  /** @private */
  this._transaction = transaction;
  
  /**
   * @private
   * @type {?xdata.Transaction}
   */
  this._xdataTransaction = null;
  
  /** @private */
  this._dataTrackerService = dataTrackerService;
  
  /**
   * @private
   * @type {?wrm.data.JDDataContext._SubRunner}
   */
  this._subRunner = dataTrackerService ? new wrm.data.JDDataContext._SubRunner(this) : null;
  
  /** @private */
  this._trackingListener = new wrm.data.TrackingListener(dataTrackerService);
};

extendConstructor(wrm.data.JDDataContext, wrm.data.AbstractDataContext);

/**
 * @package
 * @return {!$data.EntityContext}
 */
wrm.data.JDDataContext.prototype["getEntityContext"] = function() {
  return this._entityContext;
};

/**
 * @package
 * @return {!$data.Transaction|undefined}
 */
wrm.data.JDDataContext.prototype["getTransaction"] = function() {
  return this._transaction || undefined;
};
/**
 * @package
 * @return {!xdata.Database}
 */
wrm.data.JDDataContext.prototype["getXDataDatabase"] = function() {
  return this.getDataService().getXDataDatabase();
};
/**
 * @package
 * @param {boolean=} force
 * @param {boolean=} useNewishQueries
 * @return {?xdata.Transaction}
 */
wrm.data.JDDataContext.prototype["getXDataTransaction"] = function(force, useNewishQueries) {
  if (!force && !useNewishQueries) {
    return null;
  }
  var xdataTx = this._xdataTransaction;
  if (!xdataTx) {
    var tx = this._transaction;
    if (!tx) {
      if (force) {
        return null;
      }
      throw new Error("The new query implementation requires transactions");
    }
    var xdataDb = this.getDataService().getXDataDatabase();
    this._xdataTransaction = xdataTx = xdataDb.attachTransaction(tx["retrieveTransaction"]());
  }
  return xdataTx;
};
/**
 * @package
 * @return {!Promise<!xdata.Session>}
 */
wrm.data.JDDataContext.prototype["openXDataSession"] = function() {
  var dbName = this._entityContext["_wr_databaseName"];
  var xdataDb = this["getXDataDatabase"]();
  var db = GLOBAL.openDatabase(dbName, "", dbName, 1 * 1024 * 1024);
  return Promise.resolve(xdataDb.attachSession(db));
};

/** @override */
wrm.data.JDDataContext.prototype.doCastValue = function(property, value) {
  
  /* For attributes, cast the value to the attribute type */
  if (property instanceof wrm.data.meta.Attribute) {
    var type = property.getType();
    return wrm.data.toSingle(type, value);
  }
  
  /* For roles, verify that the value is an instance of the inverse entity */
  var inverseEntity = property.getInverseEntity();
  if (value instanceof this._getEntityConstructor(inverseEntity)) {
    return value;
  }
  
  /* Treat the non-entity-instance value as the value of the key */
  if (value === null) {
    return null;
  }
  var entitySet = this._entityContext[inverseEntity.getSetName()];
  var keyValues = {};
  var keyName = inverseEntity.getKeyAttribute().getName();
  keyValues[keyName] = value;
  return entitySet.attachOrGet(keyValues);
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @return {!Function}
 */
wrm.data.JDDataContext.prototype._getEntityConstructor = function(entity) {
  var inverseEntityCtor = wrm.util.obj.lookup(entity.getName());
  return (inverseEntityCtor);
};

/**
 * @package
 * @param {!$data.Queryable} queryable
 * @param {function(?=)} iterator
 * @return {!Promise.<!Array>}
 */
wrm.data.JDDataContext.prototype["iterateResults"] = function(queryable, iterator) {
  return queryable.forEach(iterator, this._transaction || undefined);
};

/**
 * @package
 * @param {!$data.Queryable} queryable
 * @return {!Promise.<!Array>}
 */
wrm.data.JDDataContext.prototype["loadResults"] = function(queryable) {
  return queryable.toArray(undefined, this._transaction || undefined);
};

/**
 * @package
 * @return {!Promise}
 */
wrm.data.JDDataContext.prototype["saveChanges"] = function() {
  return this._entityContext.saveChanges(undefined, this._transaction || undefined);
};

/**
 * @override
 * @const
 */
wrm.data.JDDataContext.prototype.disableChangeTracking = function() {
  this._dataTrackerService = null;
};

/**
 * @override
 * @const
 */
wrm.data.JDDataContext.prototype.isChangeTrackingEnabled = function() {
  return !!this._dataTrackerService;
};

/** @override */
wrm.data.JDDataContext.prototype.configureQuery = function(query) {
  wrm.data.JDDataContext._super.configureQuery.call(this, query);
  
  /* Add change tracking if enabled and possibly required by the entity */
  if (this._dataTrackerService && !(query instanceof wrm.data.JSelectQuery) && this._dataTrackerService.isRelevantEntity(query.getEntity())) {
    if (!this._subRunner) {
      throw new Error("Sub-runner not available");
    }
    var changeTracker = new wrm.data.JDChangeTracker(query.getEntity(), this._subRunner, this._dataTrackerService);
    query.setChangeTracker(changeTracker);
  }
};

/** @override */
wrm.data.JDDataContext.prototype.configureQueryNew = function(query) {
  wrm.data.JDDataContext._super.configureQueryNew.call(this, query);
  
  if (this._dataTrackerService && !(query instanceof wrm.data.XSelectQuery || query instanceof wrm.data.XDeleteQuery) && this._dataTrackerService.isRelevantEntity(query.getBaseElement())) {
    throw new Error("Change tracking not possible with new queries");
  }
  
  if (this.isChangeTrackingEnabled()) {
    this.addChangeListener(this._trackingListener);
  }
  
};

/** @override */
wrm.data.JDDataContext.prototype.interceptQueryResult = function(query, resultPromise) {
  resultPromise = wrm.data.JDDataContext._super.interceptQueryResult.call(this, query, resultPromise);
  
  /* If the query did track changes, submit or discard them before returning the result */
  var changeTracker = query.getChangeTracker();
  if (changeTracker) {
    return resultPromise.then(function(result) {
      return changeTracker.submitChanges().then(function() {
        return result;
      });
    }, function(e) {
      changeTracker.discardChanges();
      throw e;
    });
  }
  
  return resultPromise;
};

/** @override */
wrm.data.JDDataContext.prototype.interceptQueryResultNew = function(query, resultPromise) {
  resultPromise = wrm.data.JDDataContext._super.interceptQueryResultNew.call(this, query, resultPromise);
  
  /* If the query did track changes, submit or discard them before returning the result */
  if (this.isChangeTrackingEnabled()) {
    var trackingListener = this._trackingListener;
    return resultPromise.then(function(result) {
      return trackingListener.submitChanges().then(function() {
        return result;
      });
    }, function(e) {
      trackingListener.discardChanges();
      throw e;
    });
  }
  
  return resultPromise;
};

/*
 * Internal data-runner
 */

/**
 * @private
 * @constructor
 * @implements wrm.data.DataRunner
 * @param {!wrm.data.JDDataContext} parent
 */
wrm.data.JDDataContext._SubRunner = function(parent) {
  
  /** @private */
  this._entityContext = parent._entityContext;
  
  /** @private */
  this._parentInTransaction = !!parent._transaction;
  
  /** @private */
  this._dataService = parent.getDataService();
};

/** @override */
wrm.data.JDDataContext._SubRunner.prototype.prepareSelect = function(entityId, options) {
  return this._dataService.prepareSelect(entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareOldSelect = function(entityId, options) {
  return this._dataService.prepareOldSelect(entityId, options);
};

/** @override */
wrm.data.JDDataContext._SubRunner.prototype.prepareInsert = function(entityId, insert) {
  return this._dataService.prepareInsert(entityId, insert);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @return {!wrm.data.XEntityInsertQuery}
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareNewInsert = function(entityId, insert) {
  return this._dataService.prepareNewInsert(entityId, insert);
};

/** @override */
wrm.data.JDDataContext._SubRunner.prototype.prepareUpdate = function(entityId, options) {
  return this._dataService.prepareUpdate(entityId, options);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @return {!wrm.data.XUpdateQuery}
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareNewUpdate = function(entityId, options) {
  return this._dataService.prepareNewUpdate(entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareOldDelete = function(entityId, options) {
  return this._dataService.prepareOldDelete(entityId, options);
};

/** @override */
wrm.data.JDDataContext._SubRunner.prototype.prepareDelete = function(entityId, options) {
  return this._dataService.prepareDelete(entityId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @return {!wrm.data.XAssocSelectQuery}
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareNewAssociationSelect = function(assocId, options) {
  return this._dataService.prepareNewAssociationSelect(assocId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @return {!wrm.data.XAssocInsertQuery}
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareNewAssociationInsert = function(assocId, insert) {
  return this._dataService.prepareNewAssociationInsert(assocId, insert);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @return {!wrm.data.XAssocUpdateQuery}
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareNewAssociationUpdate = function(assocId, options) {
  return this._dataService.prepareNewAssociationUpdate(assocId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @return {!wrm.data.XAssocDeleteQuery}
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareNewAssociationDelete = function(assocId, options) {
  return this._dataService.prepareNewAssociationDelete(assocId, options);
};

/**
 * @override
 * @deprecated
 */
wrm.data.JDDataContext._SubRunner.prototype.prepareCondition = function(entityId, expression) {
  return this._dataService.prepareCondition(entityId, expression);
};

/** @override */
wrm.data.JDDataContext._SubRunner.prototype.execute = function(callback, inTransaction) {
  var entityContext = this._entityContext;
  var dataService = this._dataService;
  
  /* Work in a transaction if asked to and the parent is not already inside one */
  var txPromise;
  if (inTransaction && !this._parentInTransaction) {
    txPromise = entityContext.beginTransaction(true, function(tx) {
      tx["keepAlive"](300, 500);
    });
  } else {
    txPromise = Promise.resolve(null);
  }
  
  /* Create a new data context like the parent one, but with tracking disabled */
  return txPromise.then(function(tx) {
    var dataContext = new wrm.data.JDDataContext(entityContext, tx, null, dataService);
    return Promise.resolve(callback(dataContext)).finally(function() {
      if (tx) {
        tx["release"]();
      }
    });
  });
};




//== wrm/data/JDPropertyFiller.js =============================================



/**
 * @package
 * @constructor
 * @param {string} targetPropertyName
 * @param {!wrm.data.PropertyRef} propertyRef
 */
wrm.data.JDPropertyFiller = function(targetPropertyName, propertyRef) {
  
  /** @private */
  this._targetPropertyName = targetPropertyName;
  
  /** @private */
  this._roles = propertyRef.getRoles();
  
  /** @private */
  this._resolvedReference = propertyRef.getResolvedReference();
  
  /** @private */
  this._many = this._roles.some(function(role) {
    return role.isMany();
  });
};

/**
 * @param {!Object} target
 * @param {!Object} object
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDPropertyFiller.prototype.fill = function(target, object, dataContext) {
  var thisFiller = this;
  return this._doFill(object, this._roles, dataContext).then(function() {
    thisFiller._setTargetValue(target, object);
  });
};

/**
 * @private
 * @param {!Object} object
 * @param {!Array.<!wrm.data.meta.Role>} roles
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDPropertyFiller.prototype._doFill = function(object, roles, dataContext) {
  var thisFiller = this;
  
  /* If there are still roles to follow on the path, follow the first one */
  if (roles.length > 0) {
    return wrm.data.JDPropertyFiller.retrieveRoleValues(object, roles, dataContext).then(function(instances) {
      
      /* Fill the remaining roles on all instances */
      var nextRoles = roles.slice(1);
      return instances.reduce(function(chain, instance) {
        return chain.then(function() {
          return thisFiller._doFill(instance, nextRoles, dataContext);
        });
      }, Promise.resolve());
    });
  }
  
  return Promise.resolve();
};

/**
 * @private
 * @param {!Object} target
 * @param {!Object} object
 */
wrm.data.JDPropertyFiller.prototype._setTargetValue = function(target, object) {
  var mapper = new wrm.util.ObjectMapper(object);
  mapper.setFlattenArrays(true);
  
  var value = mapper.getValues(this._resolvedReference);
  if (!this._many) {
    value = wrm.data.toAnySingle(value);
  }
  target[this._targetPropertyName] = value;
};

/**
 * @package
 * @param {!Object} object
 * @param {!Array.<!wrm.data.meta.Role>} roles
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<!Array.<!Object>>}
 */
wrm.data.JDPropertyFiller.retrieveRoleValues = function(object, roles, dataContext) {
  var role = roles[0];
  
  /* Attempt a direct get from the object */
  var value = object[role.getName()];
  if (value || value === null && role.isForeignKey()) {
    return Promise.resolve(wrm.data.toAnyArray(value));
  }
  
  /*
   * The role has no value (not even an empty array). This may be one of the cases that JayData cannot fill by itself (e.g. if we are
   * on the non-foreign-key side), so try again after filling the role
   */
  return wrm.data.JDPropertyFiller._fillRole(object, roles, dataContext).then(function() {
    return wrm.data.toAnyArray(object[role.getName()]);
  });
};

/**
 * @private
 * @param {!Object} object
 * @param {!Array.<!wrm.data.meta.Role>} roles
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise}
 */
wrm.data.JDPropertyFiller._fillRole = function(object, roles, dataContext) {
  var DataContextHelper = wrm.data.DataContextHelper;
  
  /* Find the first role to fill and the additional ones that can be filled by JayData 'include' */
  if (roles.length <= 0) {
    return Promise.resolve();
  }
  var firstNearRole = roles[0];
  var firstFarRole = firstNearRole.getInverseRole();
  var otherRoles = wrm.data.JDPropertyFiller.getIncludableRoles(roles.slice(1));
  
  var entity = firstNearRole.getEntity();
  var farEntity = firstFarRole.getEntity();
  
  /* Prepare the reference to other roles that can be included besides the first one */
  var otherRoleReference = otherRoles.map(function(otherRole) {
    return otherRole.getName();
  }).join(".");
  
  var entitySet = DataContextHelper.retrieveEntitySet(dataContext, entity);
  var farEntitySet = DataContextHelper.retrieveEntitySet(dataContext, farEntity);
  
  /*
   * Select related instances of the FAR entity, including all other roles. Use a different query strategy depending on where the
   * foreign key is.
   */
  var promise;
  if (firstNearRole.isForeignKey()) {
    
    /* Foreign key on NEAR entity: obtain the far primary key and select from there */
    promise = Promise.resolve().then(function() {
      var q = entitySet.filter("it." + entity.getKeyAttribute().getName() + " \x3d\x3d\x3d this.key", {"key":object[entity.getKeyAttribute().getName()]}).map("it." + firstNearRole.getName() + "." + farEntity.getKeyAttribute().getName());
      return DataContextHelper.loadResults(dataContext, q);
    }).then(function(farKeys) {
      if (farKeys.length > 0) {
        var q = farEntitySet;
        if (otherRoleReference) {
          q = q.include(otherRoleReference);
        }
        q = q.filter("it." + farEntity.getKeyAttribute().getName() + " \x3d\x3d\x3d this.farKey", {"farKey":farKeys[0]});
        return DataContextHelper.loadResults(dataContext, q).then(function(farObjects) {
          return farObjects[0] || null;
        });
      }
      return null;
    });
    
  } else {
    
    /* Foreign key on FAR entity: select from there using the known near key */
    promise = Promise.resolve().then(function() {
      var q = farEntitySet;
      if (otherRoleReference) {
        q = q.include(otherRoleReference);
      }
      q = q.filter("it." + firstFarRole.getName() + "." + entity.getKeyAttribute().getName() + " \x3d\x3d\x3d this.key", {"key":object[entity.getKeyAttribute().getName()]});
      return DataContextHelper.loadResults(dataContext, q);
    });
    
  }
  
  /* Assign instances to the object first role */
  return promise.then(function(instances) {
    var value = firstNearRole.isMany() ? wrm.data.toAnyArray(instances) : wrm.data.toAnySingle(instances);
    object[firstNearRole.getName()] = value;
  });
};

/**
 * @package
 * @param {!Array.<!wrm.data.meta.Role>} roles
 * @return {!Array.<!wrm.data.meta.Role>}
 */
wrm.data.JDPropertyFiller.getIncludableRoles = function(roles) {
  
  /* JayData can automatically include roles up to the first one with 'many' cardinality */
  var firstManyRoleIndex = -1;
  for (var i = 0;i < roles.length;i++) {
    if (roles[i].isMany()) {
      firstManyRoleIndex = i;
      break;
    }
  }
  
  return firstManyRoleIndex >= 0 ? roles.slice(0, firstManyRoleIndex + 1) : roles.slice(0);
};

/**
 * @package
 * @param {!wrm.data.PropertyRef} propertyRef
 * @return {boolean}
 */
wrm.data.JDPropertyFiller.isFillingRequired = function(propertyRef) {
  
  /*
   * The use of a filler is required if the reference points to a property passing through at least one role that has MANY
   * cardinality (i.e. a 1:N association navigated from the '1' side to the 'N' side). It is not a problem is that role is itself the
   * last, but only if that role is followed by more roles or an attribute. Basically JayData is unable to continue following a
   * reference after it has "exploded" the values into the list of instances pointed by a role (a.k.a. "navigation property").
   */
  var roles = propertyRef.getRoles();
  var length = propertyRef.getProperty() instanceof wrm.data.meta.Role ? roles.length - 1 : roles.length;
  for (var i = 0;i < length;i++) {
    if (roles[i].isMany()) {
      return true;
    }
  }
  
  return false;
};




//== wrm/data/JSelectQuery.js =================================================


/**
 * @constructor
 * @extends wrm.data.FilteredQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {{ output: (!Object<string,string>|!Array<string>|string|undefined), distinct: (boolean|undefined), include:
 *            (!Array<string>|string|undefined), filter: (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined), order:
 *            (!Array<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string|undefined), limit:
 *            ({begin:number,count:number}|number|undefined) }=} options
 */
wrm.data.JSelectQuery = function(metadata, entityId, options) {
  wrm.data.FilteredQuery.call(this, metadata, entityId, options && options.include, options && options.filter);
  
  /** @private */
  this._output = options && options.output;
  
  /**
   * @private
   * @type {?{expression:string, infos:!Array<wrm.data.JSelectQuery._ProjectionInfo>,
   *       exposedInfos:!Array<wrm.data.JSelectQuery._ProjectionInfo>, multipleExposed:boolean}}
   */
  this._projector = null;
  
  /** @private */
  this._distinct = options && options.distinct || false;
  
  /** @private */
  this._orderCriteria = this._createOrderCriteria(options && options.order);
  
  /** @private */
  this._limits = this._createLimits(options && options.limit);
};

extendConstructor(wrm.data.JSelectQuery, wrm.data.FilteredQuery);

/**
 * @typedef {{expose:(boolean|string), property:!wrm.data.meta.Property, resolvedReference:string, filled:boolean }}
 */
wrm.data.JSelectQuery._ProjectionInfo;

/**
 * @private
 * @param {!Object<string,string>|!Array<string>|string|undefined} outputs
 * @return {{expression:string, filler:?(function(!Object,!Object,!wrm.data.DataContext):!Promise),
 *         infos:!Array<wrm.data.JSelectQuery._ProjectionInfo>, exposedInfos:!Array<wrm.data.JSelectQuery._ProjectionInfo>,
 *         multipleExposed:boolean}}
 */
wrm.data.JSelectQuery.prototype._createProjector = function(outputs) {
  var JDDataMover = wrm.data.JDDataMover;
  var thisQuery = this;
  var entity = this.getEntity();
  
  var exposedMetaAttributes = this.getExposedMetaAttributes();
  
  /* Function for resolving each output and keeping track of it in the query state */
  function resolveOutput(output) {
    var ref = wrm.data.PropertyRef.of(thisQuery.getEntity(), output, exposedMetaAttributes.length > 0);
    
    /* Keep track of included roles */
    var includedRoleRef = ref.getLastRoleRef();
    if (includedRoleRef) {
      thisQuery.addIncludedRole(includedRoleRef);
    }
    
    return ref;
  }
  
  /* Function and array for tracking the references that will require to be filled later */    /** @type {!Array<function(!Object,!Object,!wrm.data.DataContext):!Promise>} */
  var propertyFillerFunctions = [];
  function trackFilledRefs(property, propertyRef) {
    if (wrm.data.JDPropertyFiller.isFillingRequired(propertyRef)) {
      var filler = new wrm.data.JDPropertyFiller(property.getId(), propertyRef);
      propertyFillerFunctions.push(filler.fill.bind(filler));
      return true;
    }
    return false;
  }
  
  /* Determine which properties to project */    /** @type {!Array<wrm.data.JSelectQuery._ProjectionInfo>} */
  var infos = [];
  
  /* First determine the EXPOSED properties, to be actually put in results */
  var exposedProperties = [];
  if (!outputs) {
    
    /* No outputs: all attributes are projected with the addition of "auto-included" roles */
    var allExposedAttributes = entity.getAttributes().slice(0);
    Array.prototype.push.apply(allExposedAttributes, exposedMetaAttributes);
    allExposedAttributes.forEach(function(attribute) {
      infos.push({expose:attribute.getName(), property:attribute, resolvedReference:attribute.getName(), filled:false});
      exposedProperties.push(attribute);
    });
    this.getIncludedRoleRefs().forEach(function(roleRef) {
      var role = roleRef.getProperty();
      infos.push({expose:role.getName(), property:role, resolvedReference:roleRef.getPhysicalRef().getResolvedReference(), filled:trackFilledRefs(role, roleRef.getPhysicalRef())});
      exposedProperties.push(role);
    });
    
  } else {
    if (typeof outputs === "string") {
      
      /* Only a STRING output: project the value on it */
      var ref = resolveOutput(outputs);
      infos.push({expose:true, property:ref.getProperty(), resolvedReference:ref.getPhysicalRef().getResolvedReference(), filled:trackFilledRefs(ref.getProperty(), ref.getPhysicalRef())});
      exposedProperties.push(ref.getProperty());
      
    } else {
      
      /* Resolve each output reference */
      var useAlias = !angular.isArray(outputs);
      angular.forEach(outputs, function(output, alias) {
        var ref = resolveOutput(output);
        var property = ref.getProperty();
        var propertyName;
        if (useAlias) {
          propertyName = alias;
        } else {
          propertyName = property.getEntity() !== entity ? output.replace(".", "_") : property.getName();
        }
        infos.push({expose:propertyName, property:property, resolvedReference:ref.getPhysicalRef().getResolvedReference(), filled:trackFilledRefs(property, ref.getPhysicalRef())});
        exposedProperties.push(property);
      }, this);
    }
  }
  
  /* Next, determine the ADDITIONAL non-exposed properties that may be required for unloading result values */
  JDDataMover.computeAdditionalUnloadProperties(exposedProperties).forEach(function(property) {
    infos.push({expose:false, property:property, resolvedReference:property.getName(), filled:false});
  });
  
  /* Compute the projection expression, which should include ALL properties in order for them to be available for processing later */
  var expression = "{" + infos.map(function(info) {
    return info.property.getId() + ": " + (!info.filled ? "it." + info.resolvedReference : "null");
  }).join(", ") + "}";
  
  /* Prepare a single filler function */
  var fillerFunction;
  if (propertyFillerFunctions.length > 0) {
    fillerFunction = function(target, object, dataContext) {
      return propertyFillerFunctions.reduce(function(chain, fn) {
        return chain.then(function() {
          return fn(target, object, dataContext);
        });
      }, Promise.resolve());
    };
  } else {
    fillerFunction = null;
  }
  
  return {expression:expression, filler:fillerFunction, infos:infos, exposedInfos:infos.filter(function(info) {
    return info.expose !== false;
  }), multipleExposed:exposedProperties.length > 1};
};

/**
 * @private
 * @param {!Array<{property:string,reverse:boolean}|string>|{property:string,reverse:boolean}|string=} order
 * @return {!Array<{property:string,reverse:boolean}>}
 */
wrm.data.JSelectQuery.prototype._createOrderCriteria = function(order) {
  if (!order) {
    return [];
  }
  
  if (!angular.isArray(order)) {
    order = [order];
  }
  
  /* Resolve each order criteria */
  var orderCriteria = [];
  angular.forEach((order), function(anOrder) {
    var property = anOrder.property || anOrder;
    var reverse = anOrder.reverse || false;
    var ref = wrm.data.PropertyRef.of(this.getEntity(), property);
    if (!(ref.getProperty() instanceof wrm.data.meta.Attribute)) {
      throw new Error("Cannot order by non-attribute '" + property + "'");
    }
    
    /* Keep track of included roles */
    var includedRoleRef = ref.getLastRoleRef();
    if (includedRoleRef) {
      this.addIncludedRole(includedRoleRef);
    }
    
    orderCriteria.push({property:"it." + ref.getPhysicalRef().getResolvedReference(), reverse:reverse});
  }, this);
  
  return orderCriteria;
};

/**
 * @private
 * @param {{begin:number,count:number}|number=} limit
 * @return {{begin:?number,count:?number}}
 */
wrm.data.JSelectQuery.prototype._createLimits = function(limit) {
  
  /* Take a lone number as a 'count' value */
  var begin, count;
  if (typeof limit === "number") {
    begin = null;
    count = limit;
  } else {
    begin = limit && limit.begin || null;
    count = limit && limit.count || null;
  }
  
  return {begin:begin, count:count};
};

/** @override */
wrm.data.JSelectQuery.prototype.setExposedMetaAttributes = function(families) {
  wrm.data.JSelectQuery._super.setExposedMetaAttributes.apply(this, arguments);
  
  /* Invalidate projector */
  this._projector = null;
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.JSelectQuery.prototype.query = function(dataContext, parameters) {
  var thisQuery = this;
  
  this.checkDataContext(dataContext);
  var q = this._createQueryableWithMaxCount(dataContext, parameters || {}, null);
  if (!q) {
    return Promise.resolve([]);
  }
  
  return this.loadResults(dataContext, q).then(function(results) {
    return thisQuery._processResults(dataContext, results);
  });
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<?Object|*>}
 */
wrm.data.JSelectQuery.prototype.queryOne = function(dataContext, parameters) {
  var thisQuery = this;
  
  this.checkDataContext(dataContext);
  var q = this._createQueryableWithMaxCount(dataContext, parameters || {}, 1);
  if (!q) {
    return Promise.resolve((null));
  }
  
  return this.loadResults(dataContext, q).then(function(results) {
    return thisQuery._processResults(dataContext, results).then(function(results) {
      
      /* Because of the forced maximum count, results contains either 0 or 1 element */
      return results[0] || null;
    });
  });
};

/**
 * @override
 * @internal
 */
wrm.data.JSelectQuery.prototype.createQueryable = function(dataContext, parameters) {
  return this._createQueryableWithMaxCount(dataContext, parameters, null);
};

/**
 * @private
 * @param {?number} maxCount
 * @return {?$data.Queryable}
 */
wrm.data.JSelectQuery.prototype._createQueryableWithMaxCount = function(dataContext, parameters, maxCount) {
  if (!this._projector) {
    this._projector = this._createProjector(this._output);
  }
  
  var q = wrm.data.JSelectQuery._super.createQueryable.call(this, dataContext, parameters);
  if (!q) {
    return null;
  }
  
  /* Apply the projector expression */
  if (this._projector.filler) {
    q = wrm.data.LateFilteredQueryable.wrap(q, this.getEntity(), this.getIncludedRoles(), dataContext);
    q.initMapperFunction(this._projector.filler);
  }
  q = q.map(this._projector.expression);
  
  /* Apply order criteria */
  angular.forEach(this._orderCriteria, function(orderCriterium) {
    if (orderCriterium.reverse) {
      q = q.orderByDescending(orderCriterium.property);
    } else {
      q = q.orderBy(orderCriterium.property);
    }
  });
  
  /* Apply limits */
  if (this._limits.begin !== null) {
    q = q.skip(this._limits.begin);
  }
  if (this._limits.count !== null || maxCount !== null) {
    if (maxCount !== null) {
      q = q.take(maxCount);
    } else {
      q = q.take(this._limits.count);
    }
  }
  
  return q;
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Array} results
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.JSelectQuery.prototype._processResults = function(dataContext, results) {
  var JDDataMover = wrm.data.JDDataMover;
  var infos = this._projector.exposedInfos;
  
  /* Prepare a set for tracking distinct processed results */
  var tableSet = null;
  if (this._distinct) {
    var propertiesArray = [];
    if (this._projector.multipleExposed !== null) {
      infos.forEach(function(info) {
        if (typeof info.expose === "string") {
          propertiesArray.push(info.expose);
        }
      });
    }
    tableSet = new wrm.data.ObjectSet(propertiesArray);
  }
  
  /* Process each result row (use native loops for performance) */
  var processedResults = [];
  var asyncValuesPromises = [];
  for (var resultIndex = 0;resultIndex < results.length;resultIndex++) {
    var result = results[resultIndex];
    var processed = {};
    processedResults[resultIndex] = processed = {};
    
    /* Extract each property value, using the correct type */
    for (var i = 0;i < infos.length;i++) {
      var info = infos[i];
      var property = info.property;
      var expose = info.expose;
      var valueOrPromise = JDDataMover.unload(result, property, property.getId(), dataContext);
      
      /* Save to a property or to the entire array element */
      if (valueOrPromise !== undefined) {
        if (expose !== true) {
          processed[expose] = valueOrPromise;
        } else {
          processedResults[resultIndex] = valueOrPromise;
        }
      }
      
      /* Post-process asynchronous values (cannot use the 'processed' variable) */
      if (wrm.util.isPromise(valueOrPromise)) {
        asyncValuesPromises.push(function(resultIndex, expose) {
          asyncValuesPromises.push(valueOrPromise.then(function(value) {
            if (expose !== true) {
              if (value !== undefined) {
                processedResults[resultIndex][expose] = value;
              } else {
                delete processedResults[resultIndex][expose];
              }
            } else {
              processedResults[resultIndex] = value;
            }
          }));
        }(resultIndex, expose));
      }
    }
  }
  
  /* Wait for any asynchronous value */
  return Promise.all(asyncValuesPromises).then(function() {
    
    /* Eliminate duplicates if 'distinct' is active */
    if (tableSet) {
      for (var i = 0;i < processedResults.length;i++) {
        if (!tableSet.add(processedResults[i])) {
          processedResults.splice(i--, 1);
        }
      }
    }
    
    return processedResults;
  });
};




//== wrm/data/UpdateQuery.js ==================================================



/**
 * @constructor
 * @extends wrm.data.FilteredQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {{ update: ((function(!Object):!Object)|!Object), include: (!Array<string>|string|undefined), filter:
 *            (!wrm.data.Condition|!wrm.data.Condition.Expression|undefined) }=} options
 */
wrm.data.UpdateQuery = function(metadata, entityId, options) {
  wrm.data.FilteredQuery.call(this, metadata, entityId, options && options.include, options && options.filter);
  
  /* Extract the updates to do */
  var update = options && options.update;
  if (!update) {
    throw new Error("Update values not specified");
  }
  
  /**
   * @private
   * @type {(function(!Object):!Object)|!Object}
   */
  this._update = update;
};

extendConstructor(wrm.data.UpdateQuery, wrm.data.FilteredQuery);

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.UpdateQuery.prototype.execute = function(dataContext, parameters) {
  if (parameters && parameters["useNewishQueries"]) {
    return wrm.data.NewQueries.update(this, this._update, dataContext, parameters);
  }
  
  var thisQuery = this;
  
  this.checkDataContext(dataContext);
  var keyAttribute = this.getEntity().getKeyAttribute();
  var keyAttributeName = keyAttribute && keyAttribute.getName();
  var q = this.createQueryable(dataContext, parameters || {});
  if (!q) {
    return Promise.resolve([]);
  }
  
  /** @type {!Array<function():!Promise>} */
  var postUpdateFunctions = [];
  
  /* Create the functions for carrying out updates */
  var promise = this._createUpdateObjects(dataContext, parameters);
  
  /* Update each object in the entity set */
  var oldObjects = this.hasChangeListeners() ? [] : null;
  var updatedObjects = [];
  promise = promise.then(function(objs) {
    var updatePromise = Promise.resolve();
    return thisQuery.iterateResults(dataContext, (q), function(object) {
      
      /* Body */
      updatePromise = updatePromise.then(function() {
        object = thisQuery.includeInContext(dataContext, object);
        return thisQuery.enlistForUpdate(object);
      }).then(function(object) {
        if (oldObjects) {
          oldObjects.push(thisQuery._extractValues(object));
        }
        objs.updateFunction(object);
        if (objs.postUpdateFunction) {
          postUpdateFunctions.push(objs.postUpdateFunction.bind(null, object));
        }
        
        /* Keep track of updated objects */
        updatedObjects.push(object);
      });
    }).then(function() {
      return updatePromise;
    });
  });
  
  /* Save changes */
  promise = promise.then(function() {
    return thisQuery.saveChanges(dataContext);
  });
  
  /* Run post-update functions, then save changes again */
  promise = promise.then(function() {
    return postUpdateFunctions.reduce(function(chain, fn) {
      return chain.then(function() {
        return fn();
      });
    }, Promise.resolve());
  }).then(function() {
    if (postUpdateFunctions.length > 0) {
      return thisQuery.saveChanges(dataContext);
    }
  });
  
  return promise.then(function() {
    
    /* Notify listeners */
    if (thisQuery.hasChangeListeners()) {
      updatedObjects.forEach(function(updatedObject, i) {
        var oldObject = oldObjects[i];
        thisQuery.notifyInstanceUpdated(oldObject, updatedObject);
      });
    }
    
    /* Collect the keys of all updated objects and return them */
    return updatedObjects.map(function(object) {
      return keyAttributeName ? object[keyAttributeName] : null;
    });
  });
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<undefined>}
 */
wrm.data.UpdateQuery.prototype.executeNoResult = function(dataContext, parameters) {
  var $jscomp$this = this;
  if (parameters && parameters["useNewishQueries"]) {
    return wrm.data.NewQueries.updateNoResult(this, this._update, dataContext, parameters);
  }
  
  this.checkDataContext(dataContext);
  this.setFastQuery(true);
  return this.execute(dataContext, parameters).finally(function() {
    $jscomp$this.setFastQuery(false);
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<{updateFunction:function(!Object), postInsertFunction:?function(!Object):Promise}>}
 */
wrm.data.UpdateQuery.prototype._createUpdateObjects = function(dataContext, parameters) {
  var JDDataMover = wrm.data.JDDataMover;
  var entity = this.getEntity();
  var changeTracker = this.getChangeTracker();
  
  /* Compute actual update values from update function */
  var updateValues;
  if (typeof this._update === "function") {
    updateValues = this._update(parameters);
  } else {
    updateValues = this._update;
  }
  
  /* Prepare updated values (by NAME) converted to the correct type and a additional post-update functions */
  var propertyUpdates = {};
  var propertyPostSetFunctions = [];
  var loadPromises = [];
  angular.forEach(updateValues, function(value, propertyId) {
    var property = entity.getProperty(propertyId, true);
    if (property instanceof wrm.data.meta.Role) {
      var accessor = wrm.data.RoleAccessor.get(property);
      var postSetRequired = accessor.set(propertyUpdates, value, dataContext);
      if (postSetRequired) {
        propertyPostSetFunctions.push(function(object) {
          return accessor.postSet(object, value, changeTracker, dataContext);
        });
      }
    } else {
      var postSetRequired = JDDataMover.isPostOperationRequired((property));
      var convertedValue = dataContext.castToSingleValue(property, value);
      loadPromises.push(JDDataMover.load(propertyUpdates, property, convertedValue));
      if (postSetRequired) {
        propertyPostSetFunctions.push(function(object) {
          return JDDataMover.postUpdate((property), object[property.getEntity().getKeyAttribute().getName()], (convertedValue), dataContext);
        });
      }
    }
  });
  
  /* Prepare a single post-update function */
  var postUpdateFunction;
  if (propertyPostSetFunctions.length > 0) {
    postUpdateFunction = function(object) {
      return propertyPostSetFunctions.reduce(function(chain, fn) {
        return chain.then(function() {
          return fn(object);
        });
      }, Promise.resolve());
    };
  } else {
    postUpdateFunction = null;
  }
  
  return Promise.all(loadPromises).then(function() {
    
    /* Prepare a function that updates all properties of the passed object */
    function updateFunction(object) {
      for (var propertyName in propertyUpdates) {
        if (propertyUpdates.hasOwnProperty(propertyName)) {
          object[propertyName] = propertyUpdates[propertyName];
        }
      }
    }
    
    return {updateFunction:updateFunction, postUpdateFunction:postUpdateFunction};
  });
};

/**
 * @private
 * @param {Object} object
 * @return {!Object}
 */
wrm.data.UpdateQuery.prototype._extractValues = function(object) {
  var result = {};
  if (object) {
    this.getEntity().getProperties().forEach(function(property) {
      var propertyName = property.getName();
      result[propertyName] = object[propertyName];
    });
  }
  return result;
};




//== wrm/data/XQuery.js =======================================================


wrm.data.XQuery = function(baseElement) {
  
  /**
   * @protected
   * @const
   */
  this.baseElement = baseElement;
  
  /**
   * @private
   * @type {wrm.data.XDConfiguration}
   */
  this._lastConfig = null;
  
};

/**
 * @return {B}
 */
wrm.data.XQuery.prototype.getBaseElement = function() {
  return this.baseElement;
};

/**
 * @package
 * @return {string}
 */
wrm.data.XQuery.prototype.getXDataBaseElementName = ABSTRACT_METHOD;

/**
 * @package
 * @param {string} elementIdPath
 * @return {string}
 */
wrm.data.XQuery.prototype.getXDataPropertyPath = ABSTRACT_METHOD;

/**
 * @protected
 * @const
 * @param {!wrm.data.DataContext} dataContext
 */
wrm.data.XQuery.prototype.checkDataContext = function(dataContext) {
  if (dataContext.getMetadata() !== this.baseElement.getMetadata()) {
    throw new Error("The query was created against a different set of metadata");
  }
};

/*
 * XData id-name mapping for ENTITIES
 */

/**
 * @package
 * @param {!wrm.data.meta.Entity} entity
 * @return {string}
 */
wrm.data.XQuery.getEntityXDataName = function(entity) {
  
  /* Entities are named using their SET NAME in XData schema */
  return entity.getSetName();
};

/**
 * @param {!wrm.data.meta.Entity} entity
 * @param {string} elementIdPath
 * @return {string}
 */
wrm.data.XQuery.getEntityXDataPropertyPath = function(entity, elementIdPath) {
  
  /*
   * Valid paths in XData start with an optional chain of role references and end with an attribute reference. All the said XData
   * references use the element NAME.
   */
  
  /* Resolve as an element reference based on the entity */
  return wrm.data.PropertyRef.of(entity, elementIdPath).getResolvedReference();
};

/*
 * XData id-name mapping for ASSOCIATIONS
 */

/**
 * @package
 * @param {!wrm.data.meta.Association} assoc
 * @return {string}
 */
wrm.data.XQuery.getAssociationXDataName = function(assoc) {
  
  /* Associations are named using their ID in XData schema */
  return assoc.getId();
};

/**
 * @param {!wrm.data.meta.Association} assoc
 * @param {string} elementIdPath
 * @return {string}
 */
wrm.data.XQuery.getAssociationXDataPropertyPath = function(assoc, elementIdPath) {
  
  /*
   * Valid paths in XData start with a relationship-role reference, which uses the ROLE ID as name. Valid paths then continue with an
   * optional chain of role references and end with an attribute reference: all these latter XData references use the element NAME.
   */
  
  var firstDotIndex = elementIdPath.indexOf(".");
  var assocRoleId = firstDotIndex >= 0 ? elementIdPath.substring(0, firstDotIndex) : elementIdPath;
  var remainingIdPath = firstDotIndex >= 0 ? elementIdPath.substring(firstDotIndex + 1) : null;
  
  /* Resolve the relationship-role directly, the rest as an element reference based on the reached entity */
  var relRoleName, entity;
  if (assoc.getRole1().getId() === assocRoleId) {
    relRoleName = assocRoleId;
    entity = assoc.getEntity1();
  } else {
    if (assoc.getRole2().getId() === assocRoleId) {
      relRoleName = assocRoleId;
      entity = assoc.getEntity2();
    } else {
      throw new Error("Unknown role '" + assocRoleId + "' connect to association " + assoc);
    }
  }
  if (remainingIdPath) {
    return relRoleName + "." + wrm.data.PropertyRef.of(entity, remainingIdPath).getResolvedReference();
  }
  return relRoleName;
};

/**
 * @protected
 * @param {?} query
 * @param {!wrm.data.DataContext} dataContext
 */
wrm.data.XQuery.prototype.configureXDataQuery = function(query, dataContext) {
  var config = dataContext.getQueryConfiguration();
  if (config !== this._lastConfig) {
    config.configureQuery(query, this.getBaseElement());
    this._lastConfig = config;
  }
};




//== wrm/data/XFilteredQuery.js ===============================================



wrm.data.XFilteredQuery = function(baseElement) {
  wrm.data.XQuery.call(this, baseElement);
};

extendConstructor(wrm.data.XFilteredQuery, wrm.data.XQuery);
/**
 * @package
 * @param {wrm.data.Condition.Expression} filter
 * @return {!Object|string}
 */
wrm.data.XFilteredQuery.prototype.prepareXDataFilterExpression = function(filter) {
  
  /* Prepare an "and" expression for arrays */
  if (Array.isArray(filter)) {
    return this._prepareXDataFilterLogicAndArrayExpression((filter));
  }
  
  if (typeof filter === "object") {
    
    /* Prepare an "and", "or", "not" expression for object with a logic-operator property */
    if (filter.and) {
      return this._prepareXDataFilterLogicAndExpression((filter));
    } else {
      if (filter.or) {
        return this._prepareXDataFilterLogicOrExpression((filter));
      } else {
        if (filter.not) {
          return this._prepareXDataFilterLogicNotExpression((filter));
        }
      }
    }
    
    /* Prepare a generic term for other objects */
    return this._prepareXDataFilterGenericTerm((filter));
  }
  
  /* Prepare a single equal term for strings */
  return this._prepareXDataFilterSingleEqualTerm(filter);
};
/**
 * @private
 * @param {!Array<!wrm.data.Condition.Expression>} filterAndArray
 * @return {!Object}
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterLogicAndArrayExpression = function(filterAndArray) {
  return filterAndArray.map(this.prepareXDataFilterExpression, this);
};
/**
 * @private
 * @param {{and:!Array<!wrm.data.Condition.Expression>, config:(!wrm.data.Condition.Config|undefined)}} filterAnd
 * @return {!Object}
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterLogicAndExpression = function(filterAnd) {
  var result = {};
  result["and"] = filterAnd.and.map(this.prepareXDataFilterExpression, this);
  if (filterAnd.config) {
    result["config"] = this._prepareXDataFilterConfig(filterAnd.config);
  }
  return result;
};
/**
 * @private
 * @param {{or:!Array<!wrm.data.Condition.Expression>, config:(!wrm.data.Condition.Config|undefined)}} filterOr
 * @return {!Object}
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterLogicOrExpression = function(filterOr) {
  var result = {};
  result["or"] = filterOr.or.map(this.prepareXDataFilterExpression, this);
  if (filterOr.config) {
    result["config"] = this._prepareXDataFilterConfig(filterOr.config);
  }
  return result;
};
/**
 * @private
 * @param {{not:!wrm.data.Condition.Expression, config:(!wrm.data.Condition.Config|undefined)}} filterNot
 * @return {!Object}
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterLogicNotExpression = function(filterNot) {
  var result = {};
  result["not"] = this.prepareXDataFilterExpression(filterNot.not);
  if (filterNot.config) {
    result["config"] = this._prepareXDataFilterConfig(filterNot.config);
  }
  return result;
};

/**
 * @private
 * @type {!Object<string,!xdata.ValueOperator>}
 */
wrm.data.XFilteredQuery._VALUE_OPERATOR_MAP = function(map) {
  var ValueOperator = xdata.ValueOperator;
  map["e"] = ValueOperator.EMPTY;
  map["!e"] = ValueOperator.NOT_EMPTY;
  map["n"] = ValueOperator.NULL;
  map["!n"] = ValueOperator.NOT_NULL;
  map["in"] = ValueOperator.IN;
  map["!in"] = ValueOperator.NOT_IN;
  map["eq"] = ValueOperator.EQUAL;
  map["eq.ic"] = ValueOperator.EQUAL_IGNORE_CASE;
  map["!eq"] = ValueOperator.NOT_EQUAL;
  map["!eq.ic"] = ValueOperator.NOT_EQUAL_IGNORE_CASE;
  map["gt"] = ValueOperator.GREATER;
  map["gte"] = ValueOperator.GREATER_OR_EQUAL;
  map["lt"] = ValueOperator.LESSER;
  map["lte"] = ValueOperator.LESSER_OR_EQUAL;
  map["bw"] = ValueOperator.BEGINNING;
  map["bw.ic"] = ValueOperator.BEGINNING_IGNORE_CASE;
  map["!bw"] = ValueOperator.NOT_BEGINNING;
  map["!bw.ic"] = ValueOperator.NOT_BEGINNING_IGNORE_CASE;
  map["co"] = ValueOperator.CONTAINING;
  map["co.ic"] = ValueOperator.CONTAINING_IGNORE_CASE;
  map["!co"] = ValueOperator.NOT_CONTAINING;
  map["!co.ic"] = ValueOperator.NOT_CONTAINING_IGNORE_CASE;
  map["ew"] = ValueOperator.ENDING;
  map["ew.ic"] = ValueOperator.ENDING_IGNORE_CASE;
  map["!ew"] = ValueOperator.NOT_ENDING;
  map["!ew.ic"] = ValueOperator.NOT_ENDING_IGNORE_CASE;
  return map;
}({});

/**
 * @private
 * @type {!Object<string,!xdata.CollectionOperator>}
 */
wrm.data.XFilteredQuery._COLLECTION_OPERATOR_MAP = function(map) {
  var CollectionOperator = xdata.CollectionOperator;
  map["and"] = CollectionOperator.ALL;
  map["or"] = CollectionOperator.ANY;
  return map;
}({});
/**
 * @private
 * @param {{property:string, operator:(string|undefined), value:(*|undefined), valueOp:(string|undefined),
 *            valueInput:(string|undefined), implied:(boolean|undefined), config:(!wrm.data.Condition.Config|undefined)}} filterAtom
 * @return {!Object}
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterGenericTerm = function(filterAtom) {
  var result = {};
  result["property"] = this.getXDataPropertyPath(filterAtom.property);
  if (filterAtom.operator) {
    result["operator"] = wrm.data.XFilteredQuery._VALUE_OPERATOR_MAP[filterAtom.operator];
  }
  if (filterAtom.value !== undefined) {
    result["value"] = filterAtom.value;
  }
  if (filterAtom.valueInput) {
    result["valueInput"] = filterAtom.valueInput;
  }
  if (filterAtom.valueOp) {
    result["valueOperator"] = wrm.data.XFilteredQuery._COLLECTION_OPERATOR_MAP[filterAtom.valueOp];
  }
  if (filterAtom.implied !== undefined) {
    result["implied"] = filterAtom.implied;
  }
  if (filterAtom.config) {
    result["config"] = this._prepareXDataFilterConfig(filterAtom.config);
  }
  return result;
};
/**
 * @private
 * @param {string} filterAtomProperty
 * @return {string}
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterSingleEqualTerm = function(filterAtomProperty) {
  return this.getXDataPropertyPath(filterAtomProperty);
};

/**
 * @private
 * @param {!wrm.data.Condition.Config} filterConfig
 */
wrm.data.XFilteredQuery.prototype._prepareXDataFilterConfig = function(filterConfig) {
  return {"oneImpliedInputRequired":filterConfig.oneImpliedInputRequired};
};




//== wrm/data/XDeleteQuery.js =================================================



/**
 * @package
 * @constructor
 * @template B
 * @extends wrm.data.XFilteredQuery<B>
 * @implements wrm.data.DeleteQuery
 * @param {B} baseElement
 * @param {wrm.data.DeleteQuery.Options=} options
 */
wrm.data.XDeleteQuery = function(baseElement, options) {
  wrm.data.XFilteredQuery.call(this, baseElement);
  
  /** @private */
  this._xdataFilter = this._constructXDataFilter(options);
  
  /**
   * @private
   * @type {?xdata.DeleteQuery}
   */
  this._xdataQuery = null;
};

extendConstructor(wrm.data.XDeleteQuery, wrm.data.XFilteredQuery);
/**
 * @private
 * @param {wrm.data.DeleteQuery.Options|undefined} options
 * @return {?Object|string}
 */
wrm.data.XDeleteQuery.prototype._constructXDataFilter = function(options) {
  var filter = options && options.filter;
  if (!filter) {
    return null;
  }
  return this.prepareXDataFilterExpression(filter);
};

/*
 * Query-time
 */

/**
 * @package
 * @template R
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object|undefined} parameters
 * @param {function(!xdata.Transaction,!xdata.DeleteQuery,!Object=):!Promise<R>} executeCallback
 * @return {R}
 */
wrm.data.XDeleteQuery.prototype.executeXDataQuery = function(dataContext, parameters, executeCallback) {
  this.checkDataContext(dataContext);
  
  /* Retrieve or create the XData query */
  var query = this._xdataQuery;
  if (!query) {
    query = this._createXDataQuery(dataContext);
    this._xdataQuery = query;
  }
  
  this.configureXDataQuery(query, dataContext);
  
  /* Execute the query */
  var begunTx = false;
  var unq = parameters && parameters["useNewishQueries"];
  return Promise.resolve(wrm.data.DataContextHelper.getXDataTransactionNew(dataContext, unq)).then(function(tx) {
    if (!tx) {
      begunTx = true;
      return wrm.data.DataContextHelper.openXDataSession(dataContext).then(function(session) {
        return session.createTransaction();
      });
    }
    return tx;
  }).then(function(tx) {
    return executeCallback(tx, (query), parameters).then(function(result) {
      if (begunTx) {
        return tx.resolve().then(function() {
          return result;
        });
      }
      return result;
    });
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.DeleteQuery}
 */
wrm.data.XDeleteQuery.prototype._createXDataQuery = function(dataContext) {
  var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
  return db.prepareDelete(this.getXDataBaseElementName(), ({filter:(this._xdataFilter) || undefined}));
};




//== wrm/data/XAssocDeleteQuery.js ============================================


/**
 * @internal
 * @constructor
 * @extends wrm.data.XDeleteQuery<!wrm.data.meta.Association>
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} assocId
 * @param {wrm.data.DeleteQuery.Options=} options
 */
wrm.data.XAssocDeleteQuery = function(metadata, assocId, options) {
  wrm.data.XDeleteQuery.call(this, metadata.getAssociation(assocId), options);
};

extendConstructor(wrm.data.XAssocDeleteQuery, wrm.data.XDeleteQuery);

/** @override */
wrm.data.XAssocDeleteQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getAssociationXDataName(this.baseElement);
};

/** @override */
wrm.data.XAssocDeleteQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getAssociationXDataPropertyPath(this.baseElement, elementIdPath);
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<undefined>}
 */
wrm.data.XAssocDeleteQuery.prototype.execute = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.execute(tx, parameters);
  });
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XAssocDeleteQuery.prototype.executeGetChanged = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  });
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.XAssocDeleteQuery.prototype.executeGetCount = function(dataContext, parameters) {
  return Promise.reject(new Error("Execution with result count is not supported yet"));
};




//== wrm/data/XInsertQuery.js =================================================



wrm.data.XInsertQuery = function(baseElement, insert) {
  wrm.data.XQuery.call(this, baseElement);
  
  /** @private */
  this._inserts = this._constructInserts(insert);
  
  /**
   * @private
   * @type {!Object<string,!xdata.InsertQuery>}
   */
  this._xdataQueries = {};
};

extendConstructor(wrm.data.XInsertQuery, wrm.data.XQuery);
/**
 * @internal
 * @typedef {!Array<(function(!Object):!Object)|!Object> | (function(!Object):!Object) | !Object}
 */
wrm.data.XInsertQuery.Insert;

/**
 * @private
 * @param {wrm.data.XInsertQuery.Insert} insert
 * @return {!Array<(function(!Object):!Object)|!Object>}
 */
wrm.data.XInsertQuery.prototype._constructInserts = function(insert) {
  if (Array.isArray(insert)) {
    return insert.slice(0);
  }
  return [insert];
};

/*
 * Query-time
 */

/**
 * @package
 * @template R
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object|undefined} parameters
 * @param {function(!xdata.Transaction,!xdata.InsertQuery,!Object=):!Promise<R>} executeCallback
 * @return {!Promise<!Array<R>>}
 */
wrm.data.XInsertQuery.prototype.executeXDataQuery = function(dataContext, parameters, executeCallback) {
  this.checkDataContext(dataContext);
  
  /* Prepare actual inserted values by element ID */
  var insertElementIdsSet = {};
  var insertObjects = this._inserts.map(function(insert) {
    var insertValuesById;
    if (typeof insert === "function") {
      insertValuesById = insert(parameters);
    } else {
      insertValuesById = insert;
    }
    
    /* Keep track of all IDs (use native loop for performance) */
    var ids = Object.keys(insertValuesById);
    for (var i = 0;i < ids.length;i++) {
      insertElementIdsSet[ids[i]] = true;
    }
    
    return insertValuesById;
  });
  
  /* Retrieve or create the XData query */
  var insertElementIds = Object.keys(insertElementIdsSet);
  insertElementIds.sort();
  var cacheKey = this.baseElement.getId() + "_" + insertElementIds.join(",");
  var query = this._xdataQueries[cacheKey];
  if (!query) {
    query = this._createXDataQuery(insertElementIds, dataContext);
    this._xdataQueries[cacheKey] = query;
  }
  
  /* Execute the query once for each group of inserted values */
  var begunTx = false;
  var unq = parameters && parameters["useNewishQueries"];
  return Promise.resolve(wrm.data.DataContextHelper.getXDataTransactionNew(dataContext, unq)).then(function(tx) {
    if (!tx) {
      begunTx = true;
      return wrm.data.DataContextHelper.openXDataSession(dataContext).then(function(session) {
        return session.createTransaction();
      });
    }
    return tx;
  }).then(function(tx) {
    return Promise.all(insertObjects.map(function(insertObject) {
      return executeCallback(tx, query, insertObject);
    })).then(function(result) {
      if (begunTx) {
        return tx.resolve().then(function() {
          return result;
        });
      }
      return result;
    });
  });
};

/**
 * @private
 * @param {!Array<string>} insertElementIdPaths
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.InsertQuery}
 */
wrm.data.XInsertQuery.prototype._createXDataQuery = function(insertElementIdPaths, dataContext) {
  var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
  return db.prepareInsert(this.getXDataBaseElementName(), ({inserts:insertElementIdPaths.map(function(elementIdPath) {
    return {property:this.getXDataPropertyPath(elementIdPath), valueInput:elementIdPath};
  }, this)}));
};




//== wrm/data/XAssocInsertQuery.js ============================================


/**
 * @internal
 * @constructor
 * @extends wrm.data.XInsertQuery<!wrm.data.meta.Association>
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} assocId
 * @param {wrm.data.XInsertQuery.Insert} insert
 */
wrm.data.XAssocInsertQuery = function(metadata, assocId, insert) {
  wrm.data.XInsertQuery.call(this, metadata.getAssociation(assocId), insert);
};

extendConstructor(wrm.data.XAssocInsertQuery, wrm.data.XInsertQuery);

/** @override */
wrm.data.XAssocInsertQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getAssociationXDataName(this.baseElement);
};

/** @override */
wrm.data.XAssocInsertQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getAssociationXDataPropertyPath(this.baseElement, elementIdPath);
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XAssocInsertQuery.prototype.execute = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  }).then(function(changedFlags) {
    return changedFlags.indexOf(true) >= 0;
  });
};
/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XAssocInsertQuery.prototype.executeGetChanged = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  }).then(function(changedFlags) {
    return changedFlags.indexOf(true) >= 0;
  });
};




//== wrm/data/XSelectQuery.js =================================================



/**
 * @package
 * @constructor
 * @template B
 * @extends wrm.data.XFilteredQuery<B>
 * @implements wrm.data.SelectQuery
 * @param {B} baseElement
 * @param {wrm.data.SelectQuery.Options=} options
 */
wrm.data.XSelectQuery = function(baseElement, options) {
  wrm.data.XFilteredQuery.call(this, baseElement);
  
  /* Validate the output configuration */
  this._validateOutputConfig(options);
  
  /** @private */
  this._xdataDistinct = this._constructXDataDistinct(options);
  
  /** @private */
  this._xdataOutput = this._constructXDataOutput(options);
  
  /** @private */
  this._xdataFilter = this._constructXDataFilter(options);
  
  /** @private */
  this._xdataOrder = this._constructXDataOrder(options);
  
  /** @private */
  this._xdataLimit = this._constructXDataLimit(options);
  
  /**
   * @private
   * @type {?xdata.SelectQuery}
   */
  this._xdataQuery = null;
};

extendConstructor(wrm.data.XSelectQuery, wrm.data.XFilteredQuery);

/**
 * @private
 * @param {wrm.data.SelectQuery.Options|undefined} options
 */
wrm.data.XSelectQuery.prototype._validateOutputConfig = function(options) {
  var outputConfig = options && options.outputConfig;
  var useNames = outputConfig && outputConfig.useNames || false;
  
  /* The "use names" mode is currently the only supported, but it will not be the default in the future */
  if (!useNames) {
    throw new Error("The output must be configured to use names");
  }
};

/**
 * @private
 * @param {wrm.data.SelectQuery.Options|undefined} options
 * @return {?boolean}
 */
wrm.data.XSelectQuery.prototype._constructXDataDistinct = function(options) {
  var distinct = options && options.distinct;
  if (distinct === undefined) {
    return null;
  }
  return distinct;
};

/**
 * @private
 * @param {wrm.data.SelectQuery.Options|undefined} options
 * @return {?Object<string,string>|!Array<string>|string}
 */
wrm.data.XSelectQuery.prototype._constructXDataOutput = function(options) {
  var output = options && options.output;
  if (!output) {
    return null;
  }
  
  if (typeof output === "object") {
    
    /* Array with a list of id-paths: translate elements to XData paths */
    if (Array.isArray(output)) {
      return output.map(this.getXDataPropertyPath, this);
    }
    
    /* Object with (outputProperty: id-path) mappings: translate values to XData paths */
    var result = {};
    Object.keys(output).forEach(function(key) {
      result[key] = this.getXDataPropertyPath(output[key]);
    }, this);
    return result;
  }
  
  /* String id-path: translate to XData path */
  return this.getXDataPropertyPath(output);
};
/**
 * @private
 * @param {wrm.data.SelectQuery.Options|undefined} options
 * @return {?Object|string}
 */
wrm.data.XSelectQuery.prototype._constructXDataFilter = function(options) {
  var filter = options && options.filter;
  if (!filter) {
    return null;
  }
  return this.prepareXDataFilterExpression(filter);
};

/**
 * @private
 * @param {wrm.data.SelectQuery.Options|undefined} options
 * @return {?Array<{property:string,descending:boolean}|string>}
 */
wrm.data.XSelectQuery.prototype._constructXDataOrder = function(options) {
  var order = options && options.order;
  if (!order) {
    return null;
  }
  
  /* Normalize to always use an array */
  if (!Array.isArray(order)) {
    order = [order];
  }
  
  return order.map(function(term) {
    if (typeof term === "string") {
      
      /* Id-path: translate to XData path */
      return this.getXDataPropertyPath(term);
      
    } else {
      
      /* Object containing an id-path: translate that to an XData path */
      return {property:this.getXDataPropertyPath(term.property), descending:term.reverse};
      
    }
  }, this);
};

/**
 * @private
 * @param {wrm.data.SelectQuery.Options|undefined} options
 * @return {?{begin:number,count:number}|number}
 */
wrm.data.XSelectQuery.prototype._constructXDataLimit = function(options) {
  var limit = options && options.limit;
  if (!limit) {
    return null;
  }
  
  if (typeof limit === "number") {
    return limit;
  }
  return {begin:limit.begin, count:limit.count};
};

/*
 * Query-time
 */

/**
 * @package
 * @template R
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object|undefined} parameters
 * @param {function(!xdata.Transaction,!xdata.SelectQuery,!Object=):!Promise<R>} executeCallback
 * @return {R}
 */
wrm.data.XSelectQuery.prototype.executeXDataQuery = function(dataContext, parameters, executeCallback) {
  this.checkDataContext(dataContext);
  
  /* Retrieve or create the XData query */
  var query = this._xdataQuery;
  if (!query) {
    query = this._createXDataQuery(dataContext);
    this._xdataQuery = query;
  }
  
  /* Execute the query */
  var begunTx = false;
  var unq = parameters && parameters["useNewishQueries"];
  return Promise.resolve(wrm.data.DataContextHelper.getXDataTransactionNew(dataContext, unq)).then(function(tx) {
    if (!tx) {
      begunTx = true;
      return wrm.data.DataContextHelper.openXDataSession(dataContext).then(function(session) {
        return session.createTransaction();
      });
    }
    return tx;
  }).then(function(tx) {
    return executeCallback(tx, (query), parameters).then(function(result) {
      if (begunTx) {
        return tx.resolve().then(function() {
          return result;
        });
      }
      return result;
    });
  });
};

/**
 * @private
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.SelectQuery}
 */
wrm.data.XSelectQuery.prototype._createXDataQuery = function(dataContext) {
  var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
  return db.prepareSelect(this.getXDataBaseElementName(), ({distinct:this._xdataDistinct !== null ? this._xdataDistinct : undefined, output:this._xdataOutput || undefined, filter:(this._xdataFilter) || undefined, order:this._xdataOrder !== null ? this._xdataOrder : undefined, limit:this._xdataLimit !== null ? this._xdataLimit : undefined}));
};




//== wrm/data/XAssocSelectQuery.js ============================================


/**
 * @internal
 * @constructor
 * @extends wrm.data.XSelectQuery<!wrm.data.meta.Association>
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} assocId
 * @param {wrm.data.SelectQuery.Options=} options
 */
wrm.data.XAssocSelectQuery = function(metadata, assocId, options) {
  wrm.data.XSelectQuery.call(this, metadata.getAssociation(assocId), options);
};

extendConstructor(wrm.data.XAssocSelectQuery, wrm.data.XSelectQuery);

/** @override */
wrm.data.XAssocSelectQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getAssociationXDataName(this.baseElement);
};

/** @override */
wrm.data.XAssocSelectQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getAssociationXDataPropertyPath(this.baseElement, elementIdPath);
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.XAssocSelectQuery.prototype.query = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.queryAll(tx, parameters);
  });
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<?Object|*>}
 */
wrm.data.XAssocSelectQuery.prototype.queryOne = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.queryOne(tx, parameters);
  });
};




//== wrm/data/XUpdateQuery.js =================================================


/**
 * @internal
 * @constructor
 * @template B
 * @extends wrm.data.XFilteredQuery<B>
 * @param {B} baseElement
 * @param {wrm.data.XUpdateQuery.Options=} options
 */
wrm.data.XUpdateQuery = function(baseElement, options) {
  wrm.data.XFilteredQuery.call(this, baseElement);
  
  /** @private */
  this._update = this._constructUpdate(options);
  
  /** @private */
  this._xdataFilter = this._constructXDataFilter(options);
  
  /**
   * @private
   * @type {!Object<string,!xdata.UpdateQuery>}
   */
  this._xdataQueries = {};
};

extendConstructor(wrm.data.XUpdateQuery, wrm.data.XFilteredQuery);
/**
 * @internal
 * @typedef {{ update:((function(!Object):!Object)|!Object), filter:(!wrm.data.Condition.Expression|undefined) }}}
 */
wrm.data.XUpdateQuery.Options;

/**
 * @private
 * @param {wrm.data.XUpdateQuery.Options|undefined} options
 * @return {(function(!Object):!Object)|!Object}
 */
wrm.data.XUpdateQuery.prototype._constructUpdate = function(options) {
  var update = options && options.update;
  if (!update) {
    throw new Error("Update values not specified");
  }
  return update;
};
/**
 * @private
 * @param {wrm.data.XUpdateQuery.Options|undefined} options
 * @return {?Object|string}
 */
wrm.data.XUpdateQuery.prototype._constructXDataFilter = function(options) {
  var filter = options && options.filter;
  if (!filter) {
    return null;
  }
  return this.prepareXDataFilterExpression(filter);
};

/*
 * Query-time
 */

/**
 * @package
 * @template R
 * @const
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object|undefined} parameters
 * @param {function(!xdata.Transaction,!xdata.UpdateQuery,!Object=):!Promise<R>} executeCallback
 * @return {R}
 */
wrm.data.XUpdateQuery.prototype.executeXDataQuery = function(dataContext, parameters, executeCallback) {
  this.checkDataContext(dataContext);
  
  /* Prepare actual updated values by element ID */
  var updateObject;
  if (typeof this._update === "function") {
    updateObject = this._update(parameters);
  } else {
    updateObject = this._update;
  }
  
  /* Retrieve or create the XData query */
  var updateElementIds = Object.keys(updateObject);
  updateElementIds.sort();
  var cacheKey = this.baseElement.getId() + "_" + updateElementIds.join(",");
  var query = this._xdataQueries[cacheKey];
  if (!query) {
    query = this._createXDataQuery(updateElementIds, dataContext);
    this._xdataQueries[cacheKey] = query;
  }
  
  /* Integrate the update object values with the other parameters */
  var parametersWithUpdates = parameters ? Object.create(parameters) : {};
  updateElementIds.forEach(function(updateElementId) {
    parametersWithUpdates["_u_" + updateElementId] = updateObject[updateElementId];
  });
  
  /* Execute the query */
  var begunTx = false;
  var unq = parameters && parameters["useNewishQueries"];
  return Promise.resolve(wrm.data.DataContextHelper.getXDataTransactionNew(dataContext, unq)).then(function(tx) {
    if (!tx) {
      begunTx = true;
      return wrm.data.DataContextHelper.openXDataSession(dataContext).then(function(session) {
        return session.createTransaction();
      });
    }
    return tx;
  }).then(function(tx) {
    return executeCallback(tx, query, parametersWithUpdates).then(function(result) {
      if (begunTx) {
        return tx.resolve().then(function() {
          return result;
        });
      }
      return result;
    });
  });
};

/**
 * @private
 * @param {!Array<string>} updateElementIds
 * @param {!wrm.data.DataContext} dataContext
 * @return {!xdata.UpdateQuery}
 */
wrm.data.XUpdateQuery.prototype._createXDataQuery = function(updateElementIds, dataContext) {
  var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
  return db.prepareUpdate(this.getXDataBaseElementName(), ({updates:updateElementIds.map(function(elementIdPath) {
    return {property:this.getXDataPropertyPath(elementIdPath), valueInput:"_u_" + elementIdPath};
  }, this), filter:(this._xdataFilter) || undefined}));
};




//== wrm/data/XAssocUpdateQuery.js ============================================


/**
 * @internal
 * @constructor
 * @extends wrm.data.XUpdateQuery<!wrm.data.meta.Association>
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} assocId
 * @param {wrm.data.XUpdateQuery.Options=} options
 */
wrm.data.XAssocUpdateQuery = function(metadata, assocId, options) {
  wrm.data.XUpdateQuery.call(this, metadata.getAssociation(assocId), options);
};

extendConstructor(wrm.data.XAssocUpdateQuery, wrm.data.XUpdateQuery);

/** @override */
wrm.data.XAssocUpdateQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getAssociationXDataName(this.baseElement);
};

/** @override */
wrm.data.XAssocUpdateQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getAssociationXDataPropertyPath(this.baseElement, elementIdPath);
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XAssocUpdateQuery.prototype.execute = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  });
};
/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XAssocUpdateQuery.prototype.executeGetChanged = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  });
};




//== wrm/data/EntityDeleteQuery.js ============================================



/**
 * @interface
 * @extends wrm.data.DeleteQuery<!wrm.data.meta.Entity>
 */
wrm.data.EntityDeleteQuery = function() {
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise}
 */
wrm.data.EntityDeleteQuery.prototype.execute = function(dataContext, parameters) {
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.EntityDeleteQuery.prototype.executeGetChanged = function(dataContext, parameters) {
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.EntityDeleteQuery.prototype.executeGetCount = function(dataContext, parameters) {
};




//== wrm/data/XEntityDeleteQuery.js ===========================================



/**
 * @package
 * @constructor
 * @extends wrm.data.XDeleteQuery<!wrm.data.meta.Entity>
 * @implements wrm.data.EntityDeleteQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {wrm.data.DeleteQuery.Options=} options
 */
wrm.data.XEntityDeleteQuery = function(metadata, entityId, options) {
  wrm.data.XDeleteQuery.call(this, metadata.getEntity(entityId), options);
  
  /**
   * @private
   * @type {wrm.data.XDConfiguration}
   */
  this._casdcadeQueryLastConfig = null;
};

extendConstructor(wrm.data.XEntityDeleteQuery, wrm.data.XDeleteQuery);

/** @override */
wrm.data.XEntityDeleteQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getEntityXDataName(this.baseElement);
};

/** @override */
wrm.data.XEntityDeleteQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getEntityXDataPropertyPath(this.baseElement, elementIdPath);
};

/** @override */
wrm.data.XEntityDeleteQuery.prototype.execute = function(dataContext, parameters) {
  var thisQuery = this;
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return thisQuery._doQueryWithCascade(query, dataContext, tx, parameters).then(function(count) {
      return Promise.resolve();
    });
  });
};

/** @override */
wrm.data.XEntityDeleteQuery.prototype.executeGetChanged = function(dataContext, parameters) {
  var thisQuery = this;
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return thisQuery._doQueryWithCascade(query, dataContext, tx, parameters).then(function(count) {
      return Promise.resolve(count > 0);
    });
  });
};

/** @override */
wrm.data.XEntityDeleteQuery.prototype.executeGetCount = function(dataContext, parameters) {
  var thisQuery = this;
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return thisQuery._doQueryWithCascade(query, dataContext, tx, parameters);
  });
};

/**
 * @private
 * @param {!xdata.DeleteQuery} q
 * @param {!wrm.data.DataContext} dataContext
 * @param {!xdata.Transaction} tx
 * @param {!Object=} parameters
 * @return {!Promise<number>}
 */
wrm.data.XEntityDeleteQuery.prototype._doQueryWithCascade = function(q, dataContext, tx, parameters) {
  var $jscomp$this = this;
  var entity = this.getBaseElement();
  var cascadedRoles = [];
  
  /* For each association which is not a foreign key, perform a delete where the key value is within the list of deleted objects */
  entity.getRoles().forEach(function(role) {
    
    if (role.isForeignKey()) {
      /* Do nothing because the entities to which we should operate on are exactly those which have been deleted */
      return;
    }
    
    cascadedRoles.push(role);
  });
  
  /* Perform cascade delete */
  if (cascadedRoles.length > 0) {
    return q.executeGetKeys(tx, parameters).then(function(keys) {
      if (keys.length > 0) {
        return $jscomp$this._doCascade(entity, keys, cascadedRoles, dataContext, tx).then(function() {
          return keys.length;
        });
      }
      return 0;
    });
  }
  
  return q.executeGetCount(tx, parameters);
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {!xdata.List<*>} keys
 * @param {!Array<wrm.data.meta.Role>} cascadedRoles
 * @param {!wrm.data.DataContext} dataContext
 * @param {!xdata.Transaction} tx
 * @return {!Promise<!Array<?>>}
 */
wrm.data.XEntityDeleteQuery.prototype._doCascade = function(entity, keys, cascadedRoles, dataContext, tx) {
  var $jscomp$this = this;
  return Promise.all(cascadedRoles.map(function(role) {
    
    var assoc = role.getAssociation();
    
    /* Prepare references to all attributes */
    var assocId = assoc.getId();
    var entity1 = assoc.getEntity1();
    var entity2 = assoc.getEntity2();
    var keyRef1 = assoc.getRole1().getId() + "." + entity1.getKeyAttribute().getName();
    var keyRef2 = assoc.getRole2().getId() + "." + entity2.getKeyAttribute().getName();
    var property = assoc.getRole1().getId() === role.getId() ? keyRef1 : keyRef2;
    var propertyValues = [];
    (keys).map(function(key) {
      if (typeof key === "object") {
        if (key.hasOwnPropery(property)) {
          /* 'key' is an object having a property named 'property' */
          propertyValues.push(key[property]);
        } else {
        }
      } else {
        if (typeof key === "number") {
          /* 'key' is simple number */
          propertyValues.push(key);
        }
      }
    });
    
    var db = wrm.data.DataContextHelper.getXDataDatabase(dataContext);
    var cascadeQuery = db.prepareDelete(assocId, ({filter:{property:property, operator:"in", value:propertyValues}}));
    
    var config = dataContext.getQueryConfiguration();
    if (config !== $jscomp$this._casdcadeQueryLastConfig) {
      config.configureQuery(cascadeQuery, assoc);
      $jscomp$this._casdcadeQueryLastConfig = config;
    }
    
    return cascadeQuery.executeGetKeys(tx, {});
  }));
};




//== wrm/data/XEntityInsertQuery.js ===========================================


/**
 * @internal
 * @constructor
 * @extends wrm.data.XInsertQuery<!wrm.data.meta.Entity>
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {wrm.data.XInsertQuery.Insert} insert
 */
wrm.data.XEntityInsertQuery = function(metadata, entityId, insert) {
  wrm.data.XInsertQuery.call(this, metadata.getEntity(entityId), insert);
};

extendConstructor(wrm.data.XEntityInsertQuery, wrm.data.XInsertQuery);

/** @override */
wrm.data.XEntityInsertQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getEntityXDataName(this.baseElement);
};

/** @override */
wrm.data.XEntityInsertQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getEntityXDataPropertyPath(this.baseElement, elementIdPath);
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.XEntityInsertQuery.prototype.execute = function(dataContext, parameters) {
  return Promise.reject(new Error("Execution with result keys is not supported yet"));
};
/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XEntityInsertQuery.prototype.executeGetChanged = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  }).then(function(changedFlags) {
    return changedFlags.indexOf(true) >= 0;
  });
};




//== wrm/data/EntitySelectQuery.js ============================================



/**
 * @interface
 * @extends wrm.data.SelectQuery<!wrm.data.meta.Entity>
 */
wrm.data.EntitySelectQuery = function() {
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!Object|*>>}
 */
wrm.data.EntitySelectQuery.prototype.query = function(dataContext, parameters) {
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<?Object|*>}
 */
wrm.data.EntitySelectQuery.prototype.queryOne = function(dataContext, parameters) {
};




//== wrm/data/XEntitySelectQuery.js ===========================================



/**
 * @package
 * @constructor
 * @extends wrm.data.XSelectQuery<!wrm.data.meta.Entity>
 * @implements wrm.data.EntitySelectQuery
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {wrm.data.SelectQuery.Options=} options
 */
wrm.data.XEntitySelectQuery = function(metadata, entityId, options) {
  wrm.data.XSelectQuery.call(this, metadata.getEntity(entityId), options);
};

extendConstructor(wrm.data.XEntitySelectQuery, wrm.data.XSelectQuery);

/** @override */
wrm.data.XEntitySelectQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getEntityXDataName(this.baseElement);
};

/** @override */
wrm.data.XEntitySelectQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getEntityXDataPropertyPath(this.baseElement, elementIdPath);
};

/** @override */
wrm.data.XEntitySelectQuery.prototype.query = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.queryAll(tx, parameters);
  });
};

/** @override */
wrm.data.XEntitySelectQuery.prototype.queryOne = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.queryOne(tx, parameters);
  });
};




//== wrm/data/XEntityUpdateQuery.js ===========================================


/**
 * @internal
 * @constructor
 * @extends wrm.data.XUpdateQuery<!wrm.data.meta.Entity>
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {string} entityId
 * @param {wrm.data.XUpdateQuery.Options=} options
 */
wrm.data.XEntityUpdateQuery = function(metadata, entityId, options) {
  wrm.data.XUpdateQuery.call(this, metadata.getEntity(entityId), options);
};

extendConstructor(wrm.data.XEntityUpdateQuery, wrm.data.XUpdateQuery);

/** @override */
wrm.data.XEntityUpdateQuery.prototype.getXDataBaseElementName = function() {
  return wrm.data.XQuery.getEntityXDataName(this.baseElement);
};

/** @override */
wrm.data.XEntityUpdateQuery.prototype.getXDataPropertyPath = function(elementIdPath) {
  return wrm.data.XQuery.getEntityXDataPropertyPath(this.baseElement, elementIdPath);
};

/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<!Array<!*>>}
 */
wrm.data.XEntityUpdateQuery.prototype.execute = function(dataContext, parameters) {
  return Promise.reject(new Error("Execution with result keys is not supported yet"));
};
/**
 * @param {!wrm.data.DataContext} dataContext
 * @param {!Object=} parameters
 * @return {!Promise<boolean>}
 */
wrm.data.XEntityUpdateQuery.prototype.executeGetChanged = function(dataContext, parameters) {
  return this.executeXDataQuery(dataContext, parameters, function(tx, query, parameters) {
    return query.executeGetChanged(tx, parameters);
  });
};




//== wrm/util/ObjectPool.js ===================================================


/**
 * @constructor
 * @template T
 * @param {(function():Promise.<!T>)|function():!T} factoryFunction
 * @param {function(T)=} destroyFunction
 * @param {{lifetime:(number|undefined)}=} options
 */
wrm.util.ObjectPool = function(factoryFunction, destroyFunction, options) {
  
  /** @private */
  this._factoryFunction = factoryFunction;
  
  /** @private */
  this._destroyFunction = destroyFunction || angular.noop;
  
  /** @private */
  this._lifetime = options && options.lifetime || wrm.util.ObjectPool.DEFAULT_LIFETIME;
  
  /**
   * @private
   * @type {!Array.<{object:!T, destroyTimeout:number}>}
   */
  this._free = [];
};

/**
 * @const
 */
wrm.util.ObjectPool.DEFAULT_LIFETIME = 3E4;

/**
 * @return {!Promise.<!T>}
 */
wrm.util.ObjectPool.prototype.acquire = function() {
  
  /* Reuse an object if possible */
  if (this._free.length > 0) {
    var item = this._free.shift();
    clearTimeout(item.destroyTimeout);
    return Promise.resolve(item.object);
  }
  
  /* Create a new object */
  return Promise.resolve(this._factoryFunction());
};

/**
 * @param {T} object
 */
wrm.util.ObjectPool.prototype.release = function(object) {
  var thisPool = this;
  
  if (!object) {
    return;
  }
  
  /* Save in list and start a timer for destruction */
  var destroyTimeout = setTimeout(function() {
    thisPool._destroyObject(object);
  }, this._lifetime);
  this._free.push({object:object, destroyTimeout:destroyTimeout});
};

/**
 * @private
 * @param {!T} object
 */
wrm.util.ObjectPool.prototype._destroyObject = function(object) {
  for (var i = 0;i < this._free.length;i++) {
    var item = this._free[i];
    if (item.object === object) {
      this._free.splice(i, 1);
      this._destroyFunction(object);
      return;
    }
  }
};




//== wrm/data/DataService.js ==================================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.data.DataRunner
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.data.DataService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /**
   * @private
   * @type {string}
   */
  this._entityContextName = this.getDescriptorValue(descr, "contextName");
  
  /** @private */
  this._entityDisabledDataRestore = wrm.util.obj.createFromKeys(descr["dataRestoreDisabled"], true);
  
  /* Gather information required for handling the database */
  var databaseName = this.getDescriptorValue(descr, "databaseName");
  var currentMetadata = new wrm.data.meta.Metadata(descr["metadata"] || {});
  
  /** @private */
  this._dbHandler = new wrm.data.DatabaseHandler(databaseName, currentMetadata, manager.getPlatform(), this.getLog());
  
  /* Intercept unstable uses and handle them centrally */
  this._dbHandler.setUnstableUseHandler(function(requestorDataService) {
    requestorDataService.handleUnstableUse();
  });
  
  /* Handle data migration using this Data Service in its current state */
  this._dbHandler.setMigrationHandler(this._migrateData.bind(this));
  
  /*
   * UNSTABLE STATE tied to the database handler: each of the following state variables is initialized on the first database handler
   * change and re-initialized on each subsequent change.
   */    /**
   * @protected
   * @type {!wrm.util.ObjectPool<!$data.EntityContext>}
   */
  this.entityContextPool;
  
  /**
   * @private
   * @type {boolean}
   */
  this._connectionTested;
  
  /**
   * @private
   * @type {!wrm.data.Purger}
   */
  this._purger;
  
  /* Stability control */
  
  /** @private */
  this._stable = false;
  
  /** @private */
  this._unstableInstance = new wrm.core.VolatileHolder(this);
  
  /* Respond to changes in the database handler */
  this._dbHandler.addStabilityListener(function(lastChange) {
    this.entityContextPool = wrm.data.DataService.createEntityContextPool(this);
    this._connectionTested = false;
    this._purger = new wrm.data.Purger;
    this._stable = lastChange;
    this._unstableInstance.swap(lastChange ? null : new wrm.data.UnstableDataService(this));
  }.bind(this));
};

/**
 * @protected
 * @param {!wrm.data.DataService} dataService
 * @return {!wrm.util.ObjectPool<!$data.EntityContext>}
 */
wrm.data.DataService.createEntityContextPool = function(dataService) {
  return new wrm.util.ObjectPool(dataService._createEntityContext.bind(dataService));
};

extendConstructor(wrm.data.DataService, wrm.core.AbstractService);

/** @override */
wrm.data.DataService.prototype.initialize = function() {
  var thisService = this;
  var manager = this.getManager();
  
  return Promise.all([manager.getUpdateService().then(function(updateService) {
    updateService.registerParticipant(wrm.data.DataService.UPDATE_ID, thisService._dbHandler);
  })]);
};

/**
 * @const
 * @type {string}
 */
wrm.data.DataService.ID = "_data";

/**
 * @const
 * @type {string}
 */
wrm.data.DataService.UPDATE_ID = "data";

/*
 * Stability control
 */

/**
 * @protected
 * @return {undefined}
 */
wrm.data.DataService.prototype.handleUnstableUse = function() {
  throw new Error("The Data Service is not stable");
};

/**
 * @internal
 * @param {function(!wrm.data.DataService,boolean)} callback
 */
wrm.data.DataService.prototype.useUnstable = function(callback) {
  this._unstableInstance.use(callback);
};

/*
 * Metadata-related information
 */

/**
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.DataService.prototype.getMetadata = function() {
  return this._dbHandler.getMetadata(this);
};

/**
 * @param {!Array<!Object>|!Object} object
 * @param {string} entityId
 * @param {!Array<string>|string=} propertyIds
 * @return {!Object}
 */
wrm.data.DataService.prototype.extractPropertyValuesByName = function(object, entityId, propertyIds) {
  return this._extractPropertyValues(object, entityId, propertyIds, false);
};

/**
 * @param {!Array<!Object>|!Object} object
 * @param {string} entityId
 * @param {!Array<string>|string=} propertyIds
 * @return {!Object}
 */
wrm.data.DataService.prototype.extractPropertyValuesById = function(object, entityId, propertyIds) {
  return this._extractPropertyValues(object, entityId, propertyIds, true);
};

/**
 * @private
 * @param {!Array<!Object>|!Object} object
 * @param {string} entityId
 * @param {!Array<string>|string|undefined} propertyIds
 * @param {boolean} retrieveById
 * @return {!Object}
 */
wrm.data.DataService.prototype._extractPropertyValues = function(object, entityId, propertyIds, retrieveById) {
  if (angular.isArray(object) && object.length <= 0) {
    return {};
  }
  
  if (typeof propertyIds === "string") {
    propertyIds = [propertyIds];
  }
  
  /* Determine the properties to extract and the source names to look for in objects */
  var propertiesBySourceKey = {};
  var entity = this.getMetadata().getEntity(entityId);
  if (propertyIds) {
    propertyIds.forEach(function(id) {
      var property = entity.getProperty(id);
      var sourceKey = retrieveById ? property.getId() : property.getName();
      propertiesBySourceKey[sourceKey] = property;
    });
  } else {
    entity.getProperties().forEach(function(property) {
      var sourceKey = retrieveById ? property.getId() : property.getName();
      propertiesBySourceKey[sourceKey] = property;
    });
  }
  
  /* Extract property values and put them in a result object by source key */
  var sourceKeys = Object.keys(propertiesBySourceKey);
  var valuesBySourceKey = wrm.util.obj.extractPropertyValues(object, sourceKeys);
  
  /* Put collected values in a result object by id */
  var result = {};
  sourceKeys.forEach(function(sourceKey) {
    var property = propertiesBySourceKey[sourceKey];
    if (valuesBySourceKey.hasOwnProperty(sourceKey)) {
      result[property.getId()] = valuesBySourceKey[sourceKey];
    }
  });
  
  return result;
};

/*
 * Query factory // TODO move all this to a wrm.data.DefaultQueryFactory object (beware of stability of metadata!)
 */

/** @override */
wrm.data.DataService.prototype.prepareSelect = function(entityId, options) {
  return new wrm.data.XEntitySelectQuery(this.getMetadata(), entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.DataService.prototype.prepareOldSelect = function(entityId, options) {
  return new wrm.data.JSelectQuery(this.getMetadata(), entityId, options);
};

/** @override */
wrm.data.DataService.prototype.prepareInsert = function(entityId, insert) {
  return new wrm.data.InsertQuery(this.getMetadata(), entityId, insert);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @return {!wrm.data.XEntityInsertQuery}
 */
wrm.data.DataService.prototype.prepareNewInsert = function(entityId, insert) {
  return new wrm.data.XEntityInsertQuery(this.getMetadata(), entityId, insert);
};

/** @override */
wrm.data.DataService.prototype.prepareUpdate = function(entityId, options) {
  return new wrm.data.UpdateQuery(this.getMetadata(), entityId, options);
};
/**
 * @internal
 * @param {string} entityId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @return {!wrm.data.XUpdateQuery}
 */
wrm.data.DataService.prototype.prepareNewUpdate = function(entityId, options) {
  return new wrm.data.XEntityUpdateQuery(this.getMetadata(), entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.DataService.prototype.prepareOldDelete = function(entityId, options) {
  return new wrm.data.JDeleteQuery(this.getMetadata(), entityId, options);
};

/** @override */
wrm.data.DataService.prototype.prepareDelete = function(entityId, options) {
  return new wrm.data.XEntityDeleteQuery(this.getMetadata(), entityId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.SelectQuery.Options=} options
 * @return {!wrm.data.XAssocSelectQuery}
 */
wrm.data.DataService.prototype.prepareNewAssociationSelect = function(assocId, options) {
  return new wrm.data.XAssocSelectQuery(this.getMetadata(), assocId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XInsertQuery.Insert} insert
 * @return {!wrm.data.XAssocInsertQuery}
 */
wrm.data.DataService.prototype.prepareNewAssociationInsert = function(assocId, insert) {
  return new wrm.data.XAssocInsertQuery(this.getMetadata(), assocId, insert);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.XUpdateQuery.Options=} options
 * @return {!wrm.data.XAssocUpdateQuery}
 */
wrm.data.DataService.prototype.prepareNewAssociationUpdate = function(assocId, options) {
  return new wrm.data.XAssocUpdateQuery(this.getMetadata(), assocId, options);
};
/**
 * @internal
 * @param {string} assocId
 * @param {!wrm.data.DeleteQuery.Options=} options
 * @return {!wrm.data.XAssocDeleteQuery}
 */
wrm.data.DataService.prototype.prepareNewAssociationDelete = function(assocId, options) {
  return new wrm.data.XAssocDeleteQuery(this.getMetadata(), assocId, options);
};

/**
 * @override
 * @deprecated
 */
wrm.data.DataService.prototype.prepareCondition = function(entityId, expression) {
  return new wrm.data.Condition(this.getMetadata(), entityId, expression);
};

/*
 * Database access
 */

/** @override */
wrm.data.DataService.prototype.execute = function(callback, inTransaction) {
  var thisDataService = this;
  var manager = this.getManager();
  
  /*
   * Prepare a data context, then execute the callback operations on it. The data tracker service, which is also required, MUST be
   * obtained here via a promise, because loading it at construction time would create a dependency loop with that service.
   */
  var entityContextPool = this.entityContextPool;
  return entityContextPool.acquire().then(function(entityContext) {
    return new Promise(function(resolve, reject) {
      entityContext["_wr_txErrorHandlers"] = wrm.util.toErrorReject(reject);
      
      var callbackPromise = manager.getDataTrackerService().then(function(dataTrackerService) {
        var txPromise = inTransaction ? entityContext.beginTransaction(true, function(tx) {
          tx["keepAlive"](300, 500);
        }) : Promise.resolve(null);
        return txPromise.then(function(tx) {
          var dataContext = new wrm.data.JDDataContext(entityContext, tx, dataTrackerService, thisDataService);
          return Promise.resolve(callback(dataContext)).finally(function() {
            if (tx) {
              tx["release"]();
            }
          });
        });
      });
      
      /* Release the context in all cases */
      return callbackPromise.then(resolve, reject).finally(function() {
        entityContext["_wr_txErrorHandlers"] = null;
        entityContextPool.release(entityContext);
      });
    });
  });
};

/**
 * @private
 * @return {!Promise<!$data.EntityContext>}
 */
wrm.data.DataService.prototype._createEntityContext = function() {
  var thisDataService = this;
  var databaseName = this._dbHandler.getConcreteDatabaseName(this);
  var entityContextName = this._entityContextName;
  
  return Promise.resolve().then(function() {
    
    /* Perform a test connection WITH XDATA at least once */
    if (!this._connectionTested) {
      return this._dbHandler.getDatabase(this).createSession(databaseName, ({autoCreate:false})).then(function() {
        this._connectionTested = true;
      }.bind(this));
    }
  }.bind(this)).then(function() {
    
    /* Locate the context constructor */
    var ctor = GLOBAL[entityContextName];
    if (typeof ctor !== "function") {
      throw new Error("Entity context '" + entityContextName + "' not found");
    }
    
    /* Construct the context */
    var context = newObject(ctor.prototype);
    ctor.call(context, {provider:"sqLite", databaseName:databaseName, dbCreation:$data["storageProviders"]["DbCreationType"]["AssumeUnchanged"]});
    context["_wr_databaseName"] = databaseName;
    
    /* The context is ready only when its 'onReady' event fires; return a promise for that */
    return new Promise(function(resolve, reject) {
      context.onReady(function() {
        thisDataService._patchEntityContext((context));
        resolve(context);
      })["catch"](wrm.util.toErrorReject(reject));
    });
  });
};

/**
 * @private
 * @param {!$data.EntityContext} context
 */
wrm.data.DataService.prototype._patchEntityContext = function(context) {
  var log = this.getLog();
  
  /*
   * Add error-capturing logic to all transactions created in the context This includes both transactions created explicitly by the
   * WebRatio Runtime and transactions created internally in "auto-commit" mode.
   */
  context.beginTransaction = function(orig) {
    return function() {
      var args = [];
      var callback;
      for (var i = 0;i < 3;i++) {
        if (typeof arguments[i] === "function") {
          callback = arguments[i];
          args[i] = function(tx) {
            captureTxErrors(tx);
            return callback.apply(this, arguments);
          };
        } else {
          args[i] = arguments[i];
        }
      }
      if (callback) {
        return orig.apply(this, args);
      }
      return orig.apply(this, arguments).then(function(tx) {
        captureTxErrors(tx);
        return tx;
      });
    };
  }(context.beginTransaction);
  
  /* Make a transaction created by the context relay its errors to a callback on the context */
  function captureTxErrors(tx) {
    tx.onerror.attach(function(tx, e) {
      var handler = context["_wr_txErrorHandlers"];
      if (handler) {
        handler(e);
      } else {
        log.error("Unhandled transaction error", e);
      }
    });
  }
};

/**
 * @return {!wrm.data.Purger}
 */
wrm.data.DataService.prototype.getPurger = function() {
  if (!this._stable) {
    this.handleUnstableUse();
  }
  return this._purger;
};
/**
 * @package
 * @return {!xdata.Database}
 */
wrm.data.DataService.prototype.getXDataDatabase = function() {
  return this._dbHandler.getDatabase(this);
};

/**
 * @private
 * @param {!wrm.data.meta.MetadataDiff} metadataDiff
 * @return {!Promise}
 */
wrm.data.DataService.prototype._migrateData = function(metadataDiff) {
  var manager = this.getManager();
  
  /* Migrate using the internal logic on an unstable data service */
  var migrator = new wrm.data.DataMigrator(this.getLog());
  var unstableDataService = new wrm.data.UnstableDataService(this);
  return unstableDataService.execute(function(dataContext) {
    return migrator.migrate(metadataDiff, dataContext);
  }, true).then(function() {
    unstableDataService.invalidate();
  }).then(function() {
    
    /* Call the custom data migration hook */
    var migrationHook = wrm.util.obj.lookup("wrxHookAfterDataMigration");
    if (typeof migrationHook === "function") {
      return (migrationHook)(manager);
    }
  });
};

/*
 * Non-database storage
 */

/**
 * @return {!wrm.data.Dictionary}
 */
wrm.data.DataService.prototype.getAuxiliaryDictionary = function() {
  return this._dbHandler.getAuxiliaryDictionary();
};

/*
 * Initial data (TODO partly the same logic of AppStartupHandler, centralize!)
 */

/**
 * @return {!Promise}
 */
wrm.data.DataService.prototype.restoreInitialData = function() {
  var thisService = this;
  var manager = this.getManager();
  var metadata = this.getMetadata();
  var ignoredEntityIds = this._entityDisabledDataRestore;
  
  /* First clear the outgoing changes, in order to avoid inconsistency state */
  return manager.getDataSyncService().then(function(dataSyncService) {
    return dataSyncService.clearOutgoingChanges();
  }).then(function() {
    
    /* Then clear the database */
    return thisService.execute(function(d) {
      return metadata.getEntities().reduce(function(chain, entity) {
        var entityId = entity.getId();
        
        /* if it's auxiliary or is server-mapped-entity or is user-entity or is role-entity move to next */
        if (entity instanceof wrm.data.meta.AuxEntity || entity.getServerName() || entityId === wrm.Constants.USER_ENT_ID || entityId === wrm.Constants.ROLE_ENT_ID || ignoredEntityIds[entityId]) {
          return chain;
        }
        
        /* if it's bridge between server-mapped-entities move to next */
        if (entity instanceof wrm.data.meta.BridgeEntity && entity.getRole1().getInverseEntity().getServerName() && entity.getRole2().getInverseEntity().getServerName()) {
          return chain;
        }
        return chain.then(function() {
          return d["delete"](entityId, {}, {});
        });
      }, Promise.resolve());
    });
  }).then(function() {
    
    /* Retrieve initial data */
    return manager.getConfigurationObject("initialData");
  }).then(function(data) {
    
    /* Restore initial data */
    return thisService._insertInitialData(data);
  });
};

/**
 * @private
 * @param {!Object} data
 * @return {!Promise}
 */
wrm.data.DataService.prototype._insertInitialData = function(data) {
  var metadata = this.getMetadata();
  var ignoredEntityIds = this._entityDisabledDataRestore;
  return this.execute(function(d) {
    
    /* Populate (sequentially) all entities for which data is available */
    return metadata.getEntities().reduce(function(chain, entity) {
      if (entity.getServerName()) {
        return chain;
      }
      var records = data[entity.getName()];
      if (!records) {
        return chain;
      }
      
      if (ignoredEntityIds[entity.getId()]) {
        return chain;
      }
      
      /* Transform records into valid insert objects */
      var properties = entity.getProperties();
      var insertObjects = records.map(function(record) {
        var obj = {};
        properties.forEach(function(property) {
          var value = record[property.getName()];
          if (value !== undefined) {
            obj[property.getId()] = value;
          }
        });
        return obj;
      });
      
      return chain.then(function() {
        return d.insert(entity.getId(), insertObjects);
      });
    }, Promise.resolve());
  });
};




//== wrm/l10n/LocalizationService.js ==========================================

wrm.l10n = {};


/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.l10n.LocalizationService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /** @private */
  this._defaultLocale = this.getDescriptorValue(descr, "defaultLocale");
  this._parseLocale(this._defaultLocale);
  
  /** @private */
  this._localePrefs = this._createLocalePrefs(descr["locales"]);
  
  /**
   * @private
   * @type {string}
   */
  this._currentLocale;
  
  /**
   * @private
   * @type {string}
   */
  this._currentResourcesLocale;
  
  /* Locale-specific */
  
  /**
   * @private
   * @type {!Object<string,string>}
   */
  this._resources;
  
  /**
   * @private
   * @type {!Object<wrm.data.Type,string>}
   */
  this._patterns;
};

extendConstructor(wrm.l10n.LocalizationService, wrm.core.AbstractService);

/**
 * @const
 * @type {string}
 */
wrm.l10n.LocalizationService.ID = "_l10n";

/**
 * @private
 * @typedef {{patterns:!Object<wrm.data.Type,string>}}
 */
wrm.l10n.LocalizationService._LocalePrefs;

/**
 * @private
 * @param {!Object} descr
 * @return {!Object<string,wrm.l10n.LocalizationService._LocalePrefs>}
 */
wrm.l10n.LocalizationService.prototype._createLocalePrefs = function(descr) {
  var localePrefs = {};
  
  Object.keys(descr).forEach(function(locale) {
    var prefs = {};
    prefs.patterns = descr[locale]["patterns"];
    localePrefs[locale] = prefs;
  });
  
  return localePrefs;
};

/**
 * @private
 * @param {string} localeId
 * @return {{language:string, country:?string}}
 */
wrm.l10n.LocalizationService.prototype._parseLocale = function(localeId) {
  var m = /^([a-z]{2})(?:[_\-]([A-Z]{2}))?$/i.exec(localeId);
  if (!m) {
    throw new Error("Invalid locale: " + localeId);
  }
  return {language:m[1].toLowerCase(), country:m[2] ? m[2].toUpperCase() : null};
};

/**
 * @return {!Promise<boolean>}
 */
wrm.l10n.LocalizationService.prototype.refreshLocale = function() {
  var thisService = this;
  var platform = this.getManager().getPlatform();
  
  /* Determine the new current locale: exit if unchanged */
  var newCurrentLocale = platform.getCurrentLocale();
  if (newCurrentLocale === this._currentLocale) {
    return Promise.resolve(false);
  }
  this._currentLocale = newCurrentLocale;
  
  /* Reload locale-related information */
  return Promise.resolve().then(function() {
    return thisService._reloadResources();
  }).then(function() {
    thisService._reloadPatterns();
    
    /* Sets current locale language and country to be used in bindings */
    var localeParts = thisService._parseLocale(thisService._currentResourcesLocale);
    wrm.nav.SystemValues.languageIsoCode = localeParts.language;
    if (localeParts.country) {
      wrm.nav.SystemValues.countryIsoCode = localeParts.country;
    } else {
      wrm.nav.SystemValues.countryIsoCode = null;
    }
    
    return true;
  });
};

/**
 * @private
 * @return {!Promise}
 */
wrm.l10n.LocalizationService.prototype._reloadResources = function() {
  var thisService = this;
  var manager = this.getManager();
  var localeParts = this._parseLocale(this._currentLocale);
  
  var resources = null;
  var resourcesLocale = null;
  
  /* Try all resource configuration objects from most specific up to the default */
  var suffixes = [];
  if (localeParts.country) {
    suffixes.push(localeParts.language + "_" + localeParts.country);
  }
  suffixes.push(localeParts.language);
  suffixes.push(this._defaultLocale);
  return suffixes.reduce(function(chain, suffix) {
    return chain.then(function() {
      if (resources) {
        return null;
      }
      return manager.getOptionalConfigurationObject("resources_" + suffix);
    }).then(function(foundResources) {
      if (foundResources) {
        resources = foundResources;
        resourcesLocale = suffix;
      }
    });
  }, Promise.resolve()).then(function() {
    if (resources) {
      thisService._resources = resources;
      thisService._currentResourcesLocale = resourcesLocale;
    } else {
      thisService._resources = {};
      thisService._currentResourcesLocale = thisService._currentLocale;
      throw new Error("Resources not found for locale");
    }
  });
};

/**
 * @private
 * @return {undefined}
 */
wrm.l10n.LocalizationService.prototype._reloadPatterns = function() {
  var localeParts = this._parseLocale(this._currentLocale);
  
  /* Try preferences for the specific locale or for more generic ones */
  var prefs = null;
  if (localeParts.country) {
    prefs = this._localePrefs[localeParts.language + "_" + localeParts.country] || null;
  }
  if (!prefs) {
    prefs = this._localePrefs[localeParts.language] || null;
  }
  
  /* If not found, use NO PREFERENCES as default, leaving everything up to the platform */
  if (!prefs) {
    prefs = {patterns:{}};
  }
  
  this._patterns = prefs.patterns;
  
  /* Add the special message keys for boolean true/false values */
  var booleanPattern = this._patterns[wrm.data.Type.BOOLEAN] || "\u2713|\u2715";
  if (booleanPattern) {
    var booleanMessages = booleanPattern.split("|", 2);
    this._resources["boolean.yes"] = booleanMessages[0];
    this._resources["boolean.no"] = booleanMessages[1];
  }
};

/*
 * Current locale information
 */

/**
 * @return {string}
 */
wrm.l10n.LocalizationService.prototype.getCurrentLocale = function() {
  if (DEBUG && !this._currentLocale) {
    throw new Error("Current locale not available");
  }
  return this._currentLocale;
};

/**
 * @return {!wrm.l10n.LocaleInfo}
 */
wrm.l10n.LocalizationService.prototype.getCurrentLocaleInfo = function() {
  return this.getManager().getPlatform().getCurrentLocaleInfo();
};

/**
 * @param {!wrm.data.Type} type
 * @return {?string}
 */
wrm.l10n.LocalizationService.prototype.getPreferredTypePattern = function(type) {
  if (DEBUG && !this._patterns) {
    throw new Error("Preferred patterns not available");
  }
  return this._patterns[type] || null;
};

/**
 * @param {string} key
 * @param {!Object=} variables
 * @return {string}
 */
wrm.l10n.LocalizationService.prototype.formatMessage = function(key, variables) {
  if (DEBUG && !this._resources) {
    throw new Error("Resources not available");
  }
  
  /* Retrieve the localized message */
  if (!this._resources.hasOwnProperty(key)) {
    return key;
  }
  var message = this._resources[key];
  
  /* Replace variables */
  if (variables) {
    message = message.replace(/\$\{([^}]+)\}/g, function(match, propertyName) {
      var value = variables[propertyName];
      if (value !== undefined) {
        return value;
      }
      return match;
    });
  }
  
  return message;
};




//== wrm/core/Manager.js ======================================================



/**
 * @constructor
 * @param {!wrm.core.DescriptorLoader} loader
 * @param {!wrm.Platform} platform
 */
wrm.core.Manager = function(loader, platform) {
  
  /** @private */
  this._loader = loader;
  
  /** @private */
  this._platform = platform;
  
  /** @private {?Promise<!Object<string,string>>} */
  this._variableProperties = null;
  
  /**
   * @private
   * @type {!Object<string,!Promise<{main:!wrm.Service, sub:!Object<string,!wrm.SubService>}>>}
   */
  this._serviceInstances = {};
  
  /** @private */
  this._log = platform.createLog("wrm.core.Manager");
  
  /* Log an initial message */
  this._log.info("WebRatio Mobile Runtime", wrm.VERSION, "started on", platform.getWebEngineType());
};
/**
 * @return {!Promise<!wrm.nav.Navigable>}
 */
wrm.core.Manager.prototype.getNavigable = function(serviceId) {
  return this.getService(serviceId).then(function(service) {
    
    /* Wrap throwers inside an navigable adapter */
    if (implementsInterface(service, wrm.ThrowerService)) {
      return new wrm.core.NavigableThrower((service));
    } else {
      return (service);
    }
  });
};
/**
 * @return {!Promise<!wrm.nav.Notifiable>}
 */
wrm.core.Manager.prototype.getNotifiable = function(serviceId) {
  return (this.getService(serviceId));
};

/**
 * @return {!wrm.Platform}
 */
wrm.core.Manager.prototype.getPlatform = function() {
  return this._platform;
};

/**
 * @return {!Promise<!wrm.core.UpdateService>}
 */
wrm.core.Manager.prototype.getUpdateService = function() {
  return (this.getService(wrm.core.UpdateService.ID));
};

/**
 * @return {!Promise<!wrm.core.BackEndService>}
 */
wrm.core.Manager.prototype.getBackEndService = function() {
  return (this.getService(wrm.core.BackEndService.ID));
};

/**
 * @return {!Promise<!wrm.data.DataService>}
 */
wrm.core.Manager.prototype.getDataService = function() {
  return (this.getService(wrm.data.DataService.ID));
};

/**
 * @return {!Promise<!wrm.data.sync.DataSyncService>}
 */
wrm.core.Manager.prototype.getDataSyncService = function() {
  return (this.getService(wrm.data.sync.DataSyncService.ID));
};

/**
 * @return {!Promise<!wrm.data.sync.DataTrackerService>}
 */
wrm.core.Manager.prototype.getDataTrackerService = function() {
  return (this.getService(wrm.data.sync.DataTrackerService.ID));
};

/**
 * @return {!Promise<!wrm.core.AppService>}
 */
wrm.core.Manager.prototype.getAppService = function() {
  return (this.getService(wrm.core.AppService.ID));
};

/**
 * @return {!Promise<!wrm.core.SecurityService>}
 */
wrm.core.Manager.prototype.getSecurityService = function() {
  return (this.getService(wrm.core.SecurityService.ID));
};

/**
 * @return {!Promise<!wrm.l10n.LocalizationService>}
 */
wrm.core.Manager.prototype.getLocalizationService = function() {
  return (this.getService(wrm.l10n.LocalizationService.ID));
};

/**
 * @param {string} id
 * @return {!Promise<!wrm.CatcherService>}
 */
wrm.core.Manager.prototype.getCatcherService = function(id) {
  return (this.getService(id));
};

/**
 * @param {string} id
 * @return {!Promise<!wrm.core.PanelService>}
 */
wrm.core.Manager.prototype.getViewService = function(id) {
  return (this.getService(id));
};

/**
 * @param {string} id
 * @return {!Promise<!wrm.ViewComponentService>}
 */
wrm.core.Manager.prototype.getViewComponentService = function(id) {
  var promise = (this.getService(id));
  
  /* Add artificial slowness */
  if (SLOWDOWN > 0) {
    promise = promise.then(function(service) {
      service.updateView = wrm.core.Manager._slowdownMethod(service.updateView, SLOWDOWN);
      return service;
    });
  }
  
  return promise;
};

/**
 * @param {!wrm.ViewComponentService} viewCompService
 * @return {!Promise<boolean>}
 */
wrm.core.Manager.prototype.hasFormSubService = function(viewCompService) {
  return this.hasSubService(viewCompService, "form");
};

/**
 * @param {!wrm.ViewComponentService} viewCompService
 * @return {!Promise<!wrm.form.FormSubService>}
 */
wrm.core.Manager.prototype.getFormSubService = function(viewCompService) {
  return (this.getSubService(viewCompService, "form"));
};

/**
 * @param {!wrm.ViewComponentService} viewCompService
 * @return {!Promise<boolean>}
 */
wrm.core.Manager.prototype.hasValidationSubService = function(viewCompService) {
  return this.hasSubService(viewCompService, "validation");
};

/**
 * @param {!wrm.ViewComponentService} viewCompService
 * @return {!Promise<!wrm.form.ValidationSubService>}
 */
wrm.core.Manager.prototype.getValidationSubService = function(viewCompService) {
  var promise = (this.getSubService(viewCompService, "validation"));
  
  /* Add artificial slowness */
  if (SLOWDOWN > 0) {
    promise = promise.then(function(service) {
      service.validateEvent = wrm.core.Manager._slowdownMethod(service.validateEvent, SLOWDOWN);
      service.validateFormObject = wrm.core.Manager._slowdownMethod(service.validateFormObject, SLOWDOWN);
      service.validateFormProperty = wrm.core.Manager._slowdownMethod(service.validateFormProperty, SLOWDOWN);
      return service;
    });
  }
  
  return promise;
};

/**
 * @param {string} id
 * @return {!Promise<!wrm.core.ActionDefService>}
 */
wrm.core.Manager.prototype.getActionDefinitionService = function(id) {
  return (this.getService(id));
};

/**
 * @param {string} id
 * @return {!Promise<!wrm.OperationService>}
 */
wrm.core.Manager.prototype.getOperationService = function(id) {
  return (this.getService(id));
};

/**
 * @param {string} id
 * @return {!Promise<!wrm.Service>}
 */
wrm.core.Manager.prototype.getService = function(id) {
  return this._doGetService(id).then(function(instances) {
    return instances.main;
  });
};

/**
 * @param {!wrm.Service} service
 * @param {string} kind
 * @return {!Promise<boolean>}
 */
wrm.core.Manager.prototype.hasSubService = function(service, kind) {
  return this._doGetService(service.getId()).then(function(instances) {
    var subService = instances.sub[kind];
    return !!subService;
  });
};

/**
 * @param {!wrm.Service} service
 * @param {string} kind
 * @return {!Promise<!wrm.SubService>}
 */
wrm.core.Manager.prototype.getSubService = function(service, kind) {
  return this._doGetService(service.getId()).then(function(instances) {
    var subService = instances.sub[kind];
    if (!subService) {
      throw new Error("Sub-service '" + kind + "' of service '" + service.getId() + "' is not available");
    }
    return subService;
  });
};

/**
 * @internal
 * @param {string} id
 * @param {!Object} descr
 * @return {!Promise<{main:!wrm.Service, sub:!Object<string,!wrm.SubService>}>}
 */
wrm.core.Manager.prototype.instantiateService = function(id, descr) {
  return this._instantiateService(id, descr);
};

/**
 * @private
 * @param {string} id
 * @return {!Promise<{main:!wrm.Service, sub:!Object<string,!wrm.SubService>}>}
 */
wrm.core.Manager.prototype._doGetService = function(id) {
  var instancesPromise = this._serviceInstances[id];
  if (!instancesPromise) {
    instancesPromise = this._createServiceInstances(id);
    this._serviceInstances[id] = instancesPromise;
  }
  return instancesPromise;
};

/**
 * @param {string} id
 * @return {!Promise<{main:!wrm.Service, sub:!Object<string,!wrm.SubService>}>}
 */
wrm.core.Manager.prototype._createServiceInstances = function(id) {
  var thisManager = this;
  var log = this._log;
  
  var loadPromise = this._loader.loadServiceDescriptor(id);
  var propertiesPromise = this.getVariableProperties();
  
  return Promise.all([loadPromise, propertiesPromise]).then(function(descrAndProps) {
    var descr = descrAndProps[0];
    var properties = descrAndProps[1];
    if (!descr) {
      throw new Error("Service '" + id + "' descriptor not found");
    }
    
    /* Replace properties in the descriptor */
    thisManager._replaceProperties(descr, properties);
    
    /* Instantiate service and sub-services from the final descriptor */
    return thisManager._instantiateService(id, descr).then(function(instances) {
      return instances;
    });
  })["catch"](function(e) {
    log.error("Error creating service '" + id + "'", e);
    throw e;
  });
};

/**
 * @param {!Object} object
 * @param {!Object<string,string>} properties
 */
wrm.core.Manager.prototype._replaceProperties = function(object, properties) {
  
  /* Replace placeholders deeply in all string values */
  angular.forEach(object, function(value, objectKey) {
    if (typeof value === "object") {
      
      /* Nested object: visit */
      this._replaceProperties(value, properties);
      
    } else {
      if (typeof value === "string") {
        
        /* String value: replace all placeholders if a property is defined */
        object[objectKey] = value.replace(/\$\{([^}]+)}/g, function(placeholder, propKey) {
          var propValue = properties[propKey];
          if (propValue !== undefined) {
            return propValue;
          } else {
            return "${" + propKey + "}";
          }
        });
        
      }
    }
  }, this);
};

/**
 * @private
 * @param {string} id
 * @param {!Object} descr
 * @return {!Promise<{main:!wrm.Service, sub:!Object<string,!wrm.SubService>}>}
 */
wrm.core.Manager.prototype._instantiateService = function(id, descr) {
  var thisManager = this;
  
  /* Extract sub-service descriptors */
  var subDescrs = {};
  Object.keys(descr).forEach(function(key) {
    if (key.indexOf("_") === 0 && key.length > 1) {
      var subDescr = descr[key];
      if (subDescr !== null && typeof subDescr === "object" && thisManager._hasConstructor(subDescr)) {
        delete descr[key];
        subDescrs[key.substring(1)] = subDescr;
      }
    }
  });
  
  /* Extract the constructor */
  var promise = Promise.resolve().then(function() {
    return thisManager._extractConstructor(descr);
  })["catch"](function(e) {
    throw new Error("Cannot instantiate service '" + id + "': " + e.message);
  });
  
  /* Construct the service instance */
  promise = promise.then(function(ctor) {
    var service = (newObject(ctor.prototype));
    ctor.call(service, id, descr, thisManager);
    return service;
  });
  
  /* Perform possibly-asynchronous initialization */
  return promise.then(function(service) {
    return Promise.resolve(service.initialize(descr)).then(function() {
      return service;
    });
  }).then(function(service) {
    
    /* Instantiate sub-services (in parallel) */
    var subServices = {};
    var subServicePromises = Object.keys(subDescrs).map(function(kind) {
      var subDescr = subDescrs[kind];
      return thisManager._instantiateSubService(service, kind, subDescr).then(function(subService) {
        subServices[kind] = subService;
      });
    });
    
    return Promise.all(subServicePromises).then(function() {
      return {main:service, sub:subServices};
    });
  });
};

/**
 * @private
 * @param {!wrm.Service} service
 * @param {string} kind
 * @param {!Object} descr
 * @return {!Promise<!wrm.SubService>}
 */
wrm.core.Manager.prototype._instantiateSubService = function(service, kind, descr) {
  var thisManager = this;
  
  /* Extract the constructor */
  var promise = Promise.resolve().then(function() {
    return thisManager._extractConstructor(descr);
  })["catch"](function(e) {
    throw new Error("Cannot instantiate sub-service '" + kind + "' of service '" + service.getId() + "': " + e.message);
  });
  
  /* Construct the sub-service instance */
  promise = promise.then(function(ctor) {
    var subService = (newObject(ctor.prototype));
    ctor.call(subService, service, descr, thisManager);
    return subService;
  });
  
  /* Perform possibly-asynchronous initialization */
  return promise.then(function(subService) {
    return Promise.resolve(subService.initialize(descr)).then(function() {
      return subService;
    });
  });
};

/**
 * @param {!wrm.Service} service
 * @return {string}
 */
wrm.core.Manager.prototype.getServiceType = function(service) {
  return service.constructor["_serviceType"] || "wrm.Service";
};

/**
 * @param {!wrm.SubService} subService
 * @return {string}
 */
wrm.core.Manager.prototype.getSubServiceType = function(subService) {
  return subService.constructor["_serviceType"] || "wrm.SubService";
};

/**
 * @return {!Promise<!Object<string,string>>}
 */
wrm.core.Manager.prototype.getVariableProperties = function() {
  if (!this._variableProperties) {
    this._variableProperties = this.getOptionalConfigurationProperties("WebRatio").then(function(properties) {
      return properties || {};
    });
  }
  return this._variableProperties;
};

/**
 * @param {string} id
 * @return {!Promise<!Object>}
 */
wrm.core.Manager.prototype.getConfigurationObject = function(id) {
  return (this._doGetConfigurationObject(id, false));
};

/**
 * @param {string} id
 * @return {!Promise<Object>}
 */
wrm.core.Manager.prototype.getOptionalConfigurationObject = function(id) {
  return this._doGetConfigurationObject(id, true);
};

/**
 * @private
 * @param {string} id
 * @param {boolean} optional
 * @return {!Promise<Object>}
 */
wrm.core.Manager.prototype._doGetConfigurationObject = function(id, optional) {
  var promise = this._loader.loadConfigurationObject(id);
  if (!optional) {
    promise = promise.then(function(conf) {
      if (!conf) {
        throw new Error("Configuration object '" + id + "' not found");
      }
      return conf;
    });
  }
  return promise;
};

/**
 * @param {string} id
 * @return {!Promise<!Object<string,string>>}
 */
wrm.core.Manager.prototype.getConfigurationProperties = function(id) {
  return (this._doGetConfigurationProperties(id, false));
};

/**
 * @param {string} id
 * @return {!Promise<Object<string,string>>}
 */
wrm.core.Manager.prototype.getOptionalConfigurationProperties = function(id) {
  return this._doGetConfigurationProperties(id, true);
};

/**
 * @private
 * @param {string} id
 * @param {boolean} optional
 * @return {!Promise<Object<string,string>>}
 */
wrm.core.Manager.prototype._doGetConfigurationProperties = function(id, optional) {
  var promise = this._loader.loadConfigurationProperties(id);
  if (!optional) {
    promise = promise.then(function(conf) {
      if (!conf) {
        throw new Error("Configuration properties '" + id + "' not found");
      }
      return conf;
    });
  }
  return promise;
};

/**
 * @private
 * @param {!Object} descr
 * @return {boolean}
 */
wrm.core.Manager.prototype._hasConstructor = function(descr) {
  return typeof descr["_"] === "string" || typeof descr["service"] === "string";
};

/**
 * @private
 * @param {!Object} descr
 * @return {!Promise<function(new:wrm.Service,string,!Object,!wrm.core.Manager)|function(new:wrm.SubService,!wrm.Service,!Object)>}
 */
wrm.core.Manager.prototype._extractConstructor = function(descr) {
  var log = this._log;
  
  /* Extract the constructor name, or its module's, from the descriptor */
  var name = descr["_"];
  var moduleName = descr["service"];
  if (!name && !moduleName) {
    throw new Error("No constructor specified in descriptor");
  }
  delete descr["_"];
  delete descr["service"];
  
  /* Retrieve the constructor function: favor using a direct reference over loading a module */
  var promise = Promise.resolve();
  if (!!name) {
    promise = promise.then(function() {
      if (!!moduleName) {
        log.warn("Ignoring reference to module '" + moduleName + "', instead looking for global '" + name + "'");
      }
      var ctor = wrm.util.obj.lookup(name);
      if (typeof ctor !== "function") {
        throw new Error("Missing or invalid constructor '" + name + "'");
      }
      return ctor;
    });
  } else {
    promise = promise.then(function() {
      return wrm.importModule(moduleName.replace(/\./g, "/"));
    }).then(function(ctorModule) {
      var ctor = ctorModule["default"];
      if (typeof ctor !== "function") {
        throw new Error("Missing or invalid constructor as default export in module '" + moduleName + "'");
      }
      return ctor;
    });
  }
  
  /* Keep constructor name on the function itself */
  return promise.then(function(ctor) {
    ctor["_serviceType"] = name || moduleName;
    return ctor;
  });
};

/**
 * @private
 * @template S, R
 * @param {function(this:S,...?):R} method
 * @param {number} duration
 * @return {function(this:S,...?):R}
 */
wrm.core.Manager._slowdownMethod = function(method, duration) {
  var slowerMethod = function() {
    var receiver = this;
    var args = arguments;
    return wrm.util.sleep(duration / 2).then(function() {
      return method.apply(receiver, args);
    }).then(function(result) {
      return wrm.util.sleep(duration / 2).then(function() {
        return result;
      });
    });
  };
  return slowerMethod;
};




//== wrm/core/MasterAwareFlow.js ==============================================



/**
 * @package
 * @constructor
 * @extends wrm.nav.AbstractFlow
 * @implements wrm.nav.NavFlow
 * @param {!wrm.nav.NavFlow} mainFlow
 * @param {!Object<string,!wrm.core.AutoFlow>} autoFlows
 */
wrm.core.MasterAwareFlow = function(mainFlow, autoFlows) {
  wrm.nav.AbstractFlow.call(this, mainFlow.getId());
  
  /** @private */
  this._mainFlow = mainFlow;
  
  /** @private */
  this._autoFlows = autoFlows;
  
  /* Extract all flows into a single array */
  var allFlows = [mainFlow];
  angular.forEach(autoFlows, function(autoFlow) {
    allFlows.push(autoFlow);
  }, this);
  
  /**
   * @private
   * @type {?Object<string,!Object<string,boolean>>}
   */
  this._preserves = wrm.core.MasterAwareFlow._constructMergedPreserves(allFlows);
  
  /**
   * @private
   * @type {!Object<string,*>}
   */
  this._bindings = wrm.core.MasterAwareFlow._constructMergedBindings(allFlows);
  
  /**
   * @private
   * @type {!Object<string,*>}
   */
  this._passings = wrm.core.MasterAwareFlow._constructMergedPassings(allFlows);
  
};

extendConstructor(wrm.core.MasterAwareFlow, wrm.nav.AbstractFlow);

/**
 * @private
 * @param {Array<!wrm.nav.Flow>} flows
 * @return {?Object<string,!Object<string,boolean>>}
 */
wrm.core.MasterAwareFlow._constructMergedPreserves = function(flows) {
  var result = null;
  flows.forEach(function(flow) {
    var flowPreserves = flow.getPreserves();
    if (!flowPreserves) {
      return;
    }
    
    /* Merge preserves with the result */
    if (!result) {
      result = {};
    }
    angular.forEach(flowPreserves, function(flowComponentPreserves, componentId) {
      var set = result[componentId];
      if (!set) {
        result[componentId] = set = {};
      }
      angular.extend(set, flowComponentPreserves);
    });
  });
  return result;
};

/**
 * @private
 * @param {Array<!wrm.nav.Flow>} flows
 * @return {!Object<string,*>}
 */
wrm.core.MasterAwareFlow._constructMergedBindings = function(flows) {
  var result = {};
  angular.forEach(flows, function(flow) {
    var flowBindings = flow.getBindings();
    angular.extend(result, flowBindings);
  });
  return result;
};

/**
 * @private
 * @param {Array<!wrm.nav.Flow>} flows
 * @return {!Object<string,*>}
 */
wrm.core.MasterAwareFlow._constructMergedPassings = function(flows) {
  var result = {};
  angular.forEach(flows, function(flow) {
    var flowPassings = flow.getPassings();
    angular.extend(result, flowPassings);
  });
  return result;
};

/**
 * @override
 * @protected
 */
wrm.core.MasterAwareFlow.prototype.getBoundSourceId = function() {
  return this._mainFlow.getBoundSourceId();
};

/**
 * @override
 * @protected
 */
wrm.core.MasterAwareFlow.prototype.getBoundTargetId = function() {
  return this._mainFlow.getBoundTargetId();
};

/** @override */
wrm.core.MasterAwareFlow.prototype.getTargetId = function() {
  return this._mainFlow.getTargetId();
};

/** @override */
wrm.core.MasterAwareFlow.prototype.getPreserves = function() {
  return this._preserves;
};

/** @override */
wrm.core.MasterAwareFlow.prototype.getBindings = function() {
  return this._bindings;
};

/** @override */
wrm.core.MasterAwareFlow.prototype.getPassings = function() {
  return this._passings;
};

/**
 * @package
 * @param {string} reachedPanelId
 * @param {!wrm.nav.State} state
 */
wrm.core.MasterAwareFlow.prototype.removeUselessPreserves = function(reachedPanelId, state) {
  
  /*
   * Determine actually needed preserves. If reaching one of the auto-flow panels, the correct preserves would have been main-flow
   * ones + auto-flow ones besides those of the reached panel. If reaching another panel, none of the extra auto-flow preservations
   * was needed.
   */
  var neededFlows = [this._mainFlow];
  if (this._autoFlows[reachedPanelId]) {
    angular.forEach(this._autoFlows, function(autoFlow, autoFlowPanelId) {
      if (autoFlowPanelId !== reachedPanelId) {
        neededFlows.push(autoFlow);
      }
    });
  }
  var neededPreserves = wrm.core.MasterAwareFlow._constructMergedPreserves(neededFlows);
  
  /* Delete component inputs of the state that were initially preserved by this flow but that are now known to be useless */
  angular.forEach(state.getComponentInputs(), function(input, componentId) {
    
    /* Get the parameters that were preserved and those that were needed */
    var preservedParams = this._preserves[componentId] || {};
    var neededParams = neededPreserves[componentId] || {};
    var propagatedParams = state.getChainPropagatedParams(componentId);
    
    /*
     * Delete input parameters that were preserved but are were not needed. In all cases, do not delete inputs that were
     * propagated, and thus provided a value newer than the preserved one. Parameters are found in public OWN properties of the
     * input object.
     */
    for (var inputProperty in input) {
      if (inputProperty.charAt(0) === "_") {
        continue;
      }
      if (!input.hasOwnProperty(inputProperty)) {
        continue;
      }
      if (propagatedParams[inputProperty] === true) {
        continue;
      }
      if (preservedParams[inputProperty] !== true || neededParams[inputProperty] === true) {
        continue;
      }
      delete input[inputProperty];
    }
    
  }, this);
};




//== wrm/core/ScenarioCondition.js ============================================


/**
 * @package
 * @constructor
 * @param {!Object} descr
 */
wrm.core.ScenarioCondition = function(descr) {
  
  /* Build a set of all navigation names (null if there are none) */
  var navigations;
  if (descr["navs"]) {
    navigations = {};
    angular.forEach(descr["navs"].split("|"), function(navName) {
      navigations[navName] = true;
    }, this);
  } else {
    navigations = null;
  }
  
  /* Build a list of all required side-effects */
  var requiredEffects = descr["effects"] ? descr["effects"].split("|") : [];
  
  /**
   * @private
   * @type {Object<string,boolean>}
   */
  this._navigations = navigations;
  
  /**
   * @private
   * @type {!Array<string>}
   */
  this._requiredEffects = requiredEffects;
  
};

/**
 * @param {!wrm.core.Navigation} navigation
 * @param {!Array<string>} observedEffects
 * @return {boolean}
 */
wrm.core.ScenarioCondition.prototype.matchesNavigation = function(navigation, observedEffects) {
  
  /* If there is a condition on navigation, the actual navigation must be one of the possible ones */
  if (this._navigations != null) {
    if (!this._navigations.hasOwnProperty(navigation.name)) {
      return false;
    }
  }
  
  /* Side-effects only: look for any of the observed side-effects in the required ones */
  if (this._requiredEffects.length > 0) {
    var found = false;
    for (var i = 0;i < this._requiredEffects.length;i++) {
      var effectName = this._requiredEffects[i];
      if (effectName === "-") {
        if (observedEffects.length <= 0) {
          found = true;
          break;
        }
      } else {
        if (observedEffects.indexOf(effectName) >= 0) {
          found = true;
          break;
        }
      }
    }
    if (!found) {
      return false;
    }
  }
  
  return true;
};




//== wrm/core/NavigationConditions.js =========================================



/**
 * @package
 * @constructor
 * @param {!Array<!Object>} descr
 */
wrm.core.NavigationConditions = function(descr) {
  
  /*
   * Build a list of navigation conditions, each composed by a scenario condition with an additional full/selective refresh mode
   * requirement
   */
  var conditions = [];
  angular.forEach(descr, function(condDescr) {
    var selectiveRefresh = condDescr["fr"] !== true;
    var scenarioCondition = new wrm.core.ScenarioCondition(condDescr);
    conditions.push({selectiveRefresh:selectiveRefresh, scenarioCondition:scenarioCondition});
  }, this);
  
  /**
   * @private
   * @type {!Array<{selectiveRefresh:boolean,scenarioCondition:!wrm.core.ScenarioCondition}>}
   */
  this._conditions = conditions;
  
};

/**
 * @param {!wrm.core.Navigation} navigation
 * @param {!Array<string>} observedEffects
 * @return {boolean}
 */
wrm.core.NavigationConditions.prototype.matchesNavigation = function(navigation, observedEffects) {
  var testedOnce = false;
  if (this._conditions.length > 0) {
    for (var i = 0;i < this._conditions.length;i++) {
      var condition = this._conditions[i];
      if (condition.selectiveRefresh === navigation.selectiveRefresh) {
        testedOnce = true;
        if (condition.scenarioCondition.matchesNavigation(navigation, observedEffects)) {
          return true;
        }
      }
    }
  }
  return !testedOnce && !navigation.selectiveRefresh;
};




//== wrm/core/Navigations.js ==================================================


/**
 * @package
 * @constructor
 * @param {!Object} descr
 */
wrm.core.Navigations = function(descr) {
  
  var navs = this._createNavigations(descr);
  
  /**
   * @private
   * @type {!Object<string,!wrm.core.Navigation>}
   */
  this._navigations = navs.byName;
  
  /**
   * @private
   * @type {!Object<string,!wrm.core.Navigations.Lookups>}
   */
  this._lookupsFullRefresh = this._computeLookupsByFlows(false, navs.list);
  
  /**
   * @private
   * @type {!Object<string,!wrm.core.Navigations.Lookups>}
   */
  this._lookupsSelectiveRefresh = this._computeLookupsByFlows(true, navs.list);
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._firstFlows = this._computeFirstFlows(navs.list);
};

/**
 * @package
 * @typedef {?{ name: string, nonContextual: boolean, flows: !Array<string>, selectiveRefresh: boolean, causedEffects: !Array<string>
 *          }}
 */
wrm.core.Navigation;

/**
 * @private
 * @typedef {Object<string,!wrm.core.Navigations.Lookups|!Array<!wrm.core.Navigation>>}
 */
wrm.core.Navigations.Lookups;

/**
 * @private
 * @param {!Object} descr
 * @return {{list:!Array<!wrm.core.Navigation>,byName:!Object<string,!wrm.core.Navigation>}}
 */
wrm.core.Navigations.prototype._createNavigations = function(descr) {
  var result = {list:[], byName:{}};
  
  angular.forEach(descr, function(navDescr, navName) {
    var nav = this._createNavigation(navName, navDescr);
    result.list.push(nav);
    result.byName[navName] = nav;
  }, this);
  
  return result;
};

/**
 * @private
 * @param {string} name
 * @param {!Object} descr
 * @return {!wrm.core.Navigation}
 */
wrm.core.Navigations.prototype._createNavigation = function(name, descr) {
  
  /* Extract information from descriptor to the new navigation */
  var nonContextual = descr["nc"] === true;
  var flows = (descr["flows"].split("|"));
  var selectiveRefresh = descr["fr"] !== true;
  var causedEffects;
  if (descr["effects"]) {
    causedEffects = (descr["effects"].split("|"));
  } else {
    causedEffects = ([]);
  }
  
  return {name:name, nonContextual:nonContextual, flows:flows, selectiveRefresh:selectiveRefresh, causedEffects:causedEffects, toString:function() {
    return name;
  }};
};

/**
 * @private
 * @param {boolean} selectiveRefresh
 * @param {!Array<!wrm.core.Navigation>} navs
 * @return {!Object<string,!wrm.core.Navigations.Lookups>}
 */
wrm.core.Navigations.prototype._computeLookupsByFlows = function(selectiveRefresh, navs) {
  
  /* Index navigations by their endpoint flows (first and last) */    /** @type {!Object<string,!Array<!wrm.core.Navigation>>} */
  var navsByFlows = {};
  angular.forEach(navs, function(nav) {
    var flowsPair = nav.flows[0] + "," + nav.flows[nav.flows.length - 1];
    var list = navsByFlows[flowsPair];
    if (!list) {
      navsByFlows[flowsPair] = list = [];
    }
    list.push(nav);
  }, this);
  
  /* Compute lookups for each set of navigations */    /** @type {!Object<string,!wrm.core.Navigations.Lookups>} */
  var lookupsByFlows = {};
  angular.forEach(navsByFlows, function(navsForFlows, flowsPair) {
    lookupsByFlows[flowsPair] = this._computeLookups([], selectiveRefresh, navsForFlows);
  }, this);
  
  return lookupsByFlows;
};

/**
 * @private
 * @param {!Array<string>} flowsPrefix
 * @param {boolean} selectiveRefresh
 * @param {!Array<!wrm.core.Navigation>} viableNavs
 * @return {!wrm.core.Navigations.Lookups}
 */
wrm.core.Navigations.prototype._computeLookups = function(flowsPrefix, selectiveRefresh, viableNavs) {
  var lookups = {};
  
  /* Construct a temporary map with all following viable navigations */    /** @type {!Object<string,!Array<!wrm.core.Navigation>>} */
  var nextViableNavs = {};
  angular.forEach(viableNavs, function(nav) {
    
    /* Skip navigations with the wrong refresh mode */
    if (nav.selectiveRefresh != selectiveRefresh) {
      return;
    }
    
    /* Find out the next flow to recognize for matching the navigation */
    var stepFlow = "\x3cnull\x3e";
    if (nav.flows.length > flowsPrefix.length) {
      stepFlow = nav.flows[flowsPrefix.length];
    }
    
    var list = nextViableNavs[stepFlow];
    if (!list) {
      nextViableNavs[stepFlow] = list = [];
    }
    list.push(nav);
  }, this);
  
  /* Update lookup table */
  angular.forEach(nextViableNavs, function(navs, stepFlow) {
    if (stepFlow === "\x3cnull\x3e") {
      if (navs.length > 1) {
        throw new Error("Found multiple matching navigations for prefix " + flowsPrefix + " with " + (selectiveRefresh ? "selective" : "full") + " refresh");
      }
      lookups["\x3cnull\x3e"] = navs;
    } else {
      var nextPrefix = flowsPrefix.slice(0);
      nextPrefix.push(stepFlow);
      lookups[stepFlow] = this._computeLookups(nextPrefix, selectiveRefresh, navs);
    }
  }, this);
  
  return lookups;
};

/**
 * @private
 * @param {!Array<!wrm.core.Navigation>} navs
 * @return {!Object<string,boolean>}
 */
wrm.core.Navigations.prototype._computeFirstFlows = function(navs) {
  var firstFlows = {};
  angular.forEach(navs, function(nav) {
    firstFlows[nav.flows[0]] = true;
  }, this);
  return firstFlows;
};

/**
 * @param {string} navigationName
 * @return {!wrm.core.Navigation}
 */
wrm.core.Navigations.prototype.get = function(navigationName) {
  var nav = this._navigations[navigationName];
  if (!nav) {
    throw new Error("Unknown navigation '" + navigationName + "'");
  }
  return nav;
};

/**
 * @param {!Array<string>} flows
 * @return {number}
 */
wrm.core.Navigations.prototype.getMaxLength = function(flows) {
  
  /* Find the farthest first flow index */
  var firstFlowIndex = -1;
  for (var i = flows.length - 1;i >= 0;i--) {
    if (this._firstFlows.hasOwnProperty(flows[i])) {
      firstFlowIndex = i;
    }
  }
  
  return firstFlowIndex >= 0 ? flows.length - firstFlowIndex : 0;
};

/**
 * @param {!Array<string>} flows
 * @param {boolean} selectiveRefresh
 * @param {number} minMatches
 * @return {!Array<!wrm.core.Navigation>}
 */
wrm.core.Navigations.prototype.lookup = function(flows, selectiveRefresh, minMatches) {
  var navigations = this._doLookup(flows, selectiveRefresh, minMatches);
  
  /* If nothing found and there are at least two flows, try matching a "default" navigation containing a star flow */
  if (navigations.length <= 0 && minMatches <= 2 && flows.length >= 2) {
    var flows2 = [flows[0], "*", flows[flows.length - 1]];
    navigations = this._doLookup(flows2, selectiveRefresh, 3);
  }
  
  return navigations;
};

/**
 * @private
 * @param {!Array<string>} flows
 * @param {boolean} selectiveRefresh
 * @param {number} minMatches
 * @return {!Array<!wrm.core.Navigation>}
 */
wrm.core.Navigations.prototype._doLookup = function(flows, selectiveRefresh, minMatches) {
  var lookupsByPair = selectiveRefresh ? this._lookupsSelectiveRefresh : this._lookupsFullRefresh;
  
  /* Find the last flow and the farthest first flow for which a set of lookups is available */
  var lastFlow = flows[flows.length - 1];
  var firstFlowIndex = 0;
  var lookups = null;
  for (var i = 0;i < flows.length;i++) {
    if (this._firstFlows.hasOwnProperty(flows[i])) {
      lookups = lookupsByPair[flows[i] + "," + lastFlow];
      if (lookups) {
        firstFlowIndex = i;
        break;
      }
    }
  }
  if (!lookups) {
    return [];
  }
  
  return this._doLookupStep(flows.slice(firstFlowIndex, flows.length), minMatches, lookups);
};

/**
 * @private
 * @param {!Array<string>} flows
 * @param {number} minMatches
 * @param {!wrm.core.Navigations.Lookups} lookups
 * @return {!Array<!wrm.core.Navigation>}
 */
wrm.core.Navigations.prototype._doLookupStep = function(flows, minMatches, lookups) {
  var skipUnknown = minMatches <= 0;
  
  var foundObj;
  do {
    var nextFlow = null;
    if (flows.length > 0) {
      nextFlow = flows.shift();
    }
    foundObj = lookups[nextFlow || "\x3cnull\x3e"];
  } while (!foundObj && flows.length > 0 && skipUnknown);
  
  if (foundObj && !angular.isArray(foundObj)) {
    return this._doLookupStep(flows, minMatches - 1, foundObj);
  } else {
    if (foundObj) {
      return foundObj;
    } else {
      if (skipUnknown) {
        var ambigNavigations = [];
        this._collectNavigations(ambigNavigations, lookups);
        return ambigNavigations;
      }
      return [];
    }
  }
};

/**
 * @private
 * @param {!Array<!wrm.core.Navigations>} navigations
 * @param {!wrm.core.Navigations.Lookups} lookups
 */
wrm.core.Navigations.prototype._collectNavigations = function(navigations, lookups) {
  angular.forEach(lookups, function(obj) {
    if (obj && !angular.isArray(obj)) {
      this._collectNavigations(navigations, obj);
    } else {
      Array.prototype.push.apply(navigations, obj);
    }
  });
};




//== wrm/core/NotFoundError.js ================================================


/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.core.NotFoundError = makeCustomErrorConstructor("wrm.core.NotFoundError");




//== wrm/core/PanelService.js =================================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.nav.Navigable
 * @implements wrm.nav.Notifiable
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.PanelService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /**
   * @private
   * @type {?Array<string>}
   */
  this._protectionRoles = descr["protected"] || null;
  
  /**
   * @private
   * @type {?string}
   */
  this._fence = descr["fence"] || null;
  
  /** @private */
  this._master = descr["master"] === true;
  
  /** @private */
  this._gateway = descr["gateway"] === true;
  
  /**
   * @private
   * @type {!Array<!wrm.core.PanelService>}
   */
  this._masterPanelServices;
  
  /**
   * @private
   * @type {!wrm.data.sync.DataSyncService}
   */
  this._dataSyncService;
  
  /**
   * @private
   * @type {!wrm.core.Navigations}
   */
  this._navigations = new wrm.core.Navigations(descr["navigations"]);
  
  /* Build a set of all known side-effects */
  var knownEffects = {};
  angular.forEach(descr["knownEffects"] ? descr["knownEffects"].split("|") : [], function(effect) {
    knownEffects[effect] = true;
  });
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._knownEffects = knownEffects;
  
  /* Create propagation flows */
  var propagationFlows = this._createPropagationFlows(descr["propagations"]);
  
  /**
   * @private
   * @type {!Array<!wrm.nav.FlowImpl>}
   */
  this._propagationSequence = this._createPropagationSequence(descr["propagationSequence"], propagationFlows, "propagation sequence");
  
  /* Create component computations */
  var componentComps = this._createComponentComputations(descr["components"]);
  
  /**
   * @private
   * @type {!Array<string>}
   */
  this._components = componentComps.compIds;
  
  /**
   * @private
   * @type {!Object<string,wrm.core.PanelService._ComponentComputation>}
   */
  this._componentComps = componentComps.map;
  
  /**
   * @private
   * @type {!Object<string,wrm.core.PanelService._EventInfo>}
   */
  this._eventInfos = this._createEventInfos(descr["events"], propagationFlows);
  
  /**
   * @private
   * @type {!wrm.core.AutoFlow}
   */
  this._autoFlow = new wrm.core.AutoFlow(descr["autoFlow"], this);
  
  /**
   * @private
   * @type {!wrm.core.AutoFlow}
   */
  this._autoFlowFull = new wrm.core.AutoFlow(descr["autoFlowFull"], this);
  
  /** @private */
  this._navigateTasks = new wrm.util.TaskQueue({maxWorkers:10});
  
  /** @private */
  this._pendingRefreshEventsHandling = false;
};

extendConstructor(wrm.core.PanelService, wrm.core.AbstractService);

/** @override */
wrm.core.PanelService.prototype.initialize = function(descr) {
  var thisService = this;
  var manager = this.getManager();
  
  var promise = manager.getDataSyncService().then(function(dataSyncService) {
    thisService._dataSyncService = dataSyncService;
  });
  
  /* Retrieve a panel service for each master panel id */
  if (descr["masters"]) {
    var mpPromisese = [];
    angular.forEach(descr["masters"], function(masterPanelId) {
      mpPromisese.push(manager.getViewService(masterPanelId));
    });
    promise = promise.then(function() {
      return Promise.all(mpPromisese).then(function(masterPanelServices) {
        thisService._masterPanelServices = masterPanelServices;
      });
    });
  } else {
    this._masterPanelServices = [];
  }
  
  return promise;
};

/**
 * @private
 * @param {!Object} descr
 * @return {!Object<string,!wrm.nav.FlowImpl>}
 */
wrm.core.PanelService.prototype._createPropagationFlows = function(descr) {
  var flows = {};
  Object.keys(descr).forEach(function(flowId) {
    var flowDescr = descr[flowId];
    flows[flowId] = new wrm.nav.FlowImpl(flowDescr);
  });
  return flows;
};

/**
 * @private
 * @param {?string} sequenceString
 * @param {!Object<string,!wrm.nav.FlowImpl>} propagationFlows
 * @param {string} label
 * @return {!Array<!wrm.nav.FlowImpl>}
 */
wrm.core.PanelService.prototype._createPropagationSequence = function(sequenceString, propagationFlows, label) {
  if (!sequenceString) {
    return [];
  }
  
  /* Split the sequence, then add the corresponding flows from the map (thus reusing the same instances) */
  return sequenceString.split("|").map(function(flowId) {
    var flow = propagationFlows[flowId];
    if (!flow) {
      throw new Error("Invalid flow id '" + flowId + "' in " + label);
    }
    return flow;
  }, this);
};

/**
 * @private
 * @typedef {{compId:string,formBased:boolean,hasView:boolean,navConditions:!wrm.core.NavigationConditions,refreshFormInfos:!Array<wrm.core.PanelService._RefreshFormInfo>}}
 */
wrm.core.PanelService._ComponentComputation;

/**
 * @private
 * @typedef {{selectiveRefresh:boolean,scenarioCondition:!wrm.core.ScenarioCondition,all:boolean,inputs:!Array<string>}}
 */
wrm.core.PanelService._RefreshFormInfo;

/**
 * @private
 * @param {!Object} descr
 * @return {{map:!Object<string,wrm.core.PanelService._ComponentComputation>,compIds:!Array<string>}}
 */
wrm.core.PanelService.prototype._createComponentComputations = function(descr) {
  var result = {map:{}, compIds:[]};
  
  angular.forEach(descr, function(compDescr, compId) {
    var compComputation = this._createComponentComputation(compId, compDescr);
    result.map[compId] = compComputation;
    result.compIds.push(compId);
  }, this);
  
  return result;
};

/**
 * @private
 * @param {string} compId
 * @param {!Object} descr
 * @return {wrm.core.PanelService._ComponentComputation}
 */
wrm.core.PanelService.prototype._createComponentComputation = function(compId, descr) {
  
  /* Extract informations from descriptor */
  var formBased = descr["fb"] === true;
  var hasView = descr["nv"] !== true;
  var navConditions = new wrm.core.NavigationConditions(descr["conds"] || []);
  var refreshFormInfos = [];
  if (descr["rf"]) {
    angular.forEach(descr["rf"], function(rfiDescr) {
      
      /* Extract refresh form information from its sub-descriptor */
      var selectiveRefresh = rfiDescr["fr"] !== true;
      var scenarioCondition = new wrm.core.ScenarioCondition(rfiDescr);
      var all = rfiDescr["all"] === true;
      var inputs = [];
      if (rfiDescr["inputs"]) {
        angular.forEach(rfiDescr["inputs"].split("|"), function(inputId) {
          var inputName = wrm.core.parseParameter(inputId).name;
          inputs.push(inputName);
        });
      }
      
      refreshFormInfos.push({selectiveRefresh:selectiveRefresh, scenarioCondition:scenarioCondition, all:all, inputs:inputs});
    }, this);
  }
  
  return {compId:compId, formBased:formBased, hasView:hasView, navConditions:navConditions, refreshFormInfos:refreshFormInfos};
};

/**
 * @private
 * @typedef {{eventId:string, compId:?string, type:string, flow:?wrm.nav.NavFlow, secondaryFlows:!Array<!wrm.nav.Flow>}}
 */
wrm.core.PanelService._EventInfo;

/**
 * @private
 * @param {!Object} descr
 * @param {!Object<string,!wrm.nav.FlowImpl>} propagationFlows
 * @return {!Object<string,!wrm.core.PanelService._EventInfo>}
 */
wrm.core.PanelService.prototype._createEventInfos = function(descr, propagationFlows) {
  var result = {};
  
  Object.keys(descr).forEach(function(eventId) {
    var eventDescr = descr[eventId];
    
    /** @type {!wrm.core.PanelService._EventInfo} */
    var eventInfo = {eventId:eventId, compId:eventDescr["component"] || null, type:eventDescr["type"], flow:eventDescr["flow"] ? new wrm.nav.NavFlowImpl(eventDescr["flow"]) : null, secondaryFlows:this._createPropagationSequence(eventDescr["secondaryFlows"] || null, propagationFlows, "secondaries of event '" + eventId + "'")};
    
    result[eventInfo.type + "." + eventId] = eventInfo;
    if (eventDescr["generic"] === true) {
      result[eventInfo.type] = eventInfo;
    }
  }, this);
  
  return result;
};

/*
 * Form operations
 */

/**
 * @return {!Promise<!wrm.core.FormInfo>}
 */
wrm.core.PanelService.prototype.getFormInfo = function() {
  var thisService = this;
  if (this._master) {
    throw new Error("FormInfo of master panel can not be computed directly");
  }
  var formSubServices = {};
  
  /* Retrieve form sub-services for primary panel */
  return this._getOwnFormSubservices().then(function(panelFormSubServices) {
    Object.keys(panelFormSubServices).forEach(function(key) {
      formSubServices[key] = panelFormSubServices[key];
    });
    
    /* Retrieve form sub-services for every master panel */
    return thisService._masterPanelServices.reduce(function(chain, masterPanelService) {
      return chain.then(function() {
        return masterPanelService._getOwnFormSubservices();
      }).then(function(masterFormSubService) {
        Object.keys(masterFormSubService).forEach(function(key) {
          formSubServices[key] = masterFormSubService[key];
        });
      });
    }, Promise.resolve());
  }).then(function() {
    return new wrm.core.FormInfo(formSubServices);
  });
};

/**
 * @private
 * @return {!Promise<!Object<string,!wrm.form.FormSubService>>}
 */
wrm.core.PanelService.prototype._getOwnFormSubservices = function() {
  var components = this._components;
  var componentComps = this._componentComps;
  var manager = this.getManager();
  
  /* Collect form sub-services of all form-based components */
  var formSubServices = {};
  var promise = components.reduce(function(chain, componentId) {
    var componentComp = componentComps[componentId];
    if (!componentComp.formBased) {
      return chain;
    }
    
    return chain.then(function() {
      return manager.getViewComponentService(componentId);
    }).then(function(viewComponentService) {
      return manager.getFormSubService(viewComponentService);
    }).then(function(formSubService) {
      formSubServices[componentId] = formSubService;
    });
  }, Promise.resolve());
  
  return promise.then(function() {
    return formSubServices;
  });
};

/**
 * @param {?string} propertyName
 * @param {!wrm.nav.State} state
 * @return {!Promise<boolean>}
 */
wrm.core.PanelService.prototype.validate = function(componentId, propertyName, state) {
  var manager = this.getManager();
  
  /* Have the component validate the form object/property using its validation sub-service */
  return Promise.resolve().then(function() {
    return manager.getViewComponentService(componentId);
  }).then(function(viewComponentService) {
    return manager.hasValidationSubService(viewComponentService).then(function(available) {
      if (available) {
        return manager.getValidationSubService(viewComponentService);
      }
      return null;
    });
  }).then(function(validationSubService) {
    if (validationSubService) {
      if (propertyName) {
        return validationSubService.validateFormProperty(propertyName, state);
      } else {
        return validationSubService.validateFormObject(state);
      }
    }
    return true;
  });
};

/*
 * Navigation
 */

/** @override */
wrm.core.PanelService.prototype.getFence = function() {
  return this._fence;
};

/** @override */
wrm.core.PanelService.prototype.navigate = function(gate, state) {
  var thisPanelService = this;
  
  /* Check permission, then give a chance to data synchronization */
  return thisPanelService._checkPermission(state).then(function(route) {
    return route || thisPanelService._dataSyncService.synchronizeDuringNavigation(state);
  }).then(function(route) {
    
    /* Navigate the panel, unless routed elsewhere by permission check or data synchronization */
    thisPanelService._dataSyncService.collectSuccessEvents(state);
    return route || thisPanelService._navigateInternal(gate, true, state);
  });
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.PanelService.prototype._checkPermission = function(state) {
  var allowedRoles = this._protectionRoles;
  if (allowedRoles) {
    return this.getManager().getSecurityService().then(function(securityService) {
      return securityService.checkPermission((allowedRoles), state);
    });
  }
  return Promise.resolve((null));
};

/**
 * @private
 * @param {?string} gate
 * @param {boolean} reachView
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Route|!Promise.<!wrm.nav.Route>}
 */
wrm.core.PanelService.prototype._navigateInternal = function(gate, reachView, state) {
  var additionalPromises = [];
  var mainPromise = this._navigate(this, reachView, additionalPromises, state);
  
  /* Put the navigation in queue so that it can be tracked and waited if necessary */
  this._navigateTasks.post(function() {
    return mainPromise.then(function() {
      return Promise.all(additionalPromises);
    });
  });
  
  /* Callers should only wait for the main promise */
  return mainPromise;
};

/**
 * @private
 * @param {!wrm.core.PanelService} reachedPanelService
 * @param {boolean} reachView
 * @param {!Array<!Promise>} additionalPromises
 * @param {!wrm.nav.State} state
 * @return {!wrm.nav.Route|!Promise<!wrm.nav.Route>}
 */
wrm.core.PanelService.prototype._navigate = function(reachedPanelService, reachView, additionalPromises, state) {
  var log = this.getLog();
  
  /*
   * If this is a master panel, find out the reached primary panel and pass navigation to it. Navigating to a master panel is like
   * navigating back to the start primary panel.
   */
  if (this._master) {
    var primaryPanelId = state.getContextualStartPrimaryPanelId();
    if (!primaryPanelId) {
      log.error("Invalid direct navigation to master panel", this);
      return wrm.nav.Route.toNowhere();
    }
    return this.getManager().getViewService(primaryPanelId).then(function(primaryPanelService) {
      return primaryPanelService._navigate(reachedPanelService, reachView, additionalPromises, state);
    });
  }
  
  /* This is a primary panel. Handle useless master panel preservations and finalize reaching the view. */
  var firstFlow = state.getFirstFlow();
  if (firstFlow instanceof wrm.core.MasterAwareFlow) {
    firstFlow.removeUselessPreserves(reachedPanelService.getId(), state);
  }
  var previousViewReuse = null;
  if (reachView) {
    previousViewReuse = state.reachPanel(this, reachedPanelService, this._gateway);
  }
  var navigations = this._locateAllNavigations(previousViewReuse, state);
  
  /* Compute data for the supported views (also including master panels - see other methods) */
  var promise = this._computePanel(navigations, additionalPromises, state);
  
  /* Proceed with a null route (end of navigation) */
  return promise.then(function() {
    log.debug("Panel navigation finished");
    return wrm.nav.Route.toNowhere();
  });
};

/*
 * Notification
 */

/** @override */
wrm.core.PanelService.prototype.notify = function(event, state) {
  var thisPanelService = this;
  var log = this.getLog();
  
  /* Handle some events by performing a stationary refresh */
  if (wrm.core.PanelService._REFRESH_EVENTS.hasOwnProperty(event.getType())) {
    return this._handleEventWithRefresh(event, wrm.core.PanelService._REFRESH_EVENTS[event.getType()], state);
  }
  
  /* Handle events not known to this panel */
  if (!this._isKnownEvent(event)) {
    
    /* If there are master panels, pass the notification to the one that knows about the event */
    for (var i = 0;i < this._masterPanelServices.length;i++) {
      var masterPanelService = this._masterPanelServices[i];
      if (masterPanelService._isKnownEvent(event)) {
        return masterPanelService.notify(event, state);
      }
    }
    
    /* No other panel knows about the event: propagate the notification */
    if (!this._isKnownEvent(event)) {
      return this.getManager().getAppService().then(function(appService) {
        return appService.notify(event, state);
      });
    }
  }
  
  /* Known event: validate it */
  return Promise.resolve().then(function() {
    return thisPanelService._validateEvent(event, state);
  }).then(function(valid) {
    if (!valid) {
      log.debug("Validation failed");
      return wrm.nav.Route.toNowhere();
    }
    
    thisPanelService._components.forEach(function(componentId) {
      state.getComponentFormState(componentId).publishValidViewValues();
    });
    
    /* Validation passed: Handle the event */
    return thisPanelService._handleEvent(event, state).then(function(eventFlow) {
      if (eventFlow) {
        return wrm.nav.Route.toService(eventFlow.getTargetId());
      } else {
        var startPanelId = state.getContextualStartPanelId();
        if (startPanelId) {
          return wrm.nav.Route.toService(startPanelId);
        }
        return wrm.nav.Route.toNowhere();
      }
    });
  });
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @param {string} debugLabel
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._handleEventWithRefresh = function(event, debugLabel, state) {
  var thisPanelService = this;
  var log = this.getLog();
  
  state.stepAhead(this._autoFlowFull);
  state.catchEvent(this, event);
  
  /* Do not schedule ANOTHER refresh event navigation */
  if (this._pendingRefreshEventsHandling) {
    log.debug("Ignoring further refresh after", debugLabel);
    return Promise.resolve(wrm.nav.Route.toNowhere());
  }
  
  /* Handle the refresh event only after other work is finished */
  this._pendingRefreshEventsHandling = true;
  return this._navigateTasks.waitForIdle().then(function() {
    thisPanelService._pendingRefreshEventsHandling = false;
    
    /* Navigate this panel service in a way that it and all master panels are refreshed */
    log.debug("Refreshing after", debugLabel);
    return thisPanelService._navigateInternal(null, false, state).then(function() {
      return wrm.nav.Route.toNowhere();
    });
  });
};

/**
 * @private
 * @const
 * @type {!Object<string,string>}
 */
wrm.core.PanelService._REFRESH_EVENTS = {"SynchronizationSuccess":"data synchronization", "CurrentLocaleChange":"locale change"};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @param {!wrm.nav.State} state
 * @return {Promise<boolean>}
 */
wrm.core.PanelService.prototype._validateEvent = function(event, state) {
  var components = this._components;
  var manager = this.getManager();
  
  var valid = true;
  
  /* Have all components validate using their validation sub-service */
  var promise = components.reduce(function(chain, componentId) {
    return chain.then(function() {
      return manager.getViewComponentService(componentId);
    }).then(function(viewComponentService) {
      return manager.hasValidationSubService(viewComponentService).then(function(available) {
        if (available) {
          return manager.getValidationSubService(viewComponentService);
        }
        return null;
      });
    }).then(function(validationSubService) {
      if (validationSubService) {
        return validationSubService.validateEvent(event, state);
      }
      return true;
    }).then(function(validForComponent) {
      if (!validForComponent) {
        valid = false;
      }
    });
  }, Promise.resolve());
  
  return promise.then(function() {
    return valid;
  });
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @param {!wrm.nav.State} state
 * @return {!Promise<!wrm.nav.FlowImpl>}
 */
wrm.core.PanelService.prototype._handleEvent = function(event, state) {
  var thisPanelService = this;
  var log = this.getLog();
  var flashState = this._createFlashState();
  
  /* Extract information about the event and its component */
  var eventInfo = this._getEventInfo(event);
  if (!eventInfo) {
    throw new Error("Unknown event " + event);
  }
  var componentId = eventInfo.compId;
  
  var promise = Promise.resolve();
  
  /* Let the component catch the event */
  if (componentId) {
    promise = this._catchEvent(componentId, event, flashState, state);
  }
  promise = promise.then(function() {
    state.catchEvent(thisPanelService, event);
  });
  
  /* Navigate the event flow, if any */
  var eventFlow = this._createEventNavigationFlow(eventInfo);
  if (eventFlow) {
    
    /* Propagate the secondary flows */
    var secondaryOutputs = {};
    promise = eventInfo.secondaryFlows.reduce(function(chain, secondaryFlow) {
      return chain.then(function() {
        var sourceId = secondaryFlow.getBoundSourceId();
        if (!sourceId || !thisPanelService._componentComps[sourceId]) {
          return {};
        }
        
        /* Let the secondary component do its own submit AT MOST ONCE */
        var secondaryOutput = secondaryOutputs[sourceId];
        if (secondaryOutput) {
          return secondaryOutput;
        }
        return thisPanelService._submitView(sourceId, flashState, state).then(function(output) {
          secondaryOutputs[sourceId] = output;
          return output;
        });
      }).then(function(secondaryOutput) {
        secondaryFlow.propagate(secondaryOutput, state);
      });
    }, promise);
    
    /* Let the primary component do its own submit */
    promise = promise.then(function() {
      if (componentId) {
        return thisPanelService._submitView(componentId, flashState, state);
      }
      return {};
    });
    
    /* Propagate the primary flow */
    promise = promise.then(function(output) {
      log.debug("Following event flow", eventFlow);
      eventFlow.propagate(output, state);
      state.stepAhead(eventFlow);
    });
  } else {
    state.stepJustEvent(eventInfo.eventId);
  }
  
  return promise.then(function() {
    return eventFlow;
  });
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @return {boolean}
 */
wrm.core.PanelService.prototype._isKnownEvent = function(event) {
  return !!this._getEventInfo(event);
};

/**
 * @private
 * @param {!wrm.nav.Event} event
 * @return {?wrm.core.PanelService._EventInfo}
 */
wrm.core.PanelService.prototype._getEventInfo = function(event) {
  
  /* Match specific, then generic (by name, then by type) */
  var eventInfo = this._eventInfos[event.getName()];
  if (!eventInfo) {
    eventInfo = this._eventInfos[event.getType()];
  }
  
  return eventInfo || null;
};

/**
 * @private
 * @param {wrm.core.PanelService._EventInfo} eventInfo
 * @return {wrm.nav.NavFlow}
 */
wrm.core.PanelService.prototype._createEventNavigationFlow = function(eventInfo) {
  var flow = eventInfo.flow;
  
  /* If there are master panels, wrap the flow in a master-aware flow */
  if (flow && this._masterPanelServices.length > 0) {
    var autoFlows = {};
    autoFlows[this.getId()] = this._autoFlow;
    angular.forEach(this._masterPanelServices, function(masterPanelService) {
      autoFlows[masterPanelService.getId()] = masterPanelService._autoFlow;
    });
    flow = new wrm.core.MasterAwareFlow(flow, autoFlows);
  }
  
  return flow;
};

/**
 * @return {boolean}
 */
wrm.core.PanelService.prototype.isMaster = function() {
  return this._master;
};

/*
 * Whole-panel Computations
 */

/**
 * @private
 * @param {!Object<string,!wrm.core.Navigation>} navigations
 * @param {!Array<!Promise>} additionalPromises
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._computePanel = function(navigations, additionalPromises, state) {
  var thisPanelService = this;
  var log = this.getLog();
  if (this._master) {
    throw new Error("Master panels cannot be computed directly");
  }
  
  if (log.isDebugEnabled()) {
    (function() {
      var navsLogString = Object.keys(navigations).map(function(panelId) {
        return panelId + ":" + navigations[panelId].name;
      }).join(", ");
      log.debug("Computing panel (" + navsLogString + ")");
    })();
  }
  var flashState = this._createFlashState(navigations);
  
  /* Fill the state with information required by form-based components */
  this._initFormInfo(flashState, state);
  
  /* Propagate parameters between outputs and inputs of all components */
  var promise = this._propagateParameters(flashState, state);
  
  /* Ask services of components to refresh their views (as an adidtional parallel task) */
  promise = promise.then(function() {
    var viewUpdatingComponentIds = [];
    additionalPromises.push(thisPanelService._updateViews(viewUpdatingComponentIds, flashState, state)["catch"](function(e) {
      log.error("Error during view update", e);
    }));
    if (log.isDebugEnabled() && viewUpdatingComponentIds.length > 0) {
      log.debug("Will update views of", viewUpdatingComponentIds.join(", "));
    }
    return null;
  });
  
  return promise;
};

/**
 * @private
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 */
wrm.core.PanelService.prototype._initFormInfo = function(flashState, state) {
  var thisPanelService = this;
  var RefreshMode = wrm.core.RefreshMode;
  
  /* Compute refresh mode and associated renewed inputs */
  var nav = this._getNavigation(flashState);
  var observedEffects = this._getObservedSideEffects(flashState);
  angular.forEach(this._componentComps, function(componentComp) {
    
    /* Skip non-form-based components */
    if (!componentComp.formBased) {
      return;
    }
    
    /* Evaluate refresh form informations, stopping at the first match */        /** @type {?wrm.core.PanelService._RefreshFormInfo} */
    var foundInfo = null;
    for (var i = 0;i < componentComp.refreshFormInfos.length;i++) {
      var info = componentComp.refreshFormInfos[i];
      if (info.selectiveRefresh === nav.selectiveRefresh && info.scenarioCondition.matchesNavigation(nav, observedEffects)) {
        foundInfo = info;
        break;
      }
    }
    
    /* Set information in the component input */
    var context = thisPanelService._getViewComponentContext(componentComp.compId, flashState, state);
    if (foundInfo) {
      context.setFormRefreshMode(foundInfo.all ? RefreshMode.REFRESH_ALL : RefreshMode.REFRESH);
      context.setFreshInputs(foundInfo.inputs);
    } else {
      context.setFormRefreshMode(RefreshMode.PRESERVE);
      context.setFreshInputs([]);
    }
  });
  
  /* Initialize master panels form info */
  if (!this._master) {
    angular.forEach(this._masterPanelServices, function(masterPanelService) {
      masterPanelService._initFormInfo(flashState, state);
    });
  }
};

/**
 * @private
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._propagateParameters = function(flashState, state) {
  var thisPanelService = this;
  
  /* Perform propagations, unless blocked by source component conditions */
  var promise = Promise.resolve();
  angular.forEach(this._propagationSequence, function(flow) {
    var componentId = flow.getBoundSourceId();
    if (!this._isComponentExecuted(componentId, flashState)) {
      return;
    }
    
    /* Compute output and then propagate the flow from it */
    promise = promise.then(function() {
      return thisPanelService._computeOutput(componentId, flashState, state);
    }).then(function(output) {
      flow.propagateWithScore(output, 1, flashState.parameterScores, state);
    });
  }, this);
  
  /* Propagate master panels parameters */
  if (!this._master) {
    angular.forEach(this._masterPanelServices, function(masterPanelService) {
      promise = promise.then(function() {
        return masterPanelService._propagateParameters(flashState, state);
      });
    }, this);
  }
  
  return promise;
};

/**
 * @private
 * @param {!Array<string>} expectedComponentIds
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._updateViews = function(expectedComponentIds, flashState, state) {
  
  /* Update all views, unless blocked by their component conditions */
  var updateViewPromises = [];
  angular.forEach(this._components, function(componentId) {
    if (!this._hasView(componentId) || !this._isComponentExecuted(componentId, flashState)) {
      return;
    }
    
    /* Update view */
    var promise = this._updateView(componentId, flashState, state);
    updateViewPromises.push(promise);
    expectedComponentIds.push(componentId);
  }, this);
  
  /* Update master panels views */
  if (!this._master) {
    angular.forEach(this._masterPanelServices, function(masterPanelService) {
      updateViewPromises.push(masterPanelService._updateViews(expectedComponentIds, flashState, state));
    }, this);
  }
  
  /* Return a single promise for the PARALLEL updates */
  return Promise.all(updateViewPromises);
};

/*
 * View component operations
 */

/**
 * @private
 * @param {string} componentId
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise<!Object>}
 */
wrm.core.PanelService.prototype._computeOutput = function(componentId, flashState, state) {
  var log = this.getLog();
  var context = this._getViewComponentContext(componentId, flashState, state);
  
  /* Retrieve the service and invoke it */
  return this.getManager().getViewComponentService(componentId).then(function(service) {
    log.debug("Computing output of", service, "-", context);
    return Promise.resolve(service.computeOutput(context)).then(function(output) {
      log.debug("Computed output of", service, "-", output);
      return output;
    });
  });
};

/**
 * @private
 * @param {string} componentId
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._updateView = function(componentId, flashState, state) {
  var REFRESH_EVENTS = wrm.core.PanelService._REFRESH_EVENTS;
  var PanelService = wrm.core.PanelService;
  var log = this.getLog();
  var manager = this.getManager();
  var context = this._getViewComponentContext(componentId, flashState, state);
  var view = context.getView();
  
  /* Determines if the navigation is caused by automatic event */
  var causedByRefreshEvent = !!(state.getCaughtEvent() && REFRESH_EVENTS.hasOwnProperty(state.getCaughtEvent().getType()));
  
  /* Immediately set the "updating" status, so that it happens before the navigation ends */
  PanelService._setViewUpdateStatus(view, true, causedByRefreshEvent);
  
  /* Retrieve the service and invoke it */
  var servicePromise = manager.getViewComponentService(componentId);
  var fpChangeTrackerPromise = this._getViewComponentFormPropertyChangeTracker(componentId, flashState, state);
  var promise = Promise.all([servicePromise, fpChangeTrackerPromise]).then(function(values) {
    var service = values[0];
    var fpChangeTracker = values[1];
    log.debug("Updating view of", service, "-", context);
    var startValues = fpChangeTracker.updatesStarted(view);
    return Promise.try(function() {
      return service.updateView(context);
    }).finally(function() {
      fpChangeTracker.updatesFinished(view, startValues);
      PanelService._setViewUpdateStatus(view, false, causedByRefreshEvent);
    }).then(function() {
      return manager.hasFormSubService(service);
    }).then(function(available) {
      if (available) {
        return manager.getFormSubService(service);
      }
      return null;
    }).then(function(formSubService) {
      if (formSubService) {
        return formSubService.publishFormState(state);
      }
    }).then(function() {
      log.debug("Updated view of", service, "-", view);
    });
  });
  
  /* Apply changes on the view (scheduling a refresh of whatever interface is attached to it) */
  return promise.then(function() {
    view.applyChanges();
  });
};

/**
 * @private
 * @param {string} componentId
 * @param {!wrm.nav.Event} event
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._catchEvent = function(componentId, event, flashState, state) {
  var log = this.getLog();
  var context = this._getViewComponentContext(componentId, flashState, state);
  
  /* Retrieve the service and invoke it */
  var promise = this.getManager().getViewComponentService(componentId).then(function(service) {
    log.debug("Catching at", service, "event", event, "-", context);
    return service.catchEvent(context, event);
  });
  
  /* Apply changes on the view (scheduling a refresh of whatever interface is attached to it) */
  return promise.then(function() {
    context.getView().applyChanges();
  });
};

/**
 * @private
 * @param {string} componentId
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.PanelService.prototype._submitView = function(componentId, flashState, state) {
  var log = this.getLog();
  var context = this._getViewComponentContext(componentId, flashState, state);
  
  /* Retrieve the service and invoke it */
  return this.getManager().getService(componentId).then(function(service) {
    log.debug("Submitting view of", service, "-", context);
    return Promise.resolve(service.submitView(context)).then(function(output) {
      log.debug("Submitted view of", service, "-", output);
      return output;
    });
  });
};

/**
 * @private
 * @param {string} componentId
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!wrm.core.ViewComponentContext}
 */
wrm.core.PanelService.prototype._getViewComponentContext = function(componentId, flashState, state) {
  var key = "context_" + componentId;
  var cache = flashState.cache;
  
  /* Retrieve the context or create & cache it */
  var componentContext = cache[key];
  if (!componentContext) {
    componentContext = state.createViewComponentContext(componentId);
    cache[key] = componentContext;
  }
  
  return componentContext;
};

/**
 * @private
 * @param {string} componentId
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @param {!wrm.nav.State} state
 * @return {!Promise<!wrm.form.FormPropertyTracker>}
 */
wrm.core.PanelService.prototype._getViewComponentFormPropertyChangeTracker = function(componentId, flashState, state) {
  var key = "fpChangeTracker_" + componentId;
  var cache = flashState.cache;
  var componentComps = this._componentComps;
  var manager = this.getManager();
  
  /* Retrieve the change tracker PROMISE or create & cache it */
  var fpChangeTracker = cache[key];
  if (!fpChangeTracker) {
    var componentComp = componentComps[componentId];
    var formState = state.getComponentFormState(componentId);
    if (!componentComp.formBased || !formState) {
      fpChangeTracker = Promise.resolve(new wrm.form.FormPropertyTracker(null, null));
    } else {
      fpChangeTracker = Promise.resolve().then(function() {
        return manager.getViewComponentService(componentId);
      }).then(function(viewComponentService) {
        return manager.getFormSubService(viewComponentService);
      }).then(function(formSubService) {
        return new wrm.form.FormPropertyTracker(formState, formSubService);
      });
    }
  }
  
  return fpChangeTracker;
};

/**
 * @private
 * @param {!wrm.core.View} view
 * @param {boolean} updating
 * @param {boolean} background
 */
wrm.core.PanelService._setViewUpdateStatus = function(view, updating, background) {
  if (background) {
    view["_updatingBG"] = updating;
  } else {
    view.updating = updating;
  }
};

/*
 * Navigations evaluation
 */

/**
 * @private
 * @param {string} compId
 * @return {boolean}
 */
wrm.core.PanelService.prototype._hasView = function(compId) {
  return this._componentComps[compId].hasView;
};

/**
 * @private
 * @param {string} compId
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @return {boolean}
 */
wrm.core.PanelService.prototype._isComponentExecuted = function(compId, flashState) {
  var computation = this._componentComps[compId];
  return this._checkNavigationConditions(computation.navConditions, flashState);
};

/**
 * @private
 * @param {!wrm.core.NavigationConditions} navConditions
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @return {boolean}
 */
wrm.core.PanelService.prototype._checkNavigationConditions = function(navConditions, flashState) {
  var nav = this._getNavigation(flashState);
  var observedEffects = this._getObservedSideEffects(flashState);
  return navConditions.matchesNavigation(nav, observedEffects);
};

/**
 * @private
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @return {!wrm.core.Navigation}
 */
wrm.core.PanelService.prototype._getNavigation = function(flashState) {
  var nav = flashState.navigations[this.getId()];
  if (!nav) {
    throw new Error("Navigation still not available");
  }
  return nav;
};

/**
 * @private
 * @param {!wrm.core.PanelService._FlashState} flashState
 * @return {!Array<string>}
 */
wrm.core.PanelService.prototype._getObservedSideEffects = function(flashState) {
  var result = {};
  
  /* Include caused effects from all navigation of OTHER panels that are known to this panel */
  var knownEffects = this._knownEffects;
  angular.forEach(flashState.navigations, function(nav, panelId) {
    
    /* Skip this panel */
    if (panelId === this.getId()) {
      return;
    }
    
    angular.forEach(nav.causedEffects, function(effect) {
      if (knownEffects[effect] === true) {
        result[effect] = true;
      }
    }, this);
  }, this);
  
  return Object.keys(result);
};

/**
 * @private
 * @param {?wrm.nav.Reuse} previousViewReuse
 * @param {!wrm.nav.State} state
 * @return {!Object<string,!wrm.core.Navigation>}
 */
wrm.core.PanelService.prototype._locateAllNavigations = function(previousViewReuse, state) {
  
  /*
   * This method is always called on the primary panel. Determine whether the overall navigation is changing view or not. That also
   * controls selective refresh.
   */
  var interView = this._computeInterView(previousViewReuse, state);
  
  /* Find out navigations for all panels (this one, the primary, and all master panels) */
  var navs = {};
  navs[this.getId()] = this._locateOwnNavigation(interView, state);
  angular.forEach(this._masterPanelServices, function(masterPanelService) {
    navs[masterPanelService.getId()] = masterPanelService._locateOwnNavigation(interView, state);
  });
  
  return navs;
};

/**
 * @private
 * @param {?wrm.nav.Reuse} previousViewReuse
 * @param {!wrm.nav.State} state
 * @return {boolean}
 */
wrm.core.PanelService.prototype._computeInterView = function(previousViewReuse, state) {
  
  /* If coming from another screen, and not fully merging on a previous one, the view is changing */
  if (state.getContextualStartPrimaryPanelId() !== this.getId()) {
    if (state.getMergedPrimaryPanelId() !== this.getId()) {
      return true;
    }
    if (previousViewReuse !== wrm.nav.Reuse.FULL) {
      return true;
    }
  }
  
  return false;
};

/**
 * @private
 * @param {boolean} interView
 * @param {!wrm.nav.State} state
 * @return {!wrm.core.Navigation}
 */
wrm.core.PanelService.prototype._locateOwnNavigation = function(interView, state) {
  var REFRESH_EVENTS = wrm.core.PanelService._REFRESH_EVENTS;
  
  /* Compute navigated flows */
  var flows;
  if (state.getReachedPanelId() == this.getId()) {
    flows = this._computeMainNavigatedFlows(state);
    if (state.getCaughtEvent() && state.getCaughtEvent().getType() === "BackEvent" && flows.length <= 0 && state.getMergedPrimaryPanelId()) {
      flows = this._computeAuxiliaryNavigatedFlows(interView);
    }
  } else {
    flows = this._computeAuxiliaryNavigatedFlows(interView);
  }
  
  /*
   * Determine whether the navigation was triggered by a special family of "refresh events" that happen in the background; those
   * events are notable because they logically required all components to refresh (i.e. a full refresh even if the view is not
   * changing)
   */
  var refreshEventCaught = state.getCaughtEvent() && REFRESH_EVENTS.hasOwnProperty(state.getCaughtEvent().getType());
  
  /* Find out navigation. Use selective refresh if performing an intra-view navigation not triggered by background refresh. */
  var selectiveRefresh = !interView && !refreshEventCaught;
  var nav = this._locateNavigation(flows, selectiveRefresh, true, state);
  if (nav == null) {
    throw new Error("Found no navigations on panel " + this.getId() + " matching flows " + flows + " (" + (selectiveRefresh ? "selective" : "full") + " refresh)");
  }
  
  return nav;
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Array<string>}
 */
wrm.core.PanelService.prototype._computeMainNavigatedFlows = function(state) {
  var flows = [];
  
  /* Add flows from flow history */
  Array.prototype.push.apply(flows, state.getFlowHistory());
  
  /* Remove the last flow if it represents a forward/landmark to the panel and it's not the only flow */
  var lastHistoryFlow = flows[flows.length - 1] || null;
  var panelId = this.getId();
  if (panelId + ".link" === lastHistoryFlow || panelId + ".enter" === lastHistoryFlow) {
    flows.pop();
  }
  
  /* Remove fake flows at the start of the history, since they are not meaningful for navigation */
  while (flows.length > 0 && wrm.Constants.FAKE_FLOW_ID === flows[0]) {
    flows.shift();
  }
  
  return flows;
};

/**
 * @private
 * @param {boolean} interView
 * @return {!Array<string>}
 */
wrm.core.PanelService.prototype._computeAuxiliaryNavigatedFlows = function(interView) {
  
  /* If the view is changing, navigate the default flow of this panel */
  if (interView) {
    return [this.getId()];
  }
  
  /* View not changing: navigate the special "auto" flow of this panel */
  return [this._autoFlow.getId()];
};

/**
 * @private
 * @param {!Array<string>} flows
 * @param {boolean} selectiveRefresh
 * @param {boolean} useDefault
 * @param {!wrm.nav.State} state
 * @return {wrm.core.Navigation}
 */
wrm.core.PanelService.prototype._locateNavigation = function(flows, selectiveRefresh, useDefault, state) {
  
  /* Retrieve navigation */
  var navs = this._navigations.lookup(flows, selectiveRefresh, 1);
  if (useDefault && navs.length <= 0) {
    navs = this._navigations.lookup([this.getId()], false, 1);
    if (navs.length <= 0) {
      throw new Error("Found no default navigation for flows " + flows + " (" + (selectiveRefresh ? "selective" : "full") + " refresh)");
    }
  }
  
  /* Find a single navigation whose conditions match the current state */
  var foundNav = null;
  for (var navIndex = 0;navIndex < navs.length;navIndex++) {
    var nav = navs[navIndex];
    if (this._checkNavigationConditionsForNavigationViability(nav, state)) {
      if (!foundNav) {
        foundNav = nav;
      } else {
        
        /* Before complaining about multiple navigations, attempt to match a shorter unique navigation */
        var foundShorterNav = null;
        var maxLength = this._navigations.getMaxLength(flows);
        if (maxLength > 0) {
          foundShorterNav = this._locateNavigation(flows.slice(flows.length - maxLength + 1, flows.length), selectiveRefresh, useDefault, state);
        }
        if (foundShorterNav != null) {
          return foundShorterNav;
        }
        
        throw new Error("Found multiple navigations matching flows " + flows + " (" + (selectiveRefresh ? "selective" : "full") + " refresh)");
      }
    }
  }
  
  return foundNav;
};

/**
 * @private
 * @param {!wrm.core.Navigation} nav
 * @param {!wrm.nav.State} state
 * @return {boolean}
 */
wrm.core.PanelService.prototype._checkNavigationConditionsForNavigationViability = function(nav, state) {
  return true;
};

/**
 * @private
 * @typedef {{navigations:!Object<string,!wrm.core.Navigation>, parameterScores:!Object<string,!Object<string,number>>, cache:!Object}}
 */
wrm.core.PanelService._FlashState;

/**
 * @private
 * @param {!Object<string,!wrm.core.Navigation>=} navigations
 * @return {!wrm.core.PanelService._FlashState}
 */
wrm.core.PanelService.prototype._createFlashState = function(navigations) {
  return {navigations:navigations || {}, parameterScores:{}, cache:{}};
};




//== wrm/core/RefreshMode.js ==================================================


/**
 * @enum {string}
 */
wrm.core.RefreshMode = {PRESERVE:"preserve", REFRESH:"refresh", REFRESH_ALL:"refreshAll"};




//== wrm/core/UpdateContext.js ================================================


/**
 * @constructor
 * @param {!wrm.data.Dictionary} stableSnapshot
 * @param {!wrm.data.Dictionary} updateSnapshot
 * @param {function(!*)} infoSetter
 * @param {function(string=):!*} infoGetter
 * @param {function()} canceler
 * @param {!wrm.nav.State} state
 */
wrm.core.UpdateContext = function(stableSnapshot, updateSnapshot, infoSetter, infoGetter, canceler, state) {
  
  /** @private */
  this._stableSnapshot = stableSnapshot;
  
  /** @private */
  this._updateSnapshot = updateSnapshot;
  
  /** @private */
  this._infoSetter = infoSetter;
  
  /** @private */
  this._infoGetter = infoGetter;
  
  /** @private */
  this._canceler = canceler;
  
  /** @private */
  this._state = state;
};

/**
 * @return {!wrm.data.Dictionary}
 */
wrm.core.UpdateContext.prototype.getStableSnapshot = function() {
  return this._stableSnapshot;
};

/**
 * @return {!wrm.data.Dictionary}
 */
wrm.core.UpdateContext.prototype.getUpdateSnapshot = function() {
  return this._updateSnapshot;
};

/**
 * @param {!*} info
 */
wrm.core.UpdateContext.prototype.setInfo = function(info) {
  this._infoSetter(info);
};

/**
 * @param {string=} participantId
 * @return {!*}
 */
wrm.core.UpdateContext.prototype.getInfo = function(participantId) {
  return this._infoGetter(participantId);
};

/**
 * @return {undefined}
 */
wrm.core.UpdateContext.prototype.cancel = function() {
  this._canceler();
};

/**
 * @return {!wrm.nav.State}
 */
wrm.core.UpdateContext.prototype.getState = function() {
  return this._state;
};




//== wrm/data/Dictionary.js ===================================================


/**
 * @interface A persistent key-value store.
 */
wrm.data.Dictionary = function() {
};

/**
 * Gets the keys for which a mapping exists in the store.
 * 
 * @return {!Array<string>}
 */
wrm.data.Dictionary.prototype.getKeys = function() {
};

/**
 * Gets a value from the store.
 * 
 * @param {string} key Key of the value.
 * @return {?string} A value or <code>null</code> if not present.
 */
wrm.data.Dictionary.prototype.get = ABSTRACT_METHOD;

/**
 * Sets a value in the store.
 * 
 * @param {string} key Key of the value.
 * @param {string} value Value to set.
 */
wrm.data.Dictionary.prototype.set = ABSTRACT_METHOD;

/**
 * Removes a value from the store. If not present, nothing happens.
 * 
 * @param {string} key Key of the value.
 */
wrm.data.Dictionary.prototype.remove = ABSTRACT_METHOD;

/**
 * Clears all mappings from the store.
 */
wrm.data.Dictionary.prototype.clear = ABSTRACT_METHOD;




//== wrm/data/WriteBackDictionary.js ==========================================



/**
 * @internal
 * @constructor
 * @implements wrm.data.Dictionary
 * @param {!wrm.data.Dictionary} delegate
 */
wrm.data.WriteBackDictionary = function(delegate) {
  
  /** @private */
  this._delegate = delegate;
  
  /**
   * @private
   * @type {!Object<string,string>}
   */
  this._modified = {};
  
  /**
   * @private
   * @type {!Object<string,boolean>}
   */
  this._removed = {};
  
  /** @private */
  this._dirty = false;
};

/** @override */
wrm.data.WriteBackDictionary.prototype.getKeys = function() {
  var delegateKeys = this._delegate.getKeys();
  if (!this._dirty) {
    return delegateKeys;
  }
  
  /* Integrate clearing and modified keys, remove removed keys */
  var keysSet = {};
  delegateKeys.forEach(function(key) {
    if (!this._removed[key]) {
      keysSet[key] = true;
    }
  }, this);
  Object.keys(this._modified).forEach(function(key) {
    keysSet[key] = true;
  }, this);
  return Object.keys(keysSet);
};

/** @override */
wrm.data.WriteBackDictionary.prototype.get = function(key) {
  if (this._dirty) {
    if (this._removed.hasOwnProperty(key)) {
      return null;
    }
    if (this._modified.hasOwnProperty(key)) {
      return this._modified[key];
    }
  }
  return this._delegate.get(key);
};

/** @override */
wrm.data.WriteBackDictionary.prototype.set = function(key, value) {
  if (this._dirty) {
    delete this._removed[key];
  }
  this._modified[key] = value;
  this._dirty = true;
};

/** @override */
wrm.data.WriteBackDictionary.prototype.remove = function(key) {
  if (this._dirty) {
    delete this._modified[key];
  }
  this._removed[key] = true;
  this._dirty = true;
};

/** @override */
wrm.data.WriteBackDictionary.prototype.clear = function() {
  if (this._dirty) {
    this._modified = {};
  }
  this.getKeys().forEach(function(key) {
    this._removed[key] = true;
  }, this);
  this._dirty = true;
};

/**
 * @return {boolean}
 */
wrm.data.WriteBackDictionary.prototype.isDirty = function() {
  return this._dirty;
};

/**
 * @return {undefined}
 */
wrm.data.WriteBackDictionary.prototype.commitChanges = function() {
  if (!this._dirty) {
    return;
  }
  Object.keys(this._removed).forEach(function(key) {
    this._delegate.remove(key);
  }, this);
  Object.keys(this._modified).forEach(function(key) {
    this._delegate.set(key, this._modified[key]);
  }, this);
  this._modified = {};
  this._removed = {};
  this._dirty = false;
};




//== wrm/core/UpdateService.js ================================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.core.UpdateService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /**
   * @private
   * @type {!wrm.l10n.LocalizationService}
   */
  this._l10nService;
  
  /**
   * @private
   * @type {!Object<string,!wrm.core.UpdateService._ParticipantInfo>}
   */
  this._participantInfosById = {};
  
  /** @private */
  this._participantsLocked = false;
  
  /* Update state */
  
  /**
   * @private
   * @type {!Object<string,!wrm.core.UpdateContext>}
   */
  this._contextsById = {};
  
  /**
   * @private
   * @type {!Object<string,!*>}
   */
  this._infosById = {};
  
  /** @private */
  this._canceled = false;
};

extendConstructor(wrm.core.UpdateService, wrm.core.AbstractService);

/** @override */
wrm.core.UpdateService.prototype.initialize = function(descr) {
  var thisService = this;
  var manager = this.getManager();
  
  /* Get needed services */
  return Promise.all([manager.getLocalizationService().then(function(l10nService) {
    thisService._l10nService = l10nService;
  })]);
};

/**
 * @const
 * @type {string}
 */
wrm.core.UpdateService.ID = "_update";

/**
 * @private
 * @typedef {{id:string, participant:!wrm.core.UpdateParticipant, requiredIds:!Array<string>}}
 */
wrm.core.UpdateService._ParticipantInfo;

/**
 * @param {string} id
 * @param {!wrm.core.UpdateParticipant} participant
 */
wrm.core.UpdateService.prototype.registerParticipant = function(id, participant) {
  if (typeof id !== "string") {
    throw new Error("Update participant id must be a string");
  }
  if (this._participantsLocked) {
    throw new Error("Participants can no longer be registered");
  }
  if (this._participantInfosById[id]) {
    throw new Error("Participant " + id + " already registered");
  }
  this._participantInfosById[id] = {id:id, participant:participant, requiredIds:participant.getRequiredParticipantIds().slice()};
};

/**
 * @private
 * @return {!Array<string>}
 */
wrm.core.UpdateService.prototype._computeSortedParticipantIds = function() {
  var $jscomp$this = this;
  
  /* Get a topological sort of the participant ids by using the required string identifiers */
  return wrm.util.sortTopologically(Object.keys(this._participantInfosById), function(id) {
    var requiredIds = $jscomp$this._participantInfosById[id].requiredIds;
    requiredIds.forEach(function(requiredId) {
      if (!$jscomp$this._participantInfosById[requiredId]) {
        throw new Error("Unable to find participant " + requiredId + " required by " + id);
      }
    });
    return requiredIds;
  });
};

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise<?wrm.nav.Route>}
 */
wrm.core.UpdateService.prototype.update = function(state) {
  var manager = this.getManager();
  var log = this.getLog();
  
  /* Ensure to solicit services that are known to participate in the update */
  return this._solicitParticipatingServices().then(function() {
    
    /* Perform the actual update */
    this._reportUpdateProgress(true, state);
    return this._doUpdate(state);
    
  }.bind(this)).then(function(result) {
    this._reportUpdateProgress(false, state);
    
    /* If the update was canceled, EXIT the application */
    if (result.canceled) {
      return wrm.nav.Route.toExit();
    }
    
    /* If there were updates, schedule the next synchronization to be a "first" one */
    if (result.updated) {
      return manager.getDataSyncService().then(function(dataSyncService) {
        dataSyncService.scheduleFirstSynchronization();
        return null;
      });
    }
    return null;
    
  }.bind(this), function(e) {
    this._reportUpdateProgress(false, state);
    
    /* In case of errors, show a dialog and EXIT the application */
    log.error("Update failed", e);
    return this._showErrorDialog(state).then(function() {
      return wrm.nav.Route.toExit();
    });
  }.bind(this));
};

/**
 * @private
 * @return {!Promise}
 */
wrm.core.UpdateService.prototype._solicitParticipatingServices = function() {
  var manager = this.getManager();
  return Promise.all([manager.getDataService(), manager.getDataSyncService(), manager.getBackEndService()]);
};

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise<{updated:boolean, canceled:boolean}>}
 */
wrm.core.UpdateService.prototype._doUpdate = function(state) {
  var $jscomp$this = this;
  var log = this.getLog();
  
  this._participantsLocked = true;
  
  /* Prepare for calling participants in direct and reverse order */
  var participantIds = this._computeSortedParticipantIds();
  var callParticipants = this._callParticipants.bind(this, participantIds, false, state);
  var callParticipantsInReverse = this._callParticipants.bind(this, participantIds, true, state);
  
  /* Call all participants through all update phases, each using its order */
  this._clearUpdateState();
  var promise = Promise.resolve().then(function() {
    return callParticipants(function(participant, context) {
      return participant.beginUpdate(context);
    });
  }).then(function() {
    return callParticipantsInReverse(function(participant, context) {
      return participant.prepareForExtensionUpdate(context);
    });
  }).then(function() {
    return callParticipants(function(participant, context) {
      return participant.performExtensionUpdate(context);
    });
  }).then(function() {
    return callParticipants(function(participant, context) {
      return participant.performCoreUpdate(context);
    });
  }).then(function() {
    return callParticipantsInReverse(function(participant, context) {
      return participant.prepareForReductionUpdate(context);
    });
  }).then(function() {
    return callParticipants(function(participant, context) {
      return participant.performReductionUpdate(context);
    });
  }).then(function() {
    return callParticipants(function(participant, context, updated) {
      return Promise.resolve(participant.finishUpdate(context)).then(function(participantUpdated) {
        return updated || participantUpdated;
      });
    }, false);
  });
  
  /* Return the update result; with no errors, finalize the update by saving the new stable snapshot */
  promise = promise.then(function(updated) {
    this._commitUpdate();
    return {updated:updated, canceled:false};
  }.bind(this), function(e) {
    log.debug("Update process canceled");
    if (e instanceof wrm.core.UpdateService._CanceledError) {
      return {updated:false, canceled:true};
    }
    throw e;
  });
  
  /* In all cases, clear the temporary in-memory update caches (info's, contexts, etc.) */
  return promise.finally(function() {
    $jscomp$this._clearUpdateState();
  });
};

/**
 * @private
 * @template T
 * @param {!Array<string>} participantIds
 * @param {boolean} reverse
 * @param {!wrm.nav.State} state
 * @param {function(this:wrm.core.UpdateService,!wrm.core.UpdateParticipant,!wrm.core.UpdateContext,T):(!Promise<T>|T)} stepCallback
 * @param {T=} baseValue
 * @return {!Promise<T>}
 */
wrm.core.UpdateService.prototype._callParticipants = function(participantIds, reverse, state, stepCallback, baseValue) {
  var thisUpdateService = this;
  
  /* Call participants in the requested order */
  var reduceMethod = reverse ? Array.prototype.reduceRight : Array.prototype.reduce;
  return reduceMethod.call(participantIds, function(chain, participantId) {
    var info = thisUpdateService._participantInfosById[participantId];
    return chain.then(function(previousValue) {
      var context = thisUpdateService._getUpdateContext(info.id, state);
      return stepCallback.call(thisUpdateService, info.participant, context, previousValue);
    });
  }, Promise.resolve(baseValue)).then(function(result) {
    
    /* If the update was canceled, throw an error to signal that */
    if (thisUpdateService._canceled) {
      throw new wrm.core.UpdateService._CanceledError("Update canceled");
    }
    
    return result;
  });
};

/**
 * @private
 * @return {undefined}
 */
wrm.core.UpdateService.prototype._commitUpdate = function() {
  
  /* Commit changes to all stable snapshot */
  Object.keys(this._contextsById).forEach(function(id) {
    var context = this._contextsById[id];
    context.getStableSnapshot().commitChanges();
  }, this);
  
  /* Clear all update snapshot (ONLY NOW that the situation is stable) */
  Object.keys(this._contextsById).forEach(function(id) {
    var context = this._contextsById[id];
    context.getUpdateSnapshot().clear();
  }, this);
};

/**
 * @private
 * @return {undefined}
 */
wrm.core.UpdateService.prototype._clearUpdateState = function() {
  this._contextsById = {};
  this._infosById = {};
  this._canceled = false;
};

/**
 * @private
 * @param {string} id
 * @param {!wrm.nav.State} state
 */
wrm.core.UpdateService.prototype._getUpdateContext = function(id, state) {
  var manager = this.getManager();
  if (!this._participantInfosById.hasOwnProperty(id)) {
    throw new Error("Unknown participant " + id);
  }
  var info = this._participantInfosById[id];
  
  var context = this._contextsById[id];
  if (!context) {
    
    /* Retrieve the snapshots reserved to the update participant */
    var stableSnapshot = new wrm.data.WriteBackDictionary(manager.getPlatform().retrieveDictionary("_update.stable." + id));
    var updateSnapshot = manager.getPlatform().retrieveDictionary("_update.progress." + id);
    
    /* Prepare an info provider function limited only to the visible participants */
    var accessibleIds = [id].concat(info.requiredIds);
    var infoSetter = this._createInfoSetter(id);
    var infoGetter = this._createInfoGetter(id, accessibleIds);
    var canceler = this._cancelUpdate.bind(this);
    
    this._contextsById[id] = context = new wrm.core.UpdateContext(stableSnapshot, updateSnapshot, infoSetter, infoGetter, canceler, state);
  }
  return context;
};

/**
 * @private
 * @param {string} id
 * @return {function(!*)}
 */
wrm.core.UpdateService.prototype._createInfoSetter = function(id) {
  
  /**
   * @param {!*} info
   */
  function infoSetter(info) {
    this._infosById[id] = info;
  }
  
  return infoSetter.bind(this);
};

/**
 * @private
 * @param {string} defaultId
 * @param {!Array<string>} accessibleIds
 * @return {function(string=):!*}
 */
wrm.core.UpdateService.prototype._createInfoGetter = function(defaultId, accessibleIds) {
  
  /**
   * @param {string=} requestedId
   * @return {!*}
   */
  function infoGetter(requestedId) {
    requestedId = requestedId || defaultId;
    if (accessibleIds.indexOf(requestedId) < 0) {
      throw new Error("Unable to access update info of " + requestedId);
    }
    var info = this._infosById[requestedId];
    if (!info) {
      throw new Error("Update info of " + requestedId + " is not available");
    }
    return info;
  }
  
  return infoGetter.bind(this);
};

/**
 * @private
 */
wrm.core.UpdateService.prototype._cancelUpdate = function() {
  this._canceled = true;
};

/**
 * @constructor
 * @extends Error
 * @param {string=} message
 */
wrm.core.UpdateService._CanceledError = makeCustomErrorConstructor("wrm.core.UpdateService._CanceledError");

/**
 * @private
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.core.UpdateService.prototype._showErrorDialog = function(state) {
  return this.getManager().getLocalizationService().then(function(l10nService) {
    var message = l10nService.formatMessage("notification.updateError");
    var dialog = new wrm.nav.Dialog(message, wrm.nav.Dialog.Flavor.NEGATIVE, [{label:l10nService.formatMessage("dialog.button.Exit"), value:0}]);
    return state.presentDialog(dialog);
  });
};

/**
 * @private
 * @param {boolean} running
 * @param {!wrm.nav.State} state
 */
wrm.core.UpdateService.prototype._reportUpdateProgress = function(running, state) {
  var message = running ? this._l10nService.formatMessage("notification.updateProgress") : null;
  state.reportProgress(new wrm.nav.Progress(message));
};




//== wrm/core/View.js =========================================================


/**
 * @interface
 */
wrm.core.View = function() {
};

/**
 * @type {boolean}
 */
wrm.core.View.prototype.updating;

/**
 * @return {undefined}
 */
wrm.core.View.prototype.applyChanges = function() {
};




//== wrm/data/BlobReference.js ================================================



/**
 * @internal
 * @constructor
 * @param {?string} serverFileId
 * @param {!wrm.data.AvailabilityStatus} status
 */
wrm.data.BlobReference = function(serverFileId, status) {
  
  /** @private */
  this._serverFileId = serverFileId;
  
  /** @private */
  this._status = status;
  
};

/**
 * @package
 * @return {?string}
 */
wrm.data.BlobReference.prototype.getServerFileId = function() {
  return this._serverFileId;
};

/**
 * @package
 * @return {!wrm.data.AvailabilityStatus}
 */
wrm.data.BlobReference.prototype.getStatus = function() {
  return this._status;
};




//== wrm/data/ChangeListenerOld.js ============================================


/**
 * @constructor
 * @param {!wrm.data.ChangeListener} changeListener
 */
wrm.data.ChangeListenerOld = function(changeListener) {
  
  /** @private */
  this._changeListener = changeListener;
  
  this._entityMap = {};
};

/**
 * Notifies to the wrapped listener that an instance has been inserted.
 * 
 * @param {!wrm.data.meta.Entity|wrm.data.meta.Association} entityOrAssoc Entity or Association affected by the change.
 * @param {!Object<string,string>|Array<string>} values The values that were inserted.
 */
wrm.data.ChangeListenerOld.prototype.instanceInserted = function(entityOrAssoc, values) {
  var thisListener = this;
  var newListener = null;
  if (entityOrAssoc instanceof wrm.data.meta.Entity) {
    var entity = (entityOrAssoc);
    newListener = thisListener._changeListener.getEntityListener(entity);
    
    var valuesForNewListener = thisListener._mapValuesForEntity(entity, newListener.tracked, values);
    newListener.afterInsert(valuesForNewListener);
  }
};

/**
 * Notifies to the wrapped listener that an instance has been updated.
 * 
 * @param {!wrm.data.meta.Entity|wrm.data.meta.Association} entityOrAssoc Entity or Association affected by the change.
 * @param {!Object<string,string>|Array<string>} oldValues The old values that were updated.
 * @param {!Object<string,string>|Array<string>} values The new values that were updated.
 */
wrm.data.ChangeListenerOld.prototype.instanceUpdated = function(entityOrAssoc, oldValues, values) {
  var thisListener = this;
  var newListener = null;
  if (entityOrAssoc instanceof wrm.data.meta.Entity) {
    var entity = (entityOrAssoc);
    newListener = thisListener._changeListener.getEntityListener(entity);
    
    var valuesForNewListener = thisListener._mapValuesForEntity(entity, newListener.tracked, values);
    var oldValuesForNewListener = thisListener._mapValuesForEntity(entity, newListener.trackedOld, oldValues);
    newListener.afterUpdate(oldValuesForNewListener, valuesForNewListener);
  }
};

/**
 * Notifies to the wrapped listener that an instance has been inserted.
 * 
 * @param {!wrm.data.meta.Entity|wrm.data.meta.Association} entityOrAssoc Entity or Association affected by the change.
 * @param {!Object<string,string>|Array<string>} values The values that were deleted.
 */
wrm.data.ChangeListenerOld.prototype.instanceDeleted = function(entityOrAssoc, values) {
  var thisListener = this;
  var newListener = null;
  if (entityOrAssoc instanceof wrm.data.meta.Entity) {
    var entity = (entityOrAssoc);
    newListener = thisListener._changeListener.getEntityListener(entity);
    
    var valuesForNewListener = thisListener._mapValuesForEntity(entity, newListener.trackedOld, values);
    newListener.afterDelete(valuesForNewListener);
  }
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {Object<string,string>|Array<string>|undefined} tracked
 * @param {Object<string,string>|Array<string>} values
 * @return {!Object<string,string>}
 */
wrm.data.ChangeListenerOld.prototype._mapValuesForEntity = function(entity, tracked, values) {
  var mappedValues = {};
  var thisEntityMap = this._entityMap;
  if (tracked !== undefined && tracked !== null) {
    Object.keys(tracked).forEach(function(propertyKeyId) {
      var propertyKeyValue = tracked[propertyKeyId];
      if (values.hasOwnProperty(propertyKeyValue)) {
        mappedValues[propertyKeyValue] = values[propertyKeyValue];
      } else {
        try {
          var property = thisEntityMap[entity.getId() + "#" + propertyKeyValue];
          if (property === undefined) {
            property = entity.getProperty(propertyKeyValue, false);
            thisEntityMap[entity.getId() + "#" + propertyKeyValue] = property;
          }
          var propertyKeyName = property.getName();
          mappedValues[propertyKeyValue] = values[propertyKeyName];
        } catch (e) {
          mappedValues[propertyKeyValue] = values[propertyKeyValue];
        }
      }
    });
  }
  
  return mappedValues;
};




//== wrm/data/ChangeTracker.js ================================================


/**
 * @interface Interface of an object that can listen for changes query execution.
 */
wrm.data.ChangeTracker = function() {
};

/**
 * Notifies that an instance has been inserted.
 * 
 * @param {!Object} newInstance Instance that was inserted.
 */
wrm.data.ChangeTracker.prototype.instanceInserted = ABSTRACT_METHOD;

/**
 * Notifies that an instance has been updated.
 * 
 * @param {!Object} oldInstance Instance that was updated, in its previous state.
 * @param {!Object} newInstance Instance that was updated, in its new state.
 */
wrm.data.ChangeTracker.prototype.instanceUpdated = ABSTRACT_METHOD;

/**
 * Notifies that an instance has been deleted.
 * 
 * @param {!Object} oldInstance Instance that was deleted.
 */
wrm.data.ChangeTracker.prototype.instanceDeleted = ABSTRACT_METHOD;




//== wrm/data/ContentType.js ==================================================


/**
 * @package
 * @constructor
 * @param {string} type
 * @param {?string} subType
 * @param {{fileNameSuffix:?string}} info
 */
wrm.data.ContentType = function(type, subType, info) {
  
  /** @private */
  this._type = type;
  
  /** @private */
  this._subType = subType;
  
  /** @private */
  this._info = info;
};

/**
 * @return {string}
 */
wrm.data.ContentType.prototype.getName = function() {
  return wrm.data.ContentType._computeName(this._type, this._subType);
};

/**
 * @private
 * @param {string} type
 * @param {?string} subType
 * @return {string}
 */
wrm.data.ContentType._computeName = function(type, subType) {
  return subType ? type + "/" + subType : type;
};

/**
 * @return {string}
 */
wrm.data.ContentType.prototype.getType = function() {
  return this._type;
};

/**
 * @return {?string}
 */
wrm.data.ContentType.prototype.getSubType = function() {
  return this._subType;
};

/**
 * @return {?string}
 */
wrm.data.ContentType.prototype.getFileNameSuffix = function() {
  return this._info.fileNameSuffix;
};

/** @override */
wrm.data.ContentType.prototype.toString = function() {
  return this.getName();
};

/*
 * Known types registry
 */

/**
 * @private
 * @type {!Object.<string,!wrm.data.ContentType>}
 */
wrm.data.ContentType._BY_NAME = {};

/**
 * @private
 * @type {!Object.<string,!wrm.data.ContentType>}
 */
wrm.data.ContentType._BY_SUFFIX = {};

/**
 * @package
 * @param {!wrm.data.ContentType} contentType
 */
wrm.data.ContentType.register = function(contentType) {
  var BY_NAME = wrm.data.ContentType._BY_NAME;
  var BY_SUFFIX = wrm.data.ContentType._BY_SUFFIX;
  
  var name = contentType.getName();
  var suffix = contentType.getFileNameSuffix();
  if (BY_NAME.hasOwnProperty(name)) {
    throw new Error("Content type '" + name + "' is already registered");
  }
  if (suffix && !BY_SUFFIX.hasOwnProperty(suffix)) {
    BY_SUFFIX[suffix] = contentType;
  }
  BY_NAME[name] = contentType;
};

/**
 * @package
 * @param {?string} contentTypeRef
 * @param {string=} defaultContentTypeRef
 * @return {!wrm.data.ContentType}
 */
wrm.data.ContentType.lookup = function(contentTypeRef, defaultContentTypeRef) {
  var ContentType = wrm.data.ContentType;
  var BY_NAME = ContentType._BY_NAME;
  
  /* Parse content type reference, extracting the various parts */
  var type = null, subType = null;
  var m = /^(.+?)(?:\/(.+?))?(?:\s*;.*)?$/.exec(contentTypeRef);
  if (m) {
    type = m[1];
    subType = m[2];
  }
  
  var result = null;
  if (subType && type) {
    result = BY_NAME[ContentType._computeName(type, subType)];
  }
  if (!result && type) {
    result = BY_NAME[ContentType._computeName(type, null)];
  }
  if (!result) {
    if (defaultContentTypeRef) {
      return ContentType.lookup(defaultContentTypeRef);
    }
    throw new Error("Unknown content type '" + contentTypeRef + "'");
  }
  
  return result;
};

/**
 * @param {string} suffix
 * @return {?wrm.data.ContentType}
 */
wrm.data.ContentType.retrieveContentTypeBySuffix = function(suffix) {
  return wrm.data.ContentType._BY_SUFFIX[suffix] || null;
};

/**
 * @param {!Array<string>} candidates
 * @return {?wrm.data.ContentType}
 */
wrm.data.ContentType.retrieveBestContentType = function(candidates) {
  var finalCandidateContentType = null;
  candidates.forEach(function(candidate) {
    if (candidate != null) {
      var candidateContentType = wrm.data.ContentType.lookup(candidate, "application/octet-stream");
      if (finalCandidateContentType === null) {
        finalCandidateContentType = candidateContentType;
      } else {
        if (finalCandidateContentType.getSubType() === null) {
          if (candidateContentType.getSubType() !== null) {
            finalCandidateContentType = candidateContentType;
          }
        } else {
          if (finalCandidateContentType.getSubType() === "octet-stream") {
            finalCandidateContentType = candidateContentType;
          }
        }
      }
    }
  });
  
  return finalCandidateContentType;
};

/*
 * Known Content Types
 */

(function() {
  var ContentType = wrm.data.ContentType;
  [new ContentType("application", "doc", {fileNameSuffix:".doc"}), new ContentType("application", "gzip", {fileNameSuffix:".gz"}), new ContentType("application", "javascript", {fileNameSuffix:".js"}), new ContentType("application", "msword", {fileNameSuffix:".doc"}), new ContentType("application", "octet-stream", {fileNameSuffix:".bin"}), new ContentType("application", "pdf", {fileNameSuffix:".pdf"}), new ContentType("application", "vnd.adobe.flash-movie", {fileNameSuffix:".swf"}), new ContentType("application", 
  "vnd.ms-excel", {fileNameSuffix:".xls"}), new ContentType("application", "vnd.ms-powerpoint", {fileNameSuffix:".ppt"}), new ContentType("application", "vnd.oasis.opendocument.presentation", {fileNameSuffix:".odp"}), new ContentType("application", "vnd.oasis.opendocument.spreadsheet", {fileNameSuffix:".ods"}), new ContentType("application", "vnd.oasis.opendocument.text", {fileNameSuffix:".odt"}), new ContentType("application", "vnd.openxmlformats-officedocument.presentationml.presentation", {fileNameSuffix:".pptx"}), 
  new ContentType("application", "vnd.openxmlformats-officedocument.spreadsheetml.sheet", {fileNameSuffix:".xlsx"}), new ContentType("application", "vnd.openxmlformats-officedocument.wordprocessingml.document", {fileNameSuffix:".docx"}), new ContentType("application", "x-7z-compressed", {fileNameSuffix:".7z"}), new ContentType("application", "x-bzpdf", {fileNameSuffix:".pdf"}), new ContentType("application", "x-gzpdf", {fileNameSuffix:".pdf"}), new ContentType("application", "x-pdf", {fileNameSuffix:".pdf"}), 
  new ContentType("application", "x-rar-compressed", {fileNameSuffix:".rar"}), new ContentType("application", "x-shockwave-flash", {fileNameSuffix:".swf"}), new ContentType("application", "x-tar", {fileNameSuffix:".tar"}), new ContentType("application", "xml", {fileNameSuffix:".xml"}), new ContentType("application", "zip", {fileNameSuffix:".zip"}), new ContentType("audio", null, {fileNameSuffix:null}), new ContentType("audio", "mpeg", {fileNameSuffix:".mp3"}), new ContentType("audio", "ogg", {fileNameSuffix:".ogg"}), 
  new ContentType("image", null, {fileNameSuffix:null}), new ContentType("image", "gif", {fileNameSuffix:".gif"}), new ContentType("image", "jpeg", {fileNameSuffix:".jpg"}), new ContentType("image", "jpg", {fileNameSuffix:".jpg"}), new ContentType("image", "png", {fileNameSuffix:".png"}), new ContentType("image", "tiff", {fileNameSuffix:".tif"}), new ContentType("image", "tiff-fx", {fileNameSuffix:".tif"}), new ContentType("text", null, {fileNameSuffix:null}), new ContentType("text", "html", {fileNameSuffix:".html"}), 
  new ContentType("text", "javascript", {fileNameSuffix:".js"}), new ContentType("text", "plain", {fileNameSuffix:".txt"}), new ContentType("text", "xml", {fileNameSuffix:".xml"}), new ContentType("video", null, {fileNameSuffix:null}), new ContentType("video", "x-matroska", {fileNameSuffix:".mkv"}), new ContentType("video", "mpeg", {fileNameSuffix:".mpg"}), new ContentType("video", "quicktime", {fileNameSuffix:".mov"}), new ContentType("video", "webm", {fileNameSuffix:".webm"})].forEach(ContentType.register);
})();




//== wrm/data/DataServiceUpdateState.js =======================================


/**
 * @constructor
 * @param {?wrm.data.meta.Metadata} originalMetadata
 * @param {!Object<number,!wrm.data.meta.Metadata>} pastExtendedMetadata
 * @param {?wrm.data.meta.Metadata} extendedMetadata
 * @param {?wrm.data.meta.MetadataDiff} extendedMetadataDiff
 * @param {!wrm.data.meta.Metadata} currentMetadata
 */
wrm.data.DataServiceUpdateState = function(originalMetadata, pastExtendedMetadata, extendedMetadata, extendedMetadataDiff, currentMetadata) {
  
  /** @private */
  this._originalMetadata = originalMetadata;
  
  /** @private */
  this._pastExtendedMetadata = pastExtendedMetadata;
  
  /** @private */
  this._extendedMetadata = extendedMetadata;
  
  /** @private */
  this._extendedMetadataDiff = extendedMetadataDiff;
  
  /** @private */
  this._currentMetadata = currentMetadata;
};

/**
 * @return {boolean}
 */
wrm.data.DataServiceUpdateState.prototype.isUpdating = function() {
  return !!this._originalMetadata && !!this._extendedMetadata && !!this._extendedMetadataDiff;
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.DataServiceUpdateState.prototype._checkUpdating = function() {
  if (!this.isUpdating()) {
    throw new Error("Not updating");
  }
};

/**
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.DataServiceUpdateState.prototype.getOriginalMetadata = function() {
  this._checkUpdating();
  return (this._originalMetadata);
};

/**
 * @package
 * @return {!Object<number,!wrm.data.meta.Metadata>}
 */
wrm.data.DataServiceUpdateState.prototype.getPastExtendedMetadata = function() {
  return this._pastExtendedMetadata;
};

/**
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.DataServiceUpdateState.prototype.getExtendedMetadata = function() {
  this._checkUpdating();
  return (this._extendedMetadata);
};

/**
 * @return {!wrm.data.meta.MetadataDiff}
 */
wrm.data.DataServiceUpdateState.prototype.getExtendedMetadataDiff = function() {
  this._checkUpdating();
  return (this._extendedMetadataDiff);
};

/**
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.DataServiceUpdateState.prototype.getCurrentMetadata = function() {
  return this._currentMetadata;
};




//== wrm/data/MetadataRegistry.js =============================================


/**
 * @package
 * @constructor
 * @param {!wrm.data.Dictionary} auxDictionary
 */
wrm.data.MetadataRegistry = function(auxDictionary) {
  
  /** @private */
  this._auxDictionary = auxDictionary;
  
  /**
   * @private
   * @type {!Object<number,!wrm.data.meta.Metadata>}
   */
  this._metadataByVersion = {};
  
  /* Always register the empty metadata set */
  this.register(wrm.data.meta.Metadata.EMPTY);
};

/**
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {boolean=} overwrite
 */
wrm.data.MetadataRegistry.prototype.register = function(metadata, overwrite) {
  var version = metadata.getVersion();
  if (!overwrite && this._metadataByVersion[version] && this._metadataByVersion[version] !== metadata) {
    throw new Error("Different metadata already registerd for version " + version);
  }
  this._metadataByVersion[version] = metadata;
};

/**
 * @param {number} metadataVersion
 * @return {number}
 */
wrm.data.MetadataRegistry.prototype.getDatabaseVersion = function(metadataVersion) {
  
  /*
   * Look for a different database version: it might be present in rare cases if the metadata version could not be used for upgrading
   * because of a change that would have been non-monotonic.
   */
  var dbVersion = this._doGetDatabaseVersion(metadataVersion);
  if (dbVersion !== null) {
    return Number(dbVersion);
  }
  
  /* Not found: assume that the metadata version was successfully used as database version */
  return metadataVersion;
};

/**
 * @param {number} dbVersion
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.MetadataRegistry.prototype.retrieveByDatabaseVersion = function(dbVersion) {
  
  /* Look in the metadata map, assuming the two versions to be equal (frequent and fast) */
  var metadata = this._metadataByVersion[dbVersion];
  if (metadata) {
    return metadata;
  }
  
  /* Reverse-lookup from the database version (rarer case) */
  var foundMetadataVersion = this._doGetMetadataVersion(dbVersion);
  if (foundMetadataVersion !== null) {
    return this._metadataByVersion[foundMetadataVersion];
  }
  
  throw new Error("Unknown metadata for database version " + dbVersion);
};

/**
 * @param {number} metadataVersion
 * @param {number} dbVersion
 */
wrm.data.MetadataRegistry.prototype.initDatabaseVersion = function(metadataVersion, dbVersion) {
  
  /* Check for incoherences caused by the new version mapping */
  if (this._doGetDatabaseVersion(metadataVersion) !== null) {
    throw new Error("Version " + metadataVersion + " already mapped to the database");
  }
  if (this._doGetMetadataVersion(dbVersion) !== null) {
    throw new Error("Database version " + dbVersion + " already mapped to metadata");
  }
  
  this._auxDictionary.set("_versions." + metadataVersion, String(dbVersion));
};

/*
 * Version number mapping
 */

/**
 * @param {number} metadataVersion
 * @return {?number}
 */
wrm.data.MetadataRegistry.prototype._doGetDatabaseVersion = function(metadataVersion) {
  
  /* Look for a mapping in the auxiliary dictionary */
  var dbVersionString = this._auxDictionary.get("_versions." + metadataVersion);
  if (dbVersionString) {
    return Number(dbVersionString);
  }
  
  return null;
};

/**
 * @param {number} dbVersion
 * @return {?number}
 */
wrm.data.MetadataRegistry.prototype._doGetMetadataVersion = function(dbVersion) {
  var foundMetadataVersion = null;
  
  /*
   * Search for a database version among the ones corresponding to the known metadata sets. NOT USING A MAP to be sure to use fresh
   * information form the auxiliary storage. This should not be a problem performance-wise because the case is rare.
   */
  Object.keys(this._metadataByVersion).forEach(function(version) {
    version = Number(version);
    if (this._doGetDatabaseVersion(version) === dbVersion) {
      if (foundMetadataVersion === null) {
        foundMetadataVersion = version;
      } else {
        throw new Error("Found multiple metadata for database version " + dbVersion);
      }
    }
  }, this);
  
  return foundMetadataVersion;
};




//== wrm/data/XDMetadata.js ===================================================


/**
 * @package
 * @constructor
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {?wrm.data.meta.MigrationWay} migrationWay
 * @param {number} dbVersion
 */
wrm.data.XDMetadata = function(metadata, migrationWay, dbVersion) {
  
  /** @private */
  this._migrationWay = migrationWay !== null ? migrationWay : wrm.data.meta.MigrationWay.STAYING;
  
  /**
   * @private
   * @type {!xdata.schema.Schema}
   */
  this._schema = new xdata.schema.Schema(wrm.data.XDMetadata._createSchemaConfig(metadata, this._extractId.bind(this)));
  
  /** @private */
  this._version = dbVersion;
};

/**
 * @private
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {function(!wrm.data.meta.Element)} extractId
 * @return {!Object}
 */
wrm.data.XDMetadata._createSchemaConfig = function(metadata, extractId) {
  var entitiesConfig = wrm.data.XDMetadata._createEntitiesSchemaConfig(metadata, extractId);
  var relationshipsConfig = wrm.data.XDMetadata._createRelationshipsSchemaConfig(metadata, extractId);
  return {"typeHandlers":wrm.data.XDTypeHandlers.MAP, "entities":entitiesConfig, "relationships":relationshipsConfig};
};

/**
 * @private
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {function(!wrm.data.meta.Element)} extractId
 * @return {!Object}
 */
wrm.data.XDMetadata._createEntitiesSchemaConfig = function(metadata, extractId) {
  var config = {};
  
  /*
   * Create an entity for each REGULAR and AUXILIARY entity. Other types of entities can be skipped because they do not model real
   * data. For example, bridge entities are not needed by XData because it handles many-to-many relationships transparently.
   */
  metadata.getEntities().forEach(function(entity) {
    if (!(entity instanceof wrm.data.meta.RegularEntity) && !(entity instanceof wrm.data.meta.AuxEntity)) {
      return;
    }
    config[entity.getSetName()] = wrm.data.XDMetadata._createEntitySchemaConfig(entity, extractId);
  });
  
  return config;
};

/**
 * @private
 * @param {!wrm.data.meta.Entity} entity
 * @param {function(!wrm.data.meta.Element)} extractId
 * @return {!Object}
 */
wrm.data.XDMetadata._createEntitySchemaConfig = function(entity, extractId) {
  
  /* Create an attribute for each attribute of the entity */
  var attributesConfig = {}, indexesConfig = [];
  entity.getAttributes().forEach(function(attr) {
    var typeModifier = attr.isOnFileSystem() ? "fs" : undefined;
    attributesConfig[attr.getName()] = {"type":wrm.data.XDTypeHandlers.getName(attr.getType(), typeModifier), "key":attr.isKey(), "identity":extractId(attr)};
    
    /* Also create a unique index if the attribute is indexed */
    if (attr.isIndexed()) {
      indexesConfig.push({"unique":true, "attributes":attr.getName()});
    }
  });
  
  /* Create a role for each NEAR role of attached associations */
  var rolesConfig = {};
  entity.getRoles().forEach(function(role) {
    rolesConfig[role.getName()] = extractId(role.getAssociation()) + "." + extractId(role);
  });
  
  return {"attributes":attributesConfig, "indexes":indexesConfig, "roles":rolesConfig, "identity":extractId(entity)};
};

/**
 * @private
 * @param {!wrm.data.meta.Metadata} metadata
 * @param {function(!wrm.data.meta.Element)} extractId
 * @return {!Object}
 */
wrm.data.XDMetadata._createRelationshipsSchemaConfig = function(metadata, extractId) {
  var config = {};
  
  /*
   * Create a relationship for each REGULAR association. Other types of associations can be skipped because they do not model real
   * data. For example, many-to-many hemi-associations are not needed because XData handles that case transparently.
   */
  metadata.getAssociations().forEach(function(assoc) {
    if (!(assoc instanceof wrm.data.meta.RegularAssociation)) {
      return;
    }
    config[extractId(assoc)] = wrm.data.XDMetadata._createRelationshipSchemaConfig(assoc, extractId);
  });
  
  return config;
};

/**
 * @private
 * @param {!wrm.data.meta.Association} assoc
 * @param {function(!wrm.data.meta.Element)} extractId
 * @return {!Object}
 */
wrm.data.XDMetadata._createRelationshipSchemaConfig = function(assoc, extractId) {
  var bridgeEntity = assoc.getBridgeEntity();
  
  /* Function for configuring a single relationship role */
  function createRoleConfig(role) {
    var roleConfig = {};
    roleConfig["cardinality"] = role.getInverseRole().isMany() ? "N" : "1";
    var roleProviderConfig = {};
    if (bridgeEntity) {
      var bridgeRole = role === assoc.getRole1() ? bridgeEntity.getRole1() : bridgeEntity.getRole2();
      roleProviderConfig["websql.bridgeColumnName." + bridgeRole.getInverseEntity().getKeyAttribute().getName()] = bridgeRole.getForeignKeyName();
    } else {
      if (role.isForeignKey()) {
        roleProviderConfig["websql.collapsedSide"] = true;
        roleProviderConfig["websql.columnName." + role.getInverseEntity().getKeyAttribute().getName()] = role.getForeignKeyName();
      }
    }
    roleConfig["provider"] = roleProviderConfig;
    return roleConfig;
  }
  
  /* Configure the relationship with the two roles */
  var rolesConfig = {};
  rolesConfig[extractId(assoc.getRole1())] = createRoleConfig(assoc.getRole1());
  rolesConfig[extractId(assoc.getRole2())] = createRoleConfig(assoc.getRole2());
  var providerConfig = {};
  if (bridgeEntity) {
    providerConfig["websql.bridgeTableName"] = assoc.getBridgeEntity().getSetName();
  }
  
  return {"roles":rolesConfig, "provider":providerConfig};
};

/**
 * @private
 * @param {!wrm.data.meta.Element} element
 * @return {string}
 */
wrm.data.XDMetadata.prototype._extractId = function(element) {
  var MigrationWay = wrm.data.meta.MigrationWay;
  var elementMigrationWay = element.getMigrationWay();
  
  /* When "staying", no other migration is allowed (the metadata has to be stable) */
  if (this._migrationWay === MigrationWay.STAYING) {
    if (elementMigrationWay !== this._migrationWay) {
      throw new Error("Found migrating element: " + element);
    }
    return element.getId();
  }
  
  /*
   * Use the migration id during the first part of the overall migration (when "arriving"), otherwise use the common id. In this way,
   * the migrating elements will "stand out" and appear different from non-migrating ones, including their previous/next selves.
   */
  if (this._migrationWay === MigrationWay.ARRIVING) {
    return element.getMigrationTempId() || element.getId();
  }
  return element.getId();
};

/**
 * @return {!xdata.schema.Schema}
 */
wrm.data.XDMetadata.prototype.getSchema = function() {
  return this._schema;
};

/**
 * @return {number}
 */
wrm.data.XDMetadata.prototype.getVersion = function() {
  return this._version;
};




//== wrm/data/meta/EntityDiff.js ==============================================


/**
 * @constructor
 * @param {!Object} descr
 */
wrm.data.meta.EntityDiff = function(descr) {
  
  /**
   * @private
   * @type {string}
   */
  this._id = descr["id"];
  
  /** @private */
  this._attributes = this._createGroup(descr["attributes"] || {});
  
  /** @private */
  this._roles = this._createGroup(descr["roles"] || {});
};

/**
 * @private
 * @param {!Object} descr
 * @return {{added:!Array<string>, removed:!Array<string>, replaced:!Array<{older:string,newer:string}>}}
 */
wrm.data.meta.EntityDiff.prototype._createGroup = function(descr) {
  return {added:(descr["added"] || []).slice(), removed:(descr["removed"] || []).slice(), replaced:(descr["replaced"] || []).map(function(replacement) {
    return {older:replacement["older"], newer:replacement["newer"]};
  })};
};

/**
 * @return {string}
 */
wrm.data.meta.EntityDiff.prototype.getId = function() {
  return this._id;
};

/**
 * @return {!Array<string>}
 */
wrm.data.meta.EntityDiff.prototype.getAddedAttributesIds = function() {
  return this._attributes.added;
};

/**
 * @return {!Array<string>}
 */
wrm.data.meta.EntityDiff.prototype.getRemovedAttributesIds = function() {
  return this._attributes.removed;
};

/**
 * @return {!Array<{older:string,newer:string}>}
 */
wrm.data.meta.EntityDiff.prototype.getReplacedAttributesIdPairs = function() {
  return this._attributes.replaced;
};

/**
 * @return {!Array<string>}
 */
wrm.data.meta.EntityDiff.prototype.getAddedRolesIds = function() {
  return this._roles.added;
};

/**
 * @return {!Array<string>}
 */
wrm.data.meta.EntityDiff.prototype.getRemovedRolesIds = function() {
  return this._roles.removed;
};

/**
 * @return {!Array<{older:string,newer:string}>}
 */
wrm.data.meta.EntityDiff.prototype.getReplacedRolesIdPairs = function() {
  return this._roles.replaced;
};




//== wrm/data/meta/MetadataDiff.js ============================================



/**
 * @constructor
 * @param {!Object} descr
 */
wrm.data.meta.MetadataDiff = function(descr) {
  
  /**
   * @private
   * @type {!Object}
   */
  this._descriptor = wrm.data.cloneObject(descr);
  
  /** @private */
  this._entities = this._createEntityDiffs(descr["entities"] || {});
  
  /** @private */
  this._assocs = this._createGroup(descr["associations"] || {});
};

/**
 * @private
 * @param {!Object} descr
 * @return {{added:!Array<!wrm.data.meta.EntityDiff>, removed:!Array<!wrm.data.meta.EntityDiff>,
 *         changed:!Array<!wrm.data.meta.EntityDiff>}}
 */
wrm.data.meta.MetadataDiff.prototype._createEntityDiffs = function(descr) {
  function createDiffs(descrs) {
    return descrs.map(function(entityDiffDescr) {
      return new wrm.data.meta.EntityDiff(entityDiffDescr);
    });
  }
  
  return {added:createDiffs(descr["added"] || []), removed:createDiffs(descr["removed"] || []), changed:createDiffs(descr["changed"] || [])};
};

/**
 * @private
 * @param {!Object} descr
 * @return {{added:!Array<string>, removed:!Array<string>, replaced:!Array<{older:string,newer:string}>}}
 */
wrm.data.meta.MetadataDiff.prototype._createGroup = function(descr) {
  return {added:(descr["added"] || []).slice(), removed:(descr["removed"] || []).slice(), replaced:(descr["replaced"] || []).map(function(replacement) {
    return {older:replacement["older"], newer:replacement["newer"]};
  })};
};

/**
 * @internal
 * @return {!Object}
 */
wrm.data.meta.MetadataDiff.prototype.getDescriptor = function() {
  return this._descriptor;
};

/**
 * @return {!Array<!wrm.data.meta.EntityDiff>}
 */
wrm.data.meta.MetadataDiff.prototype.getAddedEntities = function() {
  return this._entities.added;
};

/**
 * @return {!Array<!wrm.data.meta.EntityDiff>}
 */
wrm.data.meta.MetadataDiff.prototype.getRemovedEntities = function() {
  return this._entities.removed;
};

/**
 * @return {!Array<!wrm.data.meta.EntityDiff>}
 */
wrm.data.meta.MetadataDiff.prototype.getChangedEntities = function() {
  return this._entities.changed;
};

/**
 * @return {!Array<string>}
 */
wrm.data.meta.MetadataDiff.prototype.getAddedAssociationsIds = function() {
  return this._assocs.added;
};

/**
 * @return {!Array<string>}
 */
wrm.data.meta.MetadataDiff.prototype.getRemovedAssociationsIds = function() {
  return this._assocs.removed;
};

/**
 * @return {!Array<{older:string,newer:string}>}
 */
wrm.data.meta.MetadataDiff.prototype.getReplacedAssociationsIdPairs = function() {
  return this._assocs.replaced;
};




//== wrm/data/meta/MetadataComparator.js ======================================



/**
 * @internal
 * @constructor
 */
wrm.data.meta.MetadataComparator = function() {
};

/**
 * @param {!Object} olderDescr
 * @param {!Object} newerDescr
 * @return {{metadata:!wrm.data.meta.Metadata, diff:!wrm.data.meta.MetadataDiff}}
 */
wrm.data.meta.MetadataComparator.prototype.generateExtended = function(olderDescr, newerDescr) {
  var context = new wrm.data.meta.MetadataComparator._Context(olderDescr, newerDescr);
  this._findMigrationsInMetadata(olderDescr, newerDescr, context);
  var extendedDescr = this._computeExtendedMetadataDescr(olderDescr, newerDescr, context);
  var diffDescr = this._createMetadataDiffDescr(context);
  return {metadata:new wrm.data.meta.Metadata(extendedDescr), diff:new wrm.data.meta.MetadataDiff(diffDescr)};
};

/*
 * Migration collection
 */

/**
 * @private
 * @param {!Object} older
 * @param {!Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._findMigrationsInMetadata = function(older, newer, context) {
  wrm.data.meta.MetadataComparator._checkMetadataDescr(older);
  wrm.data.meta.MetadataComparator._checkMetadataDescr(newer);
  
  /* The metadata itself does never require migration */
  
  /* Find migrations in entities */
  var olderEntityDescrs = older && older["entities"];
  var newerEntityDescrs = newer && newer["entities"];
  this._findMigrations([], olderEntityDescrs, newerEntityDescrs, this._findMigrationsInEntity.bind(this), context);
  
  /* Find migrations in associations */
  var olderAssocDescrs = older && older["associations"];
  var newerAssocDescrs = newer && newer["associations"];
  this._findMigrations([], olderAssocDescrs, newerAssocDescrs, this._findMigrationsInAssociation.bind(this), context);
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {?Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._findMigrationsInEntity = function(id, older, newer, context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  
  wrm.data.meta.MetadataComparator._checkEntityDescr(older);
  wrm.data.meta.MetadataComparator._checkEntityDescr(newer);
  
  /* An entity is migrating only when added/removed */
  var migration = !older ? MigrationType.ADDITION : !newer ? MigrationType.REMOVAL : null;
  
  /* Find migrations in attributes */
  var olderAttrDescrs = older && older["attributes"];
  var newerAttrDescrs = newer && newer["attributes"];
  this._findMigrations([id], olderAttrDescrs, newerAttrDescrs, this._findMigrationsInAttribute.bind(this), context);
  
  /* Find migrations in roles */
  var olderRoleDescrs = older && older["roles"];
  var newerRoleDescrs = newer && newer["roles"];
  this._findMigrations([id], olderRoleDescrs, newerRoleDescrs, this._findMigrationsInRole.bind(this), context);
  
  if (migration !== null) {
    if (older) {
      this._markEntityForMigration(id, older, true, migration, context);
    }
    if (newer) {
      this._markEntityForMigration(id, newer, false, migration, context);
    }
  }
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {?Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._findMigrationsInAttribute = function(id, older, newer, context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  
  wrm.data.meta.MetadataComparator._checkAttributeDescr(older);
  wrm.data.meta.MetadataComparator._checkAttributeDescr(newer);
  
  /* An attribute is migrating when added/removed (also along with the PARENT ENTITY) */
  var migration = !older ? MigrationType.ADDITION : !newer ? MigrationType.REMOVAL : null;
  
  /* Even if staying, determine whether something has changed that requires migration */
  if (migration === null) {
    ["type", "key", "onFileSystem"].forEach(function(key) {
      if (migration === null && older[key] !== newer[key]) {
        migration = MigrationType.CHANGE;
      }
    }, this);
  }
  if (migration === null && (older["meta"] || newer["meta"])) {
    (function() {
      var metaDiff = this._computeObjectsDiff(older["meta"] || {}, newer["meta"] || {});
      if (metaDiff.added.length > 0 || metaDiff.removed.length > 0) {
        migration = MigrationType.CHANGE;
      } else {
        metaDiff.replaced.forEach(function(replacement) {
          wrm.data.meta.MetadataComparator._checkMetaAttributeDescr(replacement.oldDescr);
          wrm.data.meta.MetadataComparator._checkMetaAttributeDescr(replacement.newDescr);
          if (replacement.oldDescr["type"] !== replacement.newDescr["type"]) {
            migration = MigrationType.CHANGE;
          }
        }, this);
      }
    }).call(this);
  }
  
  var nonNullMigration = migration;
  if (nonNullMigration !== null) {
    if (older) {
      this._markAttributeForMigration(id, older, true, nonNullMigration, context);
    }
    if (newer) {
      this._markAttributeForMigration(id, newer, false, nonNullMigration, context);
    }
  }
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {?Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._findMigrationsInRole = function(id, older, newer, context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  
  wrm.data.meta.MetadataComparator._checkRoleDescr(older);
  wrm.data.meta.MetadataComparator._checkRoleDescr(newer);
  
  /* A role is migrating when added/removed (also along with the PARENT ENTITY) */
  var migration = !older ? MigrationType.ADDITION : !newer ? MigrationType.REMOVAL : null;
  
  /* Even if staying, determine whether something has changed that requires migration */
  if (migration === null && older["many"] !== newer["many"]) {
    migration = MigrationType.CHANGE;
  }
  
  if (migration !== null) {
    if (older) {
      this._markRoleForMigration(id, older, true, migration, context);
    }
    if (newer) {
      this._markRoleForMigration(id, newer, false, migration, context);
    }
  }
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {?Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._findMigrationsInAssociation = function(id, older, newer, context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  
  wrm.data.meta.MetadataComparator._checkAssociationDescr(older);
  wrm.data.meta.MetadataComparator._checkAssociationDescr(newer);
  
  /* An association is migrating only when added/removed */
  var migration = !older ? MigrationType.ADDITION : !newer ? MigrationType.REMOVAL : null;
  
  if (migration !== null) {
    if (older) {
      this._markAssociationForMigration(id, older, true, migration, context);
    }
    if (newer) {
      this._markAssociationForMigration(id, newer, false, migration, context);
    }
  }
};

/**
 * @private
 * @param {!Array<string>} idPathPrefix
 * @param {?Object<string,!Object>} olderDescrs
 * @param {?Object<string,!Object>} newerDescrs
 * @param {function(string,?Object,?Object,!wrm.data.meta.MetadataComparator._Context)} findElementMigrations
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._findMigrations = function(idPathPrefix, olderDescrs, newerDescrs, findElementMigrations, context) {
  var diff = this._computeObjectsDiff(olderDescrs || {}, newerDescrs || {});
  diff.added.forEach(function(addition) {
    findElementMigrations(addition.id, null, addition.descr, context);
    context.saveDescriptors(idPathPrefix.concat(addition.id), null, addition.descr);
  }, this);
  diff.replaced.forEach(function(replacement) {
    findElementMigrations(replacement.id, replacement.oldDescr, replacement.newDescr, context);
    context.saveDescriptors(idPathPrefix.concat(replacement.id), replacement.oldDescr, replacement.newDescr);
  }, this);
  diff.removed.forEach(function(removal) {
    findElementMigrations(removal.id, removal.descr, null, context);
    context.saveDescriptors(idPathPrefix.concat(removal.id), removal.descr, null);
  }, this);
};

/**
 * @private
 * @param {string} id
 * @param {!Object} descr
 * @param {boolean} older
 * @param {!wrm.data.meta.MetadataComparator._MigrationType} migration
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._markEntityForMigration = function(id, descr, older, migration, context) {
  context.markForMigration([id], migration);
};

/**
 * @private
 * @param {string} id
 * @param {!Object} descr
 * @param {boolean} older
 * @param {!wrm.data.meta.MetadataComparator._MigrationType} migration
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._markAttributeForMigration = function(id, descr, older, migration, context) {
  var entityId = context.getParentEntityId(id, older);
  if (!context.markForMigration([entityId, id], migration)) {
    return;
  }
  
  /* If key, cascade to all roles of the parent entity */
  if (descr["key"] === true) {
    var entityDescr = context.get(entityId, older);
    var entityRolesDescr = entityDescr["roles"];
    if (entityRolesDescr) {
      Object.keys(entityRolesDescr).forEach(function(roleId) {
        this._markRoleForMigration(roleId, context.get(roleId, older), older, wrm.data.meta.MetadataComparator._MigrationType.CHANGE, context);
      }, this);
    }
  }
};

/**
 * @private
 * @param {string} id
 * @param {!Object} descr
 * @param {boolean} older
 * @param {!wrm.data.meta.MetadataComparator._MigrationType} migration
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._markRoleForMigration = function(id, descr, older, migration, context) {
  var entityId = context.getParentEntityId(id, older);
  if (!context.markForMigration([entityId, id], migration)) {
    return;
  }
  
  /* Cascade on the inverse role and the parent association */
  var inverseRoleId = descr["inverse"];
  var inverseRoleDescr = context.get(inverseRoleId, older);
  this._markRoleForMigration(inverseRoleId, inverseRoleDescr, older, migration, context);
  var assocId = context.getParentAssociationId(id, older);
  var assocDescr = context.get(assocId, older);
  this._markAssociationForMigration(assocId, assocDescr, older, migration, context);
};

/**
 * @private
 * @param {string} id
 * @param {!Object} descr
 * @param {boolean} older
 * @param {!wrm.data.meta.MetadataComparator._MigrationType} migration
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 */
wrm.data.meta.MetadataComparator.prototype._markAssociationForMigration = function(id, descr, older, migration, context) {
  if (!context.markForMigration([id], migration)) {
    return;
  }
  
  /* Cascade on connected entity roles */
  descr["roles"].forEach(function(roleId) {
    var roleDescr = context.get(roleId, older);
    this._markRoleForMigration(roleId, roleDescr, older, migration, context);
  }, this);
};

/**
 * @private
 * @param {!Object<string,!Object>|undefined} olderById
 * @param {!Object<string,!Object>|undefined} newerById
 * @return {{added:!Array<{id:string,descr:!Object}>, replaced:!Array<{id:string,oldDescr:!Object,newDescr:!Object}>,
 *         removed:!Array<{id:string,descr:!Object}>}}
 */
wrm.data.meta.MetadataComparator.prototype._computeObjectsDiff = function(olderById, newerById) {
  olderById = olderById !== undefined ? olderById : {};
  newerById = newerById !== undefined ? newerById : {};
  
  var diff = {added:[], replaced:[], removed:[]};
  
  /* Make a cross-difference of the two sets of descriptors, using IDs as identity keys */
  var oldIdsSet = {};
  Object.keys(olderById).forEach(function(id) {
    oldIdsSet[id] = true;
  });
  Object.keys(newerById).forEach(function(id) {
    if (oldIdsSet[id] === true) {
      diff.replaced.push({id:id, oldDescr:olderById[id], newDescr:newerById[id]});
      delete oldIdsSet[id];
    } else {
      diff.added.push({id:id, descr:newerById[id]});
    }
  });
  Object.keys(oldIdsSet).forEach(function(id) {
    diff.removed.push({id:id, descr:olderById[id]});
  });
  
  return diff;
};

/*
 * Descriptor extension
 */

/**
 * @private
 * @param {!Object} older
 * @param {!Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._computeExtendedMetadataDescr = function(older, newer, context) {
  
  /*
   * Use a version that is between the two versions. If the two versions are too near, use one just below the lower one (the
   * important thing is that they are different, monotonicity is a bonus)
   */
  var extendedVersion;
  var versionsDiff = newer["version"] - older["version"];
  if (Math.abs(versionsDiff) >= 2) {
    extendedVersion = older["version"] + Math.floor(versionsDiff / 2);
  } else {
    extendedVersion = Math.min(older["version"], newer["version"]) - 1;
  }
  
  /* Compute extended entities and associations */
  var extendedEntities = this._computeExtenedObjectMap([], older["entities"], newer["entities"], this._createLeavingEntityDescr.bind(this), this._createEntityDescr.bind(this), context);
  var extendedAssocs = this._computeExtenedObjectMap([], older["associations"], newer["associations"], this._createLeavingAssociationDescr.bind(this), this._createAssociationDescr.bind(this), context);
  
  var extended = {"version":extendedVersion, "entities":extendedEntities, "associations":extendedAssocs};
  this._disambiguateNamesInMetadata(extended);
  return extended;
};

/**
 * @private
 * @param {string} id
 * @param {!Object} older
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createLeavingEntityDescr = function(id, older, context) {
  
  /* Only keep essential properties (e.g. ignore server mapping */
  var leaving = wrm.util.obj.copyProperties({}, older, ["name", "setName"]);
  
  /* Compute extended attributes and roles */
  leaving["attributes"] = this._computeExtenedObjectMap([id], older["attributes"], null, this._createLeavingAttributeDescr.bind(this), this._createAttributeDescr.bind(this), context);
  leaving["roles"] = this._computeExtenedObjectMap([id], older["roles"], null, this._createLeavingRoleDescr.bind(this), this._createRoleDescr.bind(this), context);
  
  return leaving;
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {!Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createEntityDescr = function(id, older, newer, context) {
  
  /* Use the newer properties */
  var arriving = wrm.util.obj.copyProperties({}, newer, ["name", "setName", "serverName", "serverReadable", "disableDataRestore", "auxEntity", "dirtyName", "deleteTimestampName"]);
  
  /* Compute extended attributes and roles */
  arriving["attributes"] = this._computeExtenedObjectMap([id], older && older["attributes"], newer["attributes"], this._createLeavingAttributeDescr.bind(this), this._createAttributeDescr.bind(this), context);
  arriving["roles"] = this._computeExtenedObjectMap([id], older && older["roles"], newer["roles"], this._createLeavingRoleDescr.bind(this), this._createRoleDescr.bind(this), context);
  
  this._disambiguateNamesInEntity(arriving);
  return arriving;
};

/**
 * @private
 * @param {string} id
 * @param {!Object} older
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createLeavingAttributeDescr = function(id, older, context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  
  /* Only keep essential properties (e.g. ignore server mapping */
  var leaving = wrm.util.obj.copyProperties({}, older, ["name", "type", "indexed", "onFileSystem", "meta"]);
  
  /* Keep the key configuration only if the attribute is being removed along with its entity */
  var entityId = context.getParentEntityId(id, true);
  var entityMigration = context.getDelta([entityId]).migration;
  var attrMigration = context.getDelta([entityId, id]).migration;
  if (entityMigration === attrMigration && entityMigration === MigrationType.REMOVAL) {
    leaving["key"] = older["key"];
  }
  
  return leaving;
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {!Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createAttributeDescr = function(id, older, newer, context) {
  
  /* Use the newer properties */
  var arriving = wrm.util.obj.copyProperties({}, newer, ["name", "type", "key", "indexed", "createTS", "updateTS", "onFileSystem", "meta", "serverName", "trackerName", "dirtyName", "serverKey"]);
  
  return arriving;
};

/**
 * @private
 * @param {string} id
 * @param {!Object} older
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createLeavingRoleDescr = function(id, older, context) {
  
  /* Only keep essential properties (e.g. ignore server mapping */
  var leaving = wrm.util.obj.copyProperties({}, older, ["name", "foreignKeyName", "many", "bridgeHeadRole"]);
  
  /* Re-link the inverse role to its LEAVING copy (it exists because of migration cascading rules) */
  leaving["inverse"] = this._computeLeavingId(older["inverse"]);
  
  return leaving;
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {!Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createRoleDescr = function(id, older, newer, context) {
  
  /* Use the newer properties */
  var arriving = wrm.util.obj.copyProperties({}, newer, ["name", "foreignKeyName", "many", "inverse", "bridgeHeadRole", "serverName", "serverTrackerName", "addTimestampName", "removeTimestampName"]);
  
  return arriving;
};

/**
 * @private
 * @param {string} id
 * @param {!Object} older
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createLeavingAssociationDescr = function(id, older, context) {
  
  /* Only keep essential properties (e.g. ignore server mapping */
  var leaving = wrm.util.obj.copyProperties({}, older, ["name", "bridgeEntity"]);
  
  /* Re-link the roles to their LEAVING copies (they exist because of migration cascading rules) */
  leaving["roles"] = older["roles"].map(this._computeLeavingId.bind(this));
  
  return leaving;
};

/**
 * @private
 * @param {string} id
 * @param {?Object} older
 * @param {!Object} newer
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createAssociationDescr = function(id, older, newer, context) {
  
  /* Use the newer properties */
  var arriving = wrm.util.obj.copyProperties({}, newer, ["name", "roles", "bridgeEntity", "serverName"]);
  
  return arriving;
};

/**
 * @private
 * @param {!Array<string>} isPathPrefix
 * @param {?Object} olderMap
 * @param {?Object} newerMap
 * @param {function(string,!Object,!wrm.data.meta.MetadataComparator._Context):!Object} leavingElementFactory
 * @param {function(string,?Object,!Object,!wrm.data.meta.MetadataComparator._Context):!Object} elementFactory
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._computeExtenedObjectMap = function(isPathPrefix, olderMap, newerMap, leavingElementFactory, elementFactory, context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  
  var extended = {};
  
  /* Process all identifiers (old, new) exactly once */
  var visitedIds = {};
  if (olderMap) {
    Object.keys(olderMap).forEach(processDelta, this);
  }
  if (newerMap) {
    Object.keys(newerMap).forEach(processDelta, this);
  }
  
  /* Function for processing a single delta exactly once */
  function processDelta(id) {
    if (visitedIds[id] === true) {
      return;
    }
    visitedIds[id] = true;
    
    var delta = context.getDelta(isPathPrefix.concat(id));
    if (delta.migration !== null) {
      
      /* Migration: compute leaving/arriving descriptors and store them */
      if (delta.oldDescr && delta.migration !== MigrationType.ADDITION) {
        this._putLeavingDescriptor(extended, id, leavingElementFactory(id, delta.oldDescr, context));
      }
      if (delta.newDescr && delta.migration !== MigrationType.REMOVAL) {
        this._putArrivingDescriptor(extended, id, elementFactory(id, delta.oldDescr, delta.newDescr, context));
      }
    } else {
      if (delta.newDescr) {
        
        /* No migration: compute an "arriving-like" version of the new descriptor */
        extended[id] = elementFactory(id, delta.oldDescr, delta.newDescr, context);
      }
    }
  }
  
  return extended;
};

/**
 * @private
 * @param {!Object} map
 * @param {string} id
 * @param {!Object} descr
 */
wrm.data.meta.MetadataComparator.prototype._putLeavingDescriptor = function(map, id, descr) {
  descr["migrationTempId"] = id;
  descr["migrationWay"] = wrm.data.meta.MigrationWay.LEAVING;
  map[this._computeLeavingId(id)] = descr;
};

/**
 * @private
 * @param {!Object} map
 * @param {string} id
 * @param {!Object} descr
 */
wrm.data.meta.MetadataComparator.prototype._putArrivingDescriptor = function(map, id, descr) {
  descr["migrationTempId"] = this._computeArrivingId(id);
  descr["migrationWay"] = wrm.data.meta.MigrationWay.ARRIVING;
  map[id] = descr;
};

/**
 * @private
 * @param {string} id
 * @return {string}
 */
wrm.data.meta.MetadataComparator.prototype._computeLeavingId = function(id) {
  return id + "@old";
};

/**
 * @private
 * @param {string} id
 * @return {string}
 */
wrm.data.meta.MetadataComparator.prototype._computeArrivingId = function(id) {
  return id + "@new";
};

/**
 * @private
 * @param {!Object} metadataDescr
 */
wrm.data.meta.MetadataComparator.prototype._disambiguateNamesInMetadata = function(metadataDescr) {
  
  /* Collect name and set name usage among entities */
  var usedEntityNames = {}, usedEntitySetNames = {}, leavingEntityDescrs = [];
  this._doCollectNameUsage(metadataDescr["entities"], "entity", "name", usedEntityNames, leavingEntityDescrs);
  this._doCollectNameUsage(metadataDescr["entities"], "entity", "setName", usedEntitySetNames, null);
  
  /* Change the entity name and set name in leaving descriptors that conflict with at least one of the other names */
  leavingEntityDescrs.forEach(function(descr) {
    var name = descr["name"];
    var setName = descr["setName"];
    if (usedEntityNames[name] === true || usedEntitySetNames[setName] === true) {
      descr["name"] = name + "_OLD";
      descr["setName"] = setName + "_OLD";
    }
  }, this);
  
  /* Collection name usage among associations */
  var usedAssocNames = {}, leavingAssocDescrs = [];
  this._doCollectNameUsage(metadataDescr["associations"], "association", "name", usedAssocNames, leavingAssocDescrs);
  
  /* Change the association name in leaving descriptors that conflict with used names */
  leavingAssocDescrs.forEach(function(descr) {
    var name = descr["name"];
    if (usedAssocNames[name] === true) {
      descr["name"] = name + "_OLD";
    }
  }, this);
};

/**
 * @private
 * @param {!Object} entityDescr
 */
wrm.data.meta.MetadataComparator.prototype._disambiguateNamesInEntity = function(entityDescr) {
  
  /* Collect name usage among properties (attributes and roles) */
  var usedNames = {}, leavingDescrs = [];
  this._doCollectNameUsage(entityDescr["attributes"], "attribute", "name", usedNames, leavingDescrs);
  this._doCollectNameUsage(entityDescr["roles"], "attribute/role", "name", usedNames, leavingDescrs);
  
  /* Change the name in leaving descriptors that conflict with used names */
  leavingDescrs.forEach(function(descr) {
    var name = descr["name"];
    if (usedNames[name] === true) {
      descr["name"] = name + "_OLD";
    }
  }, this);
};

/**
 * @private
 * @param {!Object} map
 * @param {string} label
 * @param {string} nameProperty
 * @param {!Object<string,boolean>} usedNames
 * @param {?Array<!Object>} leavingDescrs
 */
wrm.data.meta.MetadataComparator.prototype._doCollectNameUsage = function(map, label, nameProperty, usedNames, leavingDescrs) {
  var MigrationWay = wrm.data.meta.MigrationWay;
  
  /* Collect all names of ARRIVING and STAYING descriptors */
  Object.keys(map).forEach(function(key) {
    var descr = map[key];
    var name = descr[nameProperty];
    switch(this._getMigrationWay(descr)) {
      case MigrationWay.ARRIVING:
      ;
      case MigrationWay.STAYING:
        if (usedNames[name]) {
          throw new Error("Found conflicting " + label + " name '" + name + "'");
        }
        usedNames[name] = true;
        break;
      default:
        if (leavingDescrs) {
          leavingDescrs.push(descr);
        }
      ;
    }
  }, this);
};

/**
 * @private
 * @param {!Object} descr
 * @return {!wrm.data.meta.MigrationWay}
 */
wrm.data.meta.MetadataComparator.prototype._getMigrationWay = function(descr) {
  return descr["migrationWay"] || wrm.data.meta.MigrationWay.STAYING;
};

/*
 * Descriptor assertions
 */

/**
 * @private
 * @param {?Object} descr
 */
wrm.data.meta.MetadataComparator._checkMetadataDescr = function(descr) {
  if (DEBUG) {
    wrm.data.meta.MetadataComparator._checkDescrKnownKeys(descr, "metadata", ["version", "entities", "associations"]);
  }
};

/**
 * @private
 * @param {?Object} descr
 */
wrm.data.meta.MetadataComparator._checkEntityDescr = function(descr) {
  if (DEBUG) {
    wrm.data.meta.MetadataComparator._checkDescrKnownKeys(descr, "entity", ["name", "setName", "serverName", "serverReadable", "disableDataRestore", "auxEntity", "dirtyName", "deleteTimestampName", "attributes", "roles"]);
  }
};

/**
 * @private
 * @param {?Object} descr
 */
wrm.data.meta.MetadataComparator._checkAttributeDescr = function(descr) {
  if (DEBUG) {
    wrm.data.meta.MetadataComparator._checkDescrKnownKeys(descr, "attribute", ["name", "type", "key", "createTS", "updateTS", "onFileSystem", "meta", "serverName", "trackerName", "dirtyName", "serverKey", "indexed"]);
  }
};

/**
 * @private
 * @param {?Object} descr
 */
wrm.data.meta.MetadataComparator._checkMetaAttributeDescr = function(descr) {
  if (DEBUG) {
    wrm.data.meta.MetadataComparator._checkDescrKnownKeys(descr, "meta-attribute", ["name", "type"]);
  }
};

/**
 * @private
 * @param {?Object} descr
 */
wrm.data.meta.MetadataComparator._checkRoleDescr = function(descr) {
  if (DEBUG) {
    wrm.data.meta.MetadataComparator._checkDescrKnownKeys(descr, "role", ["name", "foreignKeyName", "many", "inverse", "bridgeHeadRole", "serverName", "serverTrackerName", "addTimestampName", "removeTimestampName"]);
  }
};

/**
 * @private
 * @param {?Object} descr
 */
wrm.data.meta.MetadataComparator._checkAssociationDescr = function(descr) {
  if (DEBUG) {
    wrm.data.meta.MetadataComparator._checkDescrKnownKeys(descr, "association", ["name", "roles", "bridgeEntity", "serverName"]);
  }
};

/**
 * @private
 * @param {?Object} descr
 * @param {string} label
 * @param {!Array<string>} knownKeys
 */
wrm.data.meta.MetadataComparator._checkDescrKnownKeys = function(descr, label, knownKeys) {
  if (DEBUG) {
    if (descr === null) {
      return;
    }
    var knownKeysSet = {};
    knownKeys.forEach(function(key) {
      knownKeysSet[key] = true;
    });
    Object.keys(descr).forEach(function(key) {
      if (knownKeysSet[key] !== true) {
        throw new Error("Unknown object key in " + label + " descriptor: " + key);
      }
    });
  }
};

/*
 * Metadata diff generation
 */

/**
 * @private
 * @param {!wrm.data.meta.MetadataComparator._Context} context
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator.prototype._createMetadataDiffDescr = function(context) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  var computeLeavingId = this._computeLeavingId.bind(this);
  
  /* Helper for avoiding visiting deltas multiple times */
  var visitedIds = {};
  function visit(deltaIdPath) {
    var deltaId = deltaIdPath.join("/");
    if (visitedIds[deltaId] === true) {
      return false;
    }
    visitedIds[deltaId] = true;
    return true;
  }
  
  /* Helper for integrating changes into a group */
  function addChangedElementToGroup(group, elementId, migrationType) {
    var list;
    switch(migrationType) {
      case MigrationType.ADDITION:
        list = group["added"] || (group["added"] = []);
        list.push(elementId);
        break;
      case MigrationType.REMOVAL:
        list = group["removed"] || (group["removed"] = []);
        list.push(computeLeavingId(elementId));
        break;
      case MigrationType.CHANGE:
        list = group["replaced"] || (group["replaced"] = []);
        list.push({"older":computeLeavingId(elementId), "newer":elementId});
        break;
    }
  }
  
  /* Collect differences in attributes and roles, organizing them by parent entity */    /** @type {!Object<string,{attributes:!Object, roles:!Object}>} */
  var entityChildChanges = {};
  function collectAttributeChange(older, attrId) {
    var entityId = context.getParentEntityId(attrId, older);
    var deltaIdPath = [entityId, attrId];
    if (!visit(deltaIdPath)) {
      return;
    }
    var migration = context.getDelta(deltaIdPath).migration;
    if (migration !== null) {
      var changes = entityChildChanges[entityId];
      if (!changes) {
        entityChildChanges[entityId] = changes = {attributes:{}, roles:{}};
      }
      addChangedElementToGroup(changes.attributes, attrId, migration);
    }
  }
  function collectRoleChange(older, roleId) {
    var entityId = context.getParentEntityId(roleId, older);
    var deltaIdPath = [entityId, roleId];
    if (!visit(deltaIdPath)) {
      return;
    }
    var migration = context.getDelta(deltaIdPath).migration;
    if (migration !== null) {
      var changes = entityChildChanges[entityId];
      if (!changes) {
        entityChildChanges[entityId] = changes = {attributes:{}, roles:{}};
      }
      addChangedElementToGroup(changes.roles, roleId, migration);
    }
  }
  context.getAttributeIds(false).forEach(collectAttributeChange.bind(null, false));
  context.getAttributeIds(true).forEach(collectAttributeChange.bind(null, true));
  context.getRoleIds(false).forEach(collectRoleChange.bind(null, false));
  context.getRoleIds(true).forEach(collectRoleChange.bind(null, true));
  
  /* Collect differences in associations */
  var assocChangeGroup = {};
  function collectAssociationChange(assocId) {
    var deltaIdPath = [assocId];
    if (!visit(deltaIdPath)) {
      return;
    }
    var migration = context.getDelta(deltaIdPath).migration;
    if (migration !== null) {
      addChangedElementToGroup(assocChangeGroup, assocId, migration);
    }
  }
  context.getAssociationIds(false).forEach(collectAssociationChange);
  context.getAssociationIds(true).forEach(collectAssociationChange);
  
  /* Collect differences in entities, integrating the child changes collect before */
  var entityChangeLists = {};
  function collectEntityChange(entityId) {
    var deltaIdPath = [entityId];
    if (!visit(deltaIdPath)) {
      return;
    }
    var migration = context.getDelta(deltaIdPath).migration;
    var childChanges = entityChildChanges[entityId];
    if (migration !== null || !!childChanges) {
      var list, changeId;
      if (migration === MigrationType.ADDITION) {
        list = entityChangeLists["added"] || (entityChangeLists["added"] = []);
        changeId = entityId;
      } else {
        if (migration === MigrationType.REMOVAL) {
          list = entityChangeLists["removed"] || (entityChangeLists["removed"] = []);
          changeId = computeLeavingId(entityId);
        } else {
          list = entityChangeLists["changed"] || (entityChangeLists["changed"] = []);
          changeId = entityId;
        }
      }
      list.push({"id":changeId, "attributes":childChanges && childChanges.attributes, "roles":childChanges && childChanges.roles});
    }
  }
  context.getEntityIds(false).forEach(collectEntityChange);
  context.getEntityIds(true).forEach(collectEntityChange);
  
  /* Construct the outer descriptor */
  return {"entities":entityChangeLists, "associations":assocChangeGroup};
};

/*
 * Context
 */

/**
 * @private
 * @constructor
 * @param {!Object} olderMetadataDescr
 * @param {!Object} newerMetadataDescr
 */
wrm.data.meta.MetadataComparator._Context = function(olderMetadataDescr, newerMetadataDescr) {
  
  /** @private */
  this._older = wrm.data.meta.MetadataComparator._Context._createMaps(olderMetadataDescr);
  
  /** @private */
  this._newer = wrm.data.meta.MetadataComparator._Context._createMaps(newerMetadataDescr);
  
  /**
   * @private
   * @type {!Object<string,{oldDescr:(?Object|undefined), newDescr:(?Object|undefined),
   *       migration:?wrm.data.meta.MetadataComparator._MigrationType}>}
   */
  this._deltas = {};
};

/**
 * @private
 * @typedef {{entity:!Object<string,boolean>, association:!Object<string,boolean>, attribute:!Object<string,boolean>,
 *          role:!Object<string,boolean>}}
 */
wrm.data.meta.MetadataComparator._Context._AllIds;

/**
 * @private
 * @typedef {{ids:wrm.data.meta.MetadataComparator._Context._AllIds, descrsById:!Object<string,!Object>,
 *          entityIdByPropertyId:!Object<string,string>, assocIdByRoleId:!Object<string,string>}}
 */
wrm.data.meta.MetadataComparator._Context._Maps;

/**
 * @private
 * @param {!Object} metadataDescr
 * @return {!wrm.data.meta.MetadataComparator._Context._Maps}
 */
wrm.data.meta.MetadataComparator._Context._createMaps = function(metadataDescr) {
  var maps = {ids:{entity:{}, association:{}, attribute:{}, role:{}}, descrsById:{}, entityIdByPropertyId:{}, assocIdByRoleId:{}};
  
  var entitiesDescr = metadataDescr["entities"] || {};
  var assocsDescr = metadataDescr["associations"] || {};
  
  /* Entities */
  Object.keys(entitiesDescr).forEach(function(entityId) {
    var entityDescr = entitiesDescr[entityId];
    maps.descrsById[entityId] = entityDescr;
    maps.ids.entity[entityId] = true;
    
    /* Attributes */
    var attributesDescr = entityDescr["attributes"] || {};
    Object.keys(attributesDescr).forEach(function(attrId) {
      var attrDescr = attributesDescr[attrId];
      maps.descrsById[attrId] = attrDescr;
      maps.entityIdByPropertyId[attrId] = entityId;
      maps.ids.attribute[attrId] = true;
    });
    
    /* Roles */
    var rolesDescr = entityDescr["roles"] || {};
    Object.keys(rolesDescr).forEach(function(roleId) {
      maps.descrsById[roleId] = rolesDescr[roleId];
      maps.entityIdByPropertyId[roleId] = entityId;
      maps.ids.role[roleId] = true;
    });
  });
  
  /* Associations */
  Object.keys(assocsDescr).forEach(function(assocId) {
    var assocDescr = assocsDescr[assocId];
    maps.descrsById[assocId] = assocDescr;
    maps.ids.association[assocId] = true;
    
    /* Roles */
    assocDescr["roles"].forEach(function(roleId) {
      maps.assocIdByRoleId[roleId] = assocId;
      maps.ids.role[roleId] = true;
    });
  });
  
  return maps;
};

/**
 * @param {string} id
 * @param {boolean} older
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator._Context.prototype.get = function(id, older) {
  return this._doGetDescr(older ? this._older : this._newer, id);
};

/**
 * @param {boolean} older
 * @return {!Array<string>}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getEntityIds = function(older) {
  return Object.keys((older ? this._older : this._newer).ids.entity);
};

/**
 * @param {boolean} older
 * @return {!Array<string>}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getAssociationIds = function(older) {
  return Object.keys((older ? this._older : this._newer).ids.association);
};

/**
 * @param {boolean} older
 * @return {!Array<string>}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getAttributeIds = function(older) {
  return Object.keys((older ? this._older : this._newer).ids.attribute);
};

/**
 * @param {boolean} older
 * @return {!Array<string>}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getRoleIds = function(older) {
  return Object.keys((older ? this._older : this._newer).ids.role);
};

/**
 * @param {string} propertyId
 * @param {boolean} older
 * @return {string}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getParentEntityId = function(propertyId, older) {
  var map = (older ? this._older : this._newer).entityIdByPropertyId;
  var entityId = map[propertyId];
  if (!entityId) {
    throw new Error("Unknown parent entity of property '" + propertyId + "'");
  }
  return entityId;
};

/**
 * @param {string} roleId
 * @param {boolean} older
 * @return {string}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getParentAssociationId = function(roleId, older) {
  var map = (older ? this._older : this._newer).assocIdByRoleId;
  var assocId = map[roleId];
  if (!assocId) {
    throw new Error("Unknown parent association of role '" + roleId + "'");
  }
  return assocId;
};

/**
 * @private
 * @param {!wrm.data.meta.MetadataComparator._Context._Maps} maps
 * @param {string} id
 * @return {!Object}
 */
wrm.data.meta.MetadataComparator._Context.prototype._doGetDescr = function(maps, id) {
  var descr = maps.descrsById[id];
  if (!descr) {
    throw new Error("Unknown element '" + id + "'");
  }
  return descr;
};

/**
 * @param {!Array<string>} idPath
 * @return {{oldDescr:(?Object), newDescr:(?Object), migration:?wrm.data.meta.MetadataComparator._MigrationType}}
 */
wrm.data.meta.MetadataComparator._Context.prototype.getDelta = function(idPath) {
  var id = idPath.join("/");
  var delta = this._deltas[id];
  if (!delta) {
    throw new Error("No delta available for '" + id + "'");
  }
  if (delta.oldDescr === undefined || delta.newDescr === undefined) {
    throw new Error("No delta available for '" + id + "'");
  }
  return (delta);
};

/**
 * @param {!Array<string>} idPath
 * @param {?Object} oldDescr
 * @param {?Object} newDescr
 */
wrm.data.meta.MetadataComparator._Context.prototype.saveDescriptors = function(idPath, oldDescr, newDescr) {
  var delta = this._getOrCreateDelta(idPath);
  if (delta.oldDescr !== undefined || delta.newDescr !== undefined) {
    throw new Error("Delta descriptors already saved");
  }
  delta.oldDescr = oldDescr;
  delta.newDescr = newDescr;
};

/**
 * @param {!Array<string>} idPath
 * @param {!wrm.data.meta.MetadataComparator._MigrationType} migration
 * @return {boolean}
 */
wrm.data.meta.MetadataComparator._Context.prototype.markForMigration = function(idPath, migration) {
  var MigrationType = wrm.data.meta.MetadataComparator._MigrationType;
  var delta = this._getOrCreateDelta(idPath);
  
  /* Forbid moving between the two extreme migration types */
  if (delta.migration === MigrationType.ADDITION && migration == MigrationType.REMOVAL || delta.migration === MigrationType.REMOVAL && migration == MigrationType.ADDITION) {
    throw new Error("Incompatible migration type");
  }
  
  /* If already migrating, it is already CHANGE or more, so no need to mark again */
  if (delta.migration !== null && migration === MigrationType.CHANGE) {
    return false;
  }
  
  /* This is either the first migration or a change to one of the extreme cases */
  var changing = delta.migration !== migration;
  delta.migration = migration;
  return changing;
};

/**
 * @private
 * @param {!Array<string>} idPath
 * @returns {{oldDescr:(?Object|undefined), newDescr:(?Object|undefined), migration:?wrm.data.meta.MetadataComparator._MigrationType}}
 */
wrm.data.meta.MetadataComparator._Context.prototype._getOrCreateDelta = function(idPath) {
  var id = idPath.join("/");
  var delta = this._deltas[id];
  if (!delta) {
    delta = {oldDescr:undefined, newDescr:undefined, migration:null};
    this._deltas[id] = delta;
  }
  return delta;
};

/**
 * @private
 * @enum {number}
 */
wrm.data.meta.MetadataComparator._MigrationType = {REMOVAL:-1, CHANGE:0, ADDITION:+1};




//== wrm/data/DatabaseHandler.js ==============================================



/**
 * @package
 * @constructor
 * @extends wrm.core.AbstractUpdateParticipant
 * @param {string} concreteDbName
 * @param {!wrm.data.meta.Metadata} currentMetadata
 * @param {!wrm.Platform} platform
 * @param {!wrm.Log} log
 */
wrm.data.DatabaseHandler = function(concreteDbName, currentMetadata, platform, log) {
  wrm.core.AbstractUpdateParticipant.call(this);
  
  /** @private */
  this._concreteDbName = concreteDbName;
  
  /** @private */
  this._currentMetadata = currentMetadata;
  
  /** @private */
  this._currentMigrationWay = null;
  
  /** @private */
  this._stable = false;
  
  /** @private */
  this._unstableUseHandler = wrm.data.DatabaseHandler.DEFAULT_UNSTABLE_USE_HANDLER;
  
  /**
   * @private
   * @type {!Array<function(boolean)>}
   */
  this._stabilityListeners = [];
  
  /** @private */
  this._platform = platform;
  
  /** @private */
  this._log = log;
  
  /** @private */
  this._auxDictionary = platform.retrieveDictionary(this._concreteDbName);
  
  /**
   * @private
   * @type {?function(!wrm.data.meta.MetadataDiff):!Promise}
   */
  this._migrationHandler = null;
  
  /**
   * @private
   * @type {?xdata.Database}
   */
  this._db = null;
};

extendConstructor(wrm.data.DatabaseHandler, wrm.core.AbstractUpdateParticipant);

/*
 * Information access
 */

/**
 * @param {!wrm.data.DataService} requestor
 * @return {string}
 */
wrm.data.DatabaseHandler.prototype.getConcreteDatabaseName = function(requestor) {
  return this._checkStable(requestor, this._concreteDbName);
};

/**
 * @param {!wrm.data.DataService} requestor
 * @return {!wrm.data.meta.Metadata}
 */
wrm.data.DatabaseHandler.prototype.getMetadata = function(requestor) {
  return this._checkStable(requestor, this._currentMetadata);
};

/**
 * @param {!wrm.data.DataService} requestor
 * @return {!xdata.Database}
 */
wrm.data.DatabaseHandler.prototype.getDatabase = function(requestor) {
  return this._checkStable(requestor, this._doGetDatabase());
};

/**
 * @private
 * @return {!xdata.Database}
 */
wrm.data.DatabaseHandler.prototype._doGetDatabase = function() {
  if (!this._db) {
    this._db = this._createDatabase();
  }
  return this._db;
};

/**
 * @return {!wrm.data.Dictionary}
 */
wrm.data.DatabaseHandler.prototype.getAuxiliaryDictionary = function() {
  return this._auxDictionary;
};

/*
 * Stability control
 */

/**
 * @private
 * @template T
 * @param {!wrm.data.DataService} requestor
 * @param {T} value
 * @return {T}
 */
wrm.data.DatabaseHandler.prototype._checkStable = function(requestor, value) {
  if (!this._stable) {
    this._unstableUseHandler(requestor);
  }
  return value;
};

/**
 * @const {function(!wrm.data.DataService)}
 */
wrm.data.DatabaseHandler.DEFAULT_UNSTABLE_USE_HANDLER = function(requestor) {
  throw new Error("The database is still unstable");
};

/**
 * @param {function(!wrm.data.DataService)} handler
 */
wrm.data.DatabaseHandler.prototype.setUnstableUseHandler = function(handler) {
  this._unstableUseHandler = handler || wrm.data.DatabaseHandler.DEFAULT_UNSTABLE_USE_HANDLER;
};

/**
 * @param {function(boolean)} listener
 */
wrm.data.DatabaseHandler.prototype.addStabilityListener = function(listener) {
  listener(this._stable);
  if (!this._stable) {
    this._stabilityListeners.push(listener);
  }
};

/**
 * @private
 * @return {undefined}
 */
wrm.data.DatabaseHandler.prototype._handleChangedStability = function() {
  
  /* Discard state that depends on unstable values */
  this._db = null;
  
  /* Invoke stability listeners to notify clients */
  for (var i = 0;i < this._stabilityListeners.length;i++) {
    var listener = this._stabilityListeners[i];
    listener(this._stable);
    if (this._stable) {
      this._stabilityListeners.splice(i--, 1);
    }
  }
};

/*
 * Update logic
 */

/**
 * @param {!function(!wrm.data.meta.MetadataDiff):!Promise} handler
 */
wrm.data.DatabaseHandler.prototype.setMigrationHandler = function(handler) {
  this._migrationHandler = handler;
};

/** @override */
wrm.data.DatabaseHandler.prototype.beginUpdate = function(context) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  var ORIG_MD_KEY = wrm.data.DatabaseHandler._ORIG_MD_SNAPSHOT_KEY;
  var EXT_MD_KEY_PREFIX = wrm.data.DatabaseHandler._EXT_MD_SNAPSHOT_KEY_PREFIX;
  var MigrationWay = wrm.data.meta.MigrationWay;
  var log = this._log;
  
  /* If the metadata version did not change, the database does not require an upgrade */
  var snapshot = context.getStableSnapshot(), updateSnapshot = context.getUpdateSnapshot();
  var legacyVersion = this._transferLegacySnapshot(snapshot, updateSnapshot);
  var originalMetadata = DatabaseHandler._readMetadata(snapshot, ORIG_MD_KEY) || wrm.data.meta.Metadata.EMPTY;
  var pastExtendedMetadata = DatabaseHandler._readMetadataMap(updateSnapshot, EXT_MD_KEY_PREFIX);
  var currentMetadata = this._currentMetadata;
  if (originalMetadata.getVersion() === currentMetadata.getVersion()) {
    log.debug("No database upgrade is needed");
    context.setInfo(new wrm.data.DataServiceUpdateState(null, {}, null, null, currentMetadata));
    return;
  }
  
  /*
   * The database must be upgraded. Prepare two extended metadata to be used for splitting the upgrade in two halves, with an
   * extended database available between the two
   */
  log.info("Database upgrade started");
  var metadataComparator = new wrm.data.meta.MetadataComparator;
  var extended = metadataComparator.generateExtended(originalMetadata.getDescriptor(), currentMetadata.getDescriptor());
  context.setInfo(new wrm.data.DataServiceUpdateState(originalMetadata, pastExtendedMetadata, extended.metadata, extended.diff, currentMetadata));
  
  /* If upgrading from legacy metadata, bump the database to the expected legacy version */
  return Promise.resolve().then(function() {
    if (legacyVersion !== null) {
      return this._bumpVersionFromEmpty(legacyVersion);
    }
  }.bind(this)).then(function() {
    
    /* From this point, working with ORIGINAL METADATA or with those of a previous attempt (in "arriving" migration mode) */
    this._currentMetadata = DatabaseHandler._findNewestMetadata(pastExtendedMetadata) || originalMetadata;
    this._currentMigrationWay = this._currentMetadata !== originalMetadata ? MigrationWay.ARRIVING : null;
    this._handleChangedStability();
  }.bind(this));
};

/** @override */
wrm.data.DatabaseHandler.prototype.performExtensionUpdate = function(context) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  var EXT_MD_KEY_PREFIX = wrm.data.DatabaseHandler._EXT_MD_SNAPSHOT_KEY_PREFIX;
  var MigrationWay = wrm.data.meta.MigrationWay;
  var info = (context.getInfo());
  if (!info.isUpdating()) {
    return;
  }
  
  /* Perform the first part of the upgrade (new elements arrive, updated elements are changed) */
  var olderMetadata = DatabaseHandler._mergeMetadataMaps(info.getPastExtendedMetadata(), info.getOriginalMetadata());
  var newerMetadata = info.getExtendedMetadata();
  return this._performUpdateStep("Extension:", olderMetadata, newerMetadata, MigrationWay.ARRIVING).then(function() {
    
    /* Save the applied extended metadata, to resume the upgrade should it fail before finishing */
    var updateSnapshot = context.getUpdateSnapshot();
    var allExtendedMetadataMap = DatabaseHandler._mergeMetadataMaps(info.getPastExtendedMetadata(), newerMetadata);
    DatabaseHandler._writeMetadataMap(updateSnapshot, EXT_MD_KEY_PREFIX, allExtendedMetadataMap);
    
    /* From this point, working with EXTENDED METADATA (in "leaving" migration mode) */
    this._currentMetadata = newerMetadata;
    this._currentMigrationWay = MigrationWay.LEAVING;
    this._handleChangedStability();
  }.bind(this));
};

/** @override */
wrm.data.DatabaseHandler.prototype.performCoreUpdate = function(context) {
  var info = (context.getInfo());
  if (!info.isUpdating()) {
    return;
  }
  if (this._migrationHandler) {
    return this._migrationHandler(info.getExtendedMetadataDiff());
  }
};

/** @override */
wrm.data.DatabaseHandler.prototype.performReductionUpdate = function(context) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  var MigrationWay = wrm.data.meta.MigrationWay;
  var info = (context.getInfo());
  if (!info.isUpdating()) {
    return;
  }
  
  /* Perform the second part of the upgrade (old elements leave) */
  var olderMetadata = DatabaseHandler._mergeMetadataMaps({}, info.getExtendedMetadata());
  var newerMetadata = info.getCurrentMetadata();
  return this._performUpdateStep("Reduction:", olderMetadata, newerMetadata, MigrationWay.LEAVING).then(function() {
    
    /* From this point, working with CURRENT METADATA */
    this._currentMetadata = newerMetadata;
    this._currentMigrationWay = null;
    this._handleChangedStability();
  }.bind(this));
};

/** @override */
wrm.data.DatabaseHandler.prototype.finishUpdate = function(context) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  var ORIG_MD_KEY = wrm.data.DatabaseHandler._ORIG_MD_SNAPSHOT_KEY;
  var info = (context.getInfo());
  
  /* If upgrading, it is now over: save the new state */
  if (info.isUpdating()) {
    var snapshot = context.getStableSnapshot();
    DatabaseHandler._writeMetadata(snapshot, ORIG_MD_KEY, info.getCurrentMetadata());
    this._log.info("Database upgrade finished");
  }
  
  /* From this point, the state is STABLE */
  this._stable = true;
  this._handleChangedStability();
  return info.isUpdating();
};

/**
 * @private
 * @param {number} version
 * @return {!Promise}
 */
wrm.data.DatabaseHandler.prototype._bumpVersionFromEmpty = function(version) {
  this._log.debug("Bumping database version to", version);
  
  var db = xdata.createDatabase("websql", {}, version, {});
  return db.upgradeVersion(this._concreteDbName, function(oldVersion) {
    throw new Error("Bumping non-empty version");
  });
};

/**
 * @private
 * @param {string} label
 * @param {!Object<number,!wrm.data.meta.Metadata>} olderMetadata
 * @param {!wrm.data.meta.Metadata} newerMetadata
 * @param {!wrm.data.meta.MigrationWay} migrationWay
 * @return {!Promise|undefined}
 */
wrm.data.DatabaseHandler.prototype._performUpdateStep = function(label, olderMetadata, newerMetadata, migrationWay) {
  var log = this._log;
  
  var metadataRegistry = this._newMetadataRegistry(newerMetadata);
  Object.keys(olderMetadata).forEach(function(key) {
    metadataRegistry.register(olderMetadata[Number(key)], true);
  });
  
  /*
   * Use a dedicated database instance. If the metadata versions are somehow not monotonic, assign a monotonic database version to
   * the newer metadata that is able to guarantee that
   */
  var db = this._createDatabase(newerMetadata, migrationWay);
  var newerMetadataVersion = newerMetadata.getVersion();
  if (metadataRegistry.getDatabaseVersion(newerMetadataVersion) < db.getVersion()) {
    metadataRegistry.initDatabaseVersion(newerMetadataVersion, db.getVersion() + 1);
    db = this._createDatabase(newerMetadata, migrationWay);
  }
  
  /* Factory for providing the older XData schemas */
  function schemaFactory(oldDbVersion) {
    log.debug(label, "previous version was", oldDbVersion);
    var oldMetadata = metadataRegistry.retrieveByDatabaseVersion(oldDbVersion);
    return (new wrm.data.XDMetadata(oldMetadata, migrationWay, oldDbVersion)).getSchema();
  }
  
  /* Upgrade the database version to the newer schema */
  log.debug(label, "upgrading to version", db.getVersion(), "with metadata", newerMetadataVersion);
  return db.upgradeVersion(this._concreteDbName, schemaFactory).then(function() {
    log.debug(label, "done");
  });
};

/**
 * @private
 * @param {!Object<number,!wrm.data.meta.Metadata>} map
 * @param {!wrm.data.meta.Metadata} metadata
 * @return {!Object<number,!wrm.data.meta.Metadata>}
 */
wrm.data.DatabaseHandler._mergeMetadataMaps = function(map, metadata) {
  var result = wrm.util.obj.copyProperties({}, map);
  result[metadata.getVersion()] = metadata;
  return result;
};

/**
 * @private
 * @param {!Object<number,!wrm.data.meta.Metadata>} metadataMap
 * @return {?wrm.data.meta.Metadata}
 */
wrm.data.DatabaseHandler._findNewestMetadata = function(metadataMap) {
  var maxVersion = -1;
  Object.keys(metadataMap).forEach(function(version) {
    version = Number(version);
    if (version > maxVersion) {
      maxVersion = version;
    }
  });
  return maxVersion > -1 ? metadataMap[maxVersion] : null;
};

/**
 * @private
 * @const
 */
wrm.data.DatabaseHandler._ORIG_MD_SNAPSHOT_KEY = "metadata";

/**
 * @private
 * @const
 */
wrm.data.DatabaseHandler._EXT_MD_SNAPSHOT_KEY_PREFIX = "extendedMetadata.";

/**
 * @private
 * @param {!wrm.data.Dictionary} snapshot
 * @param {!wrm.data.Dictionary} updateSnapshot
 * @return {?number}
 */
wrm.data.DatabaseHandler.prototype._transferLegacySnapshot = function(snapshot, updateSnapshot) {
  var ORIG_MD_KEY = wrm.data.DatabaseHandler._ORIG_MD_SNAPSHOT_KEY;
  var DatabaseHandler = wrm.data.DatabaseHandler;
  
  /** @const */
  var LEGACY_VERSION = 0;
  
  /*
   * Transfer original metadata from the provisional storage used prior to version 8.6. If found, such old metadata must be completed
   * with a version (the lowest valid version). Once transfered, store also in the temporary update snapshot, so that the legacy
   * metadata is not lost in case of update errors.
   */
  var legacyMetadata = DatabaseHandler._readMetadata(this._auxDictionary, "metadata", LEGACY_VERSION);
  if (!legacyMetadata) {
    legacyMetadata = DatabaseHandler._readMetadata(updateSnapshot, "legacyMetadata", LEGACY_VERSION);
  }
  if (legacyMetadata) {
    if (DatabaseHandler._readMetadata(snapshot, ORIG_MD_KEY)) {
      throw new Error("Conflict between legacy and new saved metadata");
    }
    DatabaseHandler._writeMetadata(updateSnapshot, "legacyMetadata", legacyMetadata);
    DatabaseHandler._writeMetadata(snapshot, ORIG_MD_KEY, legacyMetadata);
    this._auxDictionary.remove("metadata");
    return LEGACY_VERSION;
  }
  
  return null;
};

/**
 * @private
 * @param {!wrm.data.Dictionary} dictionary
 * @param {string} keyPrefix
 * @return {!Object<number,!wrm.data.meta.Metadata>}
 */
wrm.data.DatabaseHandler._readMetadataMap = function(dictionary, keyPrefix) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  var result = {};
  dictionary.getKeys().forEach(function(key) {
    if (key.indexOf(keyPrefix) !== 0) {
      return;
    }
    var version = Number(key.substring(keyPrefix.length));
    var metadata = DatabaseHandler._readMetadata(dictionary, key);
    if (metadata.getVersion() !== version) {
      throw new Error("Mismatching stored metadata version " + version);
    }
    result[version] = metadata;
  });
  return result;
};

/**
 * @private
 * @param {!wrm.data.Dictionary} dictionary
 * @param {string} key
 * @param {number=} assumedVersion
 * @return {?wrm.data.meta.Metadata}
 */
wrm.data.DatabaseHandler._readMetadata = function(dictionary, key, assumedVersion) {
  var descrString = dictionary.get(key);
  if (!descrString) {
    return null;
  }
  
  var descr = (JSON.parse(descrString));
  if (descr["version"] === undefined && assumedVersion !== undefined) {
    descr["version"] = assumedVersion;
  }
  
  return new wrm.data.meta.Metadata(descr);
};

/**
 * @private
 * @param {!wrm.data.Dictionary} dictionary
 * @param {string} keyPrefix
 * @param {!Object<number,!wrm.data.meta.Metadata>} metadataMap
 */
wrm.data.DatabaseHandler._writeMetadataMap = function(dictionary, keyPrefix, metadataMap) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  dictionary.getKeys().forEach(function(key) {
    if (key.indexOf(keyPrefix) !== 0) {
      return;
    }
    dictionary.remove(key);
  });
  Object.keys(metadataMap).forEach(function(mapKey) {
    var version = Number(mapKey);
    var metadata = metadataMap[version];
    if (metadata.getVersion() !== version) {
      throw new Error("Unmatching metadata version " + version);
    }
    DatabaseHandler._writeMetadata(dictionary, keyPrefix + version, metadata);
  });
};

/**
 * @private
 * @param {!wrm.data.Dictionary} dictionary
 * @param {string} key
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.DatabaseHandler._writeMetadata = function(dictionary, key, metadata) {
  var descr = metadata.getDescriptor();
  var descrString = JSON.stringify(descr);
  dictionary.set(key, descrString);
};

/**
 * @private
 * @param {!wrm.data.meta.Metadata=} metadata
 * @param {?wrm.data.meta.MigrationWay=} migrationWay
 * @return {!xdata.Database}
 */
wrm.data.DatabaseHandler.prototype._createDatabase = function(metadata, migrationWay) {
  var DatabaseHandler = wrm.data.DatabaseHandler;
  
  metadata = metadata || this._currentMetadata;
  migrationWay = migrationWay !== null && migrationWay !== undefined ? migrationWay : this._currentMigrationWay;
  
  var metadataRegistry = this._newMetadataRegistry(this._currentMetadata);
  var dbVersion = metadataRegistry.getDatabaseVersion(metadata.getVersion());
  var xdMetadata = new wrm.data.XDMetadata(metadata, migrationWay, dbVersion);
  var db = xdata.createDatabase(DatabaseHandler._PROVIDER_NAME, DatabaseHandler._PROVIDER_CONFIG, xdMetadata.getVersion(), xdMetadata.getSchema());
  
  /* Install database-level logging */
  var dbLog = this._platform.createLog("database", "[" + this._concreteDbName + "]");
  if (dbLog.isDebugEnabled()) {
    db.addListener(new function() {
      this.begunTransaction = function(event) {
        dbLog.debug("Transaction begun", event.readOnly ? "(read)" : "(read/write)");
      };
      this.resolvedTransaction = function(event) {
        dbLog.debug("Transaction " + (event.committed ? "committed" : "rolled back"));
      };
      this.executingCommand = function(event) {
        dbLog.debug("Command", event.command, event.commandParameters);
      };
      this.executedCommand = function(event) {
      };
    });
  }
  
  return db;
};

/**
 * @private
 * @const
 */
wrm.data.DatabaseHandler._PROVIDER_NAME = "websql";

/**
 * @private
 * @const {!Object<string,*>}
 */
wrm.data.DatabaseHandler._PROVIDER_CONFIG = {};

/**
 * @private
 * @param {!wrm.data.meta.Metadata=} metadata
 * @return {!wrm.data.MetadataRegistry}
 */
wrm.data.DatabaseHandler.prototype._newMetadataRegistry = function(metadata) {
  var registry = new wrm.data.MetadataRegistry(this._auxDictionary);
  if (metadata) {
    registry.register(metadata);
  }
  return registry;
};




//== wrm/data/DefaultQueryFactory.js ==========================================



/**
 * @constructor
 * @implements wrm.data.QueryFactory
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.DefaultQueryFactory = function(metadata) {
  
  /** @private */
  this._metadata = metadata;
};

/** @override */
wrm.data.DefaultQueryFactory.prototype.prepareSelect = function(entityId, options) {
  return new wrm.data.XEntitySelectQuery(this._metadata, entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.DefaultQueryFactory.prototype.prepareOldSelect = function(entityId, options) {
  return new wrm.data.JSelectQuery(this._metadata, entityId, options);
};

/** @override */
wrm.data.DefaultQueryFactory.prototype.prepareInsert = function(entityId, insert) {
  return new wrm.data.InsertQuery(this._metadata, entityId, insert);
};

/** @override */
wrm.data.DefaultQueryFactory.prototype.prepareUpdate = function(entityId, options) {
  return new wrm.data.UpdateQuery(this._metadata, entityId, options);
};

/** @override */
wrm.data.DefaultQueryFactory.prototype.prepareDelete = function(entityId, options) {
  return new wrm.data.XEntityDeleteQuery(this._metadata, entityId, options);
};
/**
 * @override
 * @deprecated
 */
wrm.data.DefaultQueryFactory.prototype.prepareOldDelete = function(entityId, options) {
  return new wrm.data.JDeleteQuery(this._metadata, entityId, options);
};

/**
 * @override
 * @deprecated
 */
wrm.data.DefaultQueryFactory.prototype.prepareCondition = function(entityId, expression) {
  return new wrm.data.Condition(this._metadata, entityId, expression);
};




//== wrm/data/JDAtomOperators.js ==============================================

wrm.data.JDAtomOperators = {};


/*
 * Unary
 */

/**
 * @private
 * @const
 * @type {!Object.<string,wrm.data.ConditionNodes.UnaryAtomOperatorConfig>} operatorDescriptors
 */
wrm.data.JDAtomOperators._UNARY_OPERATORS = {"e":{fragmentTemplate:"$0 \x3d\x3d ''", evaluate:function(left, right, dataContext) {
  return String(left) === "";
}}, "!e":{fragmentTemplate:"$0 !\x3d ''", evaluate:function(left, right, dataContext) {
  return String(left) !== "";
}}, "n":{fragmentTemplate:"$0 \x3d\x3d null", evaluate:function(left, right, dataContext) {
  return left === null;
}}, "!n":{fragmentTemplate:"$0 !\x3d null", evaluate:function(left, right, dataContext) {
  return left !== null;
}}};

/*
 * Binary
 */

/**
 * @private
 * @const
 * @type {!Object.<string,wrm.data.ConditionNodes.BinaryAtomOperatorConfig>} operatorDescriptors
 */
wrm.data.JDAtomOperators._BINARY_OPERATORS = {"in":{fragmentTemplate:"$0 in $1", arrayTest:true, evaluate:function(left, right, dataContext) {
  return right.indexOf(left) >= 0;
}}, "!in":{fragmentTemplate:"!($0 in $1)", arrayTest:true, evaluate:function(left, right, dataContext) {
  return right.indexOf(left) < 0;
}}, "eq":{fragmentTemplate:"$0 \x3d\x3d\x3d $1", evaluate:function(left, right, dataContext) {
  return wrm.data.equal(left, right);
}}, "eq[or]":{fragmentTemplate:"$0 in $1", arrayTest:true, evaluate:function(left, right, dataContext) {
  for (var i = 0;i < right.length;i++) {
    if (wrm.data.equal(left, right[i])) {
      return true;
    }
  }
  return false;
}}, "eq.ic":{fragmentTemplate:"$0 \x3d\x3d\x3d $1", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left === right;
}}, "eq.ic[or]":{fragmentTemplate:"$0.toLowerCase() in $1", arrayTest:true, prepareRightValue:function(value) {
  return value.map(function(v) {
    return String(v).toLowerCase();
  });
}, evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  return right.indexOf(left) >= 0;
}}, "!eq":{fragmentTemplate:"$0 !\x3d\x3d $1", evaluate:function(left, right, dataContext) {
  return !wrm.data.equal(left, right);
}}, "!eq[and]":{fragmentTemplate:"!($0 in $1)", arrayTest:true, evaluate:function(left, right, dataContext) {
  for (var i = 0;i < right.length;i++) {
    if (wrm.data.equal(left, right[i])) {
      return false;
    }
  }
  return true;
}}, "!eq.ic":{fragmentTemplate:"$0 !\x3d\x3d $1", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left !== right;
}}, "!eq.ic[and]":{fragmentTemplate:"!($0.toLowerCase() in $1)", arrayTest:true, prepareRightValue:function(value) {
  return value.map(function(v) {
    return String(v).toLowerCase();
  });
}, evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  return right.indexOf(left) < 0;
}}, "gt":{fragmentTemplate:"$0 \x3e $1", evaluate:function(left, right, dataContext) {
  return wrm.data.compare(left, right) > 0;
}}, "gte":{fragmentTemplate:"$0 \x3e\x3d $1", evaluate:function(left, right, dataContext) {
  return wrm.data.compare(left, right) >= 0;
}}, "lt":{fragmentTemplate:"$0 \x3c $1", evaluate:function(left, right, dataContext) {
  return wrm.data.compare(left, right) < 0;
}}, "lte":{fragmentTemplate:"$0 \x3c\x3d $1", evaluate:function(left, right, dataContext) {
  return wrm.data.compare(left, right) <= 0;
}}, "bw":{fragmentTemplate:"$0.startsWith($1)", evaluate:function(left, right, dataContext) {
  left = String(left);
  right = String(right);
  return left.slice(0, right.length) === right;
}}, "co":{fragmentTemplate:"$0.contains($1)", evaluate:function(left, right, dataContext) {
  left = String(left);
  right = String(right);
  return left.indexOf(right) >= 0;
}}, "ew":{fragmentTemplate:"$0.endsWith($1)", evaluate:function(left, right, dataContext) {
  left = String(left);
  right = String(right);
  return left.slice(-right.length) === right;
}}, "bw.ic":{fragmentTemplate:"$0.startsWith($1)", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left.slice(0, right.length) === right;
}}, "co.ic":{fragmentTemplate:"$0.contains($1)", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left.indexOf(right) >= 0;
}}, "ew.ic":{fragmentTemplate:"$0.endsWith($1)", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left.slice(-right.length) === right;
}}, "!bw":{fragmentTemplate:"!$0.startsWith($1)", evaluate:function(left, right, dataContext) {
  left = String(left);
  right = String(right);
  return left.slice(0, right.length) !== right;
}}, "!co":{fragmentTemplate:"!$0.contains($1)", evaluate:function(left, right, dataContext) {
  left = String(left);
  right = String(right);
  return left.indexOf(right) < 0;
}}, "!ew":{fragmentTemplate:"!$0.endsWith($1)", evaluate:function(left, right, dataContext) {
  left = String(left);
  right = String(right);
  return left.slice(-right.length) !== right;
}}, "!bw.ic":{fragmentTemplate:"!$0.startsWith($1)", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left.slice(0, right.length) !== right;
}}, "!co.ic":{fragmentTemplate:"!$0.contains($1)", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left.indexOf(right) < 0;
}}, "!ew.ic":{fragmentTemplate:"!$0.endsWith($1)", mapExpression:".toLowerCase()", evaluate:function(left, right, dataContext) {
  left = String(left).toLowerCase();
  right = String(right).toLowerCase();
  return left.slice(-right.length) !== right;
}}};

/*
 * Operation registration
 */

/**
 * @private
 * @param {!Object.<string,wrm.data.ConditionNodes.UnaryAtomOperatorConfig>} descriptors
 */
wrm.data.JDAtomOperators._registerUnaryOperator = function(descriptors) {
  wrm.data.JDAtomOperators._doAugmentOperators(descriptors);
  wrm.data.ConditionNodes.registerUnaryAtomOperators(descriptors);
};

/**
 * @private
 * @param {!Object.<string,wrm.data.ConditionNodes.BinaryAtomOperatorConfig>} descriptors
 */
wrm.data.JDAtomOperators._registerBinaryOperator = function(descriptors) {
  wrm.data.JDAtomOperators._doAugmentOperators(descriptors);
  wrm.data.ConditionNodes.registerBinaryAtomOperators(descriptors);
};

/**
 * @private
 * @param {!Object.<string,wrm.data.ConditionNodes.UnaryAtomOperatorConfig|wrm.data.ConditionNodes.UnaryAtomOperatorConfig>}
 *            descriptors
 */
wrm.data.JDAtomOperators._doAugmentOperators = function(descriptors) {
  Object.keys(descriptors).forEach(function(operator) {
    var descriptor = descriptors[operator];
    
    /* Include the property evaluator logic in the function for determining if an operator requires evaluation */
    var oldIsEvaluateRequired = descriptor.isEvaluateRequired;
    descriptor.isEvaluateRequired = function(propertyRef) {
      if (oldIsEvaluateRequired && oldIsEvaluateRequired(propertyRef)) {
        return true;
      }
      return wrm.data.JDPropertyEvaluator.isEvaluationRequired(propertyRef);
    };
  });
};

/* Register */
wrm.data.JDAtomOperators._registerUnaryOperator(wrm.data.JDAtomOperators._UNARY_OPERATORS);
wrm.data.JDAtomOperators._registerBinaryOperator(wrm.data.JDAtomOperators._BINARY_OPERATORS);




//== wrm/data/JDCompoundOperators.js ==========================================

wrm.data.JDCompoundOperators = {};


/*
 * Unary
 */

wrm.data.ConditionNodes.registerUnaryCompoundOperators({"not":{predicatePrefix:"!", propagateVerity:function(verity) {
  return !verity;
}, evaluate:function(operandEvaluators, it, dataContext) {
  
  /* Run the only evaluator, inverting its result */
  return operandEvaluators[0](it, dataContext).then(function(result) {
    return !result;
  });
}}});

/*
 * Binary
 */

wrm.data.ConditionNodes.registerBinaryCompoundOperators({"and":{predicateInfix:" \x26\x26 ", evaluate:function(operandEvaluators, it, dataContext) {
  
  /* Run all evaluators, stopping at the first FALSE one */
  var promise = operandEvaluators.reduce(function(chain, evaluator) {
    return chain.then(function(chainResult) {
      
      /* Exit immediately if FALSE */
      if (chainResult === false) {
        return chainResult;
      }
      
      /* Evaluate next */
      return evaluator(it, dataContext);
    }).then(function(result) {
      return result === false ? false : null;
    });
  }, Promise.resolve());
  
  return promise.then(function(chainResult) {
    return chainResult === false ? false : true;
  });
}}, "or":{predicateInfix:" || ", evaluate:function(operandEvaluators, it, dataContext) {
  
  /* Run all evaluators, stopping at the first TRUE one */
  var promise = operandEvaluators.reduce(function(chain, evaluator) {
    return chain.then(function(chainResult) {
      
      /* Exit immediately if TRUE */
      if (chainResult === true) {
        return chainResult;
      }
      
      /* Evaluate next */
      return evaluator(it, dataContext);
    }).then(function(result) {
      return result === true ? true : null;
    });
  }, Promise.resolve());
  
  return promise.then(function(chainResult) {
    return chainResult === true ? true : false;
  });
}}});




//== wrm/data/JDDataConverters.js =============================================



/**
 * Internal converters making JayData accept WebRatio types.
 * 
 * @package
 * @type {!Object.<string,!Object.<string,function(*):*>>}
 */
wrm.data.JDDataConverters = {};

/*
 * Blob
 */
wrm.data.JDDataConverters["$data.Blob"] = {"$data.Object":function(value) {
  if (value instanceof Uint8Array) {
    return value;
  }
  throw new Error("Invalid blob object: " + value);
}};

/*
 * Date and DateTime (they are one in JayData)
 */
wrm.data.JDDataConverters["$data.Date"] = {"$data.Object":function(value) {
  if (value instanceof wrm.data.Date || value instanceof wrm.data.DateTime) {
    return value.asDate();
  }
  throw new Error("Invalid date object: " + value);
}};

/*
 * Time
 */
wrm.data.JDDataConverters["$data.Time"] = {"$data.Object":function(value) {
  if (value instanceof wrm.data.Time) {
    return value.toString();
  }
  throw new Error("Invalid time object: " + value);
}};

/*
 * Decimal
 */
wrm.data.JDDataConverters["$data.Decimal"] = {"$data.Object":function(value) {
  if (value instanceof wrm.data.Decimal) {
    return value.toString();
  }
  throw new Error("Invalid decimal object: " + value);
}};

/*
 * Numbers (fix invalid JayData rounding to a 32-bit float)
 */
wrm.data.JDDataConverters["$data.Float"] = {"default":function(value) {
  var r = +value;
  if (isNaN(r)) {
    throw 0;
  }
  return r;
}};

/* Register converters with JayData */
angular.forEach(wrm.data.JDDataConverters, function(converters, typeName) {
  $data["Container"]["registerConverter"](typeName, converters);
});




//== wrm/data/JDPropertyEvaluator.js ==========================================



/**
 * @package
 * @constructor
 * @param {function(*,(*|undefined),!wrm.data.DataContext):(boolean|!Promise.<boolean>)} evaluateFn
 * @param {!wrm.data.PropertyRef} propertyRef
 * @param {*|undefined} rightValue
 * @param {?boolean} rightValueArrayConj
 */
wrm.data.JDPropertyEvaluator = function(evaluateFn, propertyRef, rightValue, rightValueArrayConj) {
  
  /* Extract attribute from property reference */
  var attribute = propertyRef.getProperty();
  if (!(attribute instanceof wrm.data.meta.Attribute)) {
    throw new Error("The referenced property must be an attribute");
  }
  
  /** @private */
  this._evaluateFn = evaluateFn;
  
  /** @private */
  this._roles = propertyRef.getRoles();
  
  /** @private */
  this._attribute = attribute;
  
  /** @private */
  this._rightValue = rightValue;
  
  /** @private */
  this._rightValueArrayConj = rightValueArrayConj;
};

/**
 * @param {!Object} object
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<boolean>}
 */
wrm.data.JDPropertyEvaluator.prototype.evaluate = function(object, dataContext) {
  return this._doEvaluate(object, this._roles, this._attribute, dataContext);
};

/**
 * @private
 * @param {!Object} object
 * @param {!Array.<!wrm.data.meta.Role>} roles
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<boolean>}
 */
wrm.data.JDPropertyEvaluator.prototype._doEvaluate = function(object, roles, attribute, dataContext) {
  var thisEvaluator = this;
  
  /* If there are still roles to follow on the path to the attribute, follow the first one */
  if (roles.length > 0) {
    return wrm.data.JDPropertyFiller.retrieveRoleValues(object, roles, dataContext).then(function(instances) {
      
      /* Evaluate the remaining roles and the attribute on all instances */
      var nextRoles = roles.slice(1);
      return instances.reduce(function(chain, instance) {
        return chain.then(function(resultSoFar) {
          if (resultSoFar) {
            return resultSoFar;
          }
          return thisEvaluator._doEvaluate(instance, nextRoles, attribute, dataContext);
        });
      }, Promise.resolve(false));
    });
  }
  
  /* No more roles to follow: evaluate against the attribute */
  return this._doEvaluateAttribute(object, attribute, dataContext);
};

/**
 * @private
 * @param {!Object} object
 * @param {!wrm.data.meta.Attribute} attribute
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise.<boolean>}
 */
wrm.data.JDPropertyEvaluator.prototype._doEvaluateAttribute = function(object, attribute, dataContext) {
  var evaluate = this._adaptAndEvaluate.bind(this);
  var leftValue = object[attribute.getName()];
  var rightValue = this._rightValue;
  
  if (this._rightValueArrayConj !== null && rightValue && angular.isArray(rightValue)) {
    
    /* Array input value: apply the evaluate function on each element, with boolean conjunction/disjunction logic */
    var breakValue = !this._rightValueArrayConj;
    return rightValue.reduce(function(chain, rightValueElement) {
      return chain.then(function(chainResult) {
        
        /* Exit immediately if the short-circuit flag was obtained */
        if (chainResult === breakValue) {
          return chainResult;
        }
        
        /* Evaluate next */
        return evaluate(leftValue, rightValueElement, dataContext);
      }).then(function(result) {
        return result === breakValue ? breakValue : null;
      });
    }, Promise.resolve()).then(function(chainResult) {
      return chainResult === breakValue ? breakValue : !breakValue;
    });
    
  } else {
    
    /* Scalar input value: apply the evaluate function directly */
    return Promise.resolve().then(function() {
      return evaluate(leftValue, rightValue, dataContext);
    });
  }
};

/**
 * @private
 * @param {*} left
 * @param {*|undefined} right
 * @param {!wrm.data.DataContext} dataContext
 * @return {!Promise<boolean>|boolean}
 */
wrm.data.JDPropertyEvaluator.prototype._adaptAndEvaluate = function(left, right, dataContext) {
  var type = this._attribute.getType();
  left = Array.isArray(left) ? wrm.data.toArray(type, left) : wrm.data.toSingle(type, left);
  right = Array.isArray(right) ? wrm.data.toArray(type, right) : wrm.data.toSingle(type, right);
  return this._evaluateFn(left, right, dataContext);
};

/**
 * @package
 * @param {!wrm.data.PropertyRef} propertyRef
 * @return {boolean}
 */
wrm.data.JDPropertyEvaluator.isEvaluationRequired = function(propertyRef) {
  
  /* The use of an evaluator is required if the reference points to an attribute that requires filling */
  if (propertyRef.getProperty() instanceof wrm.data.meta.Attribute) {
    return wrm.data.JDPropertyFiller.isFillingRequired(propertyRef);
  }
  
  return false;
};




//== wrm/data/meta/BridgeEntity.js ============================================



/**
 * @constructor
 * @extends wrm.data.meta.Entity
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Role} role1
 * @param {!wrm.data.meta.Role} role2
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.BridgeEntity = function(id, descr, role1, role2, metadata) {
  wrm.data.meta.Entity.call(this, id, descr, metadata);
  
  /** @private */
  this._auxEntity = this._createAuxEntity(descr["auxEntity"] || null);
  
  /** @private */
  this._addTimestampAttriubte = this._createAddTimestampAttribute(descr["addTimestampName"] || null, this._auxEntity);
  
  /** @private */
  this._removeTimestampAttriubte = this._createRemoveTimestampAttribute(descr["removeTimestampName"] || null, this._auxEntity);
  
  /* Create attributes */
  this.createAttributes(descr["attributes"] || {}, null);
  
  /* Create bridge roles */
  var bRoleDescrs = descr["bridgeRoles"] || [];
  var bRole1 = this._createBridgeRole(bRoleDescrs[0], role1, this._auxEntity);
  var bRole2 = this._createBridgeRole(bRoleDescrs[1], role2, this._auxEntity);
  
  /** @private */
  this._role1 = bRole1;
  
  /** @private */
  this._role2 = bRole2;
  
  /* Register with the parent metadata */
  metadata.registerEntity(this);
};

extendConstructor(wrm.data.meta.BridgeEntity, wrm.data.meta.Entity);

/**
 * @private
 * @param {?Object} descr
 * @return {?wrm.data.meta.AuxEntity}
 */
wrm.data.meta.BridgeEntity.prototype._createAuxEntity = function(descr) {
  if (descr) {
    return new wrm.data.meta.AuxEntity("_aux_" + this.getId(), descr, this.getMetadata());
  }
  return null;
};

/**
 * @private
 * @param {?string} atAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.BridgeEntity.prototype._createAddTimestampAttribute = function(atAttrName, auxEntity) {
  if (!atAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for entity " + this);
  }
  
  /* Create an attribute descriptor */
  var atAttrId = "_addts" + this.getId();
  var atAttrDescr = {};
  atAttrDescr["name"] = atAttrName;
  atAttrDescr["type"] = wrm.data.Type.TIMESTAMP;
  
  return new wrm.data.meta.AuxAttribute(atAttrId, atAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?string} rtAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.BridgeEntity.prototype._createRemoveTimestampAttribute = function(rtAttrName, auxEntity) {
  if (!rtAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for entity " + this);
  }
  
  /* Create an attribute descriptor */
  var rtAttrId = "_remts" + this.getId();
  var rtAttrDescr = {};
  rtAttrDescr["name"] = rtAttrName;
  rtAttrDescr["type"] = wrm.data.Type.TIMESTAMP;
  
  return new wrm.data.meta.AuxAttribute(rtAttrId, rtAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @private
 * @param {?Object} descr
 * @param {!wrm.data.meta.Role} role
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {!wrm.data.meta.BridgeRole}
 */
wrm.data.meta.BridgeEntity.prototype._createBridgeRole = function(descr, role, auxEntity) {
  if (!descr) {
    throw new Error("No descriptor found for bridge role of role " + role);
  }
  if (!role.getBridgeHeadRole()) {
    throw new Error("Role " + role + " has no bridge-head role");
  }
  
  var bRole = new wrm.data.meta.BridgeRole("_brdg_" + role.getId(), descr, this, role.getBridgeHeadRole(), auxEntity, this.getMetadata());
  return bRole;
};

/**
 * @return {?wrm.data.meta.AuxEntity}
 */
wrm.data.meta.BridgeEntity.prototype.getAuxiliaryEntity = function() {
  return this._auxEntity;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.BridgeEntity.prototype.getAddTimestampAuxiliaryAttribute = function() {
  return this._addTimestampAttriubte;
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.BridgeEntity.prototype.getRemoveTimestampAuxiliaryAttribute = function() {
  return this._removeTimestampAttriubte;
};

/**
 * @return {!wrm.data.meta.BridgeRole}
 */
wrm.data.meta.BridgeEntity.prototype.getRole1 = function() {
  return this._role1;
};

/**
 * @return {!wrm.data.meta.BridgeRole}
 */
wrm.data.meta.BridgeEntity.prototype.getRole2 = function() {
  return this._role2;
};




//== wrm/data/meta/BridgeRole.js ==============================================



/**
 * @constructor
 * @extends wrm.data.meta.Role
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.data.meta.Entity} entity
 * @param {!wrm.data.meta.Role} inverseRole
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @param {!wrm.data.meta.Metadata} metadata
 */
wrm.data.meta.BridgeRole = function(id, descr, entity, inverseRole, auxEntity, metadata) {
  wrm.data.meta.Role.call(this, id, descr, entity, metadata);
  
  /** @private */
  this._auxEntity = auxEntity;
  
  /**
   * @private
   * @type {?wrm.data.meta.AuxAttribute}
   */
  this._serverTrackerAttriubte;
  
  /* Explicitly set the inverse role (there is no reference in the descriptor) */
  this.initInverseRole(inverseRole);
  
  /* Register with the parent metadata */
  entity.registerRole(this, true);
};

extendConstructor(wrm.data.meta.BridgeRole, wrm.data.meta.Role);

/**
 * @private
 * @param {?string} stAttrName
 * @param {?wrm.data.meta.AuxEntity} auxEntity
 * @return {?wrm.data.meta.AuxAttribute}
 */
wrm.data.meta.BridgeRole.prototype._createServerTrackerAttribute = function(stAttrName, auxEntity) {
  if (!stAttrName) {
    return null;
  }
  if (!auxEntity) {
    throw new Error("No auxiliary entity available for bridge role " + this);
  }
  
  /* Create an attribute descriptor based on the pointed entity */
  var stAttrId = "_track" + this.getId();
  var stAttrDescr = {};
  stAttrDescr["name"] = stAttrName;
  stAttrDescr["type"] = this.getInverseEntity().getServerKeyAttribute().getType();
  
  return new wrm.data.meta.AuxAttribute(stAttrId, stAttrDescr, auxEntity, false, this.getMetadata());
};

/**
 * @protected
 * @override
 */
wrm.data.meta.BridgeRole.prototype.doInit = function(descr) {
  wrm.data.meta.BridgeRole._super.doInit.call(this, descr);
  this._serverTrackerAttriubte = this._createServerTrackerAttribute(descr["serverTrackerName"] || null, this._auxEntity);
};

/**
 * @return {?wrm.data.meta.Attribute}
 */
wrm.data.meta.BridgeRole.prototype.getServerTrackerAuxiliaryAttribute = function() {
  return this._serverTrackerAttriubte;
};




//== wrm/data/ObjectSet.js ====================================================


/**
 * @constructor
 * @param {!Array.<string>} uniqueProperties
 */
wrm.data.ObjectSet = function(uniqueProperties) {
  
  /**
   * @private
   * @type {!Hashtable.<!*,boolean>}
   */
  this._hashSet = new Hashtable(this._createOptions(uniqueProperties));
};

/**
 * @private
 * @param {!Array.<string>} properties
 * @return {{equals:(function(?,?):boolean|undefined), hashCode:(function(?):*|undefined), replaceDuplicateKey:(boolean|undefined)}}
 */
wrm.data.ObjectSet.prototype._createOptions = function(properties) {
  var options = {hashCode:this._computeHashCode(properties), equals:this._computeEquals(properties), replaceDuplicateKey:false};
  return options;
};

/**
 * @private
 * @param {!Array.<string>} properties
 * @return {function(?):string}
 */
wrm.data.ObjectSet.prototype._computeHashCode = function(properties) {
  function generateCode(element) {
    var code = "";
    
    /* If the element is an Object */
    if (element instanceof Object) {
      if (implementsInterface(element, wrm.data.TypedValue)) {
        
        /* Element implements the TypedValue interface */
        code += element.hashKey();
      } else {
        
        /* Element is a generic object, the code needs to be created manually */
        code += "{";
        Object.keys(element).forEach(function(key) {
          
          /* This can't work well with other nested Objects */
          code += key + ":" + String(element[key]) + ",";
        });
        code = code.substring(0, code.length - 1);
        code += "}";
      }
    } else {
      
      /* Element is a primitive type */
      code += String(element);
    }
    return code;
  }
  
  return function(obj) {
    var code = "";
    if (properties.length > 0) {
      properties.forEach(function(property) {
        var element = obj[property];
        code = generateCode(element);
      });
    } else {
      
      /* Means that the object is directly the result */
      code = generateCode(obj);
    }
    return code;
  };
};

/**
 * @private
 * @param {!Array.<string>} properties
 * @return {function(?,?):boolean}
 */
wrm.data.ObjectSet.prototype._computeEquals = function(properties) {
  function executeEquals(element1, element2) {
    if (element1 instanceof Object) {
      if (implementsInterface(element1, wrm.data.TypedValue)) {
        
        /* Element 1 implements the TypedValue interface */
        if (!element1.equals(element2)) {
          return false;
        }
      } else {
        
        /* Element 1 is a generic Object */
        if (element1 !== element2) {
          return false;
        }
      }
    } else {
      
      /* Element 1 is not an object */
      if (!(String(element1) === String(element2))) {
        return false;
      }
    }
    return true;
  }
  
  return function(obj1, obj2) {
    if (obj1 === null || obj2 === null) {
      return true;
    }
    
    if (properties.length > 0) {
      for (var iterator = 0;iterator < properties.length;iterator++) {
        if (!executeEquals(obj1[properties[iterator]], obj2[properties[iterator]])) {
          return false;
        }
      }
    } else {
      
      /* Means that the objects are directly the results */
      if (!executeEquals(obj1, obj2)) {
        return false;
      }
    }
    
    /* None of the previous checks failed, they are equal */
    return true;
  };
};

/**
 * @param {!*} object
 * @return {boolean}
 */
wrm.data.ObjectSet.prototype.add = function(object) {
  if (object !== null) {
    var oldValue = this._hashSet.put(object, true);
    if (oldValue === null) {
      return true;
    }
  }
  return false;
};

/**
 * @return {!Array.<!*>}
 */
wrm.data.ObjectSet.prototype.toArray = function() {
  var result = [];
  this._hashSet.each(function(element) {
    result.push(element);
  });
  return result;
};

/** @override */
wrm.data.ObjectSet.prototype.toString = function() {
  
  /* For development only */
  return "[" + this.toArray().map(function(element) {
    return String(element);
  }).join(", ") + "]";
};




//== wrm/data/sync/UnstableDataSyncService.js =================================



/**
 * @package
 * @constructor
 * @implements wrm.core.VolatileHolder.Instance
 * @extends wrm.data.sync.DataSyncService
 * @param {!wrm.data.sync.DataSyncService} dataSyncService
 */
wrm.data.sync.UnstableDataSyncService = function(dataSyncService) {
  /* Not calling the super-constructor ON PURPOSE */
  
  /*
   * Give this instance the same state of the base Data Sync Service. Note however that the methods might be different, as overridden
   * by this constructor own prototype.
   */
  Object.keys(dataSyncService).forEach(function(key) {
    this[key] = dataSyncService[key];
  }, this);
  
  /** @private */
  this._invalidated = false;
};

extendConstructor(wrm.data.sync.UnstableDataSyncService, wrm.data.sync.DataSyncService);

/** @override */
wrm.data.sync.UnstableDataSyncService.prototype.handleUnstableUse = function() {
  
  /* Allow unstable use unless invalidated */
  if (this._invalidated) {
    throw new Error("Unstable Data Sync Service view is no longer valid");
  }
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.sync.UnstableDataSyncService.prototype.invalidate = function() {
  this._invalidated = true;
};




//== wrm/data/UnstableDataService.js ==========================================



/**
 * @package
 * @constructor
 * @implements wrm.core.VolatileHolder.Instance
 * @extends wrm.data.DataService
 * @param {!wrm.data.DataService} dataService
 */
wrm.data.UnstableDataService = function(dataService) {
  /* Not calling the super-constructor ON PURPOSE */
  
  /*
   * Give this instance the same state of the base Data Service. Note however that the methods might be different, as overridden by
   * this constructor own prototype.
   */
  Object.keys(dataService).forEach(function(key) {
    this[key] = dataService[key];
  }, this);
  
  /** @protected */
  this.entityContextPool = wrm.data.DataService.createEntityContextPool(this);
  
  /** @private */
  this._invalidated = false;
};

extendConstructor(wrm.data.UnstableDataService, wrm.data.DataService);

/** @override */
wrm.data.UnstableDataService.prototype.handleUnstableUse = function() {
  
  /* Allow unstable use unless invalidated */
  if (this._invalidated) {
    throw new Error("Unstable Data Service view is no longer valid");
  }
};

/**
 * @package
 * @return {undefined}
 */
wrm.data.UnstableDataService.prototype.invalidate = function() {
  this._invalidated = true;
};




//== wrm/data/XDTypeHandlers.js ===============================================

wrm.data.XDTypeHandlers = {};

/*
 * Blob type: map to an array buffer and additional metadata properties
 */

/**
 * @private
 * @constructor
 * @implements xdata.TypeHandler<!wrm.data.Blob|!wrm.data.BlobReference>
 */
wrm.data.XDTypeHandlers._Blob = function() {
};

/** @override */
wrm.data.XDTypeHandlers._Blob.prototype.getMapping = function() {
  return {"":xdata.SimpleType.ARRAYBUFFER, "contentType":xdata.SimpleType.STRING, "fileName":xdata.SimpleType.STRING, "remoteFileId":xdata.SimpleType.STRING, "status":xdata.SimpleType.INTEGER};
};

/** @override */
wrm.data.XDTypeHandlers._Blob.prototype.getOperatorMapping = function(operator) {
  var ValueOperator = xdata.ValueOperator;
  switch(operator) {
    case ValueOperator.EMPTY:
    ;
    case ValueOperator.NOT_EMPTY:
    ;
    case ValueOperator.NULL:
    ;
    case ValueOperator.NOT_NULL:
      return operator;
    default:
      throw new Error("Operator '" + operator + "' not supported for BLOB values");;
  }
};

/** @override */
wrm.data.XDTypeHandlers._Blob.prototype.getOrderMapping = function(descending) {
  throw new Error("Ordering not supported for BLOB values");
};

/** @override */
wrm.data.XDTypeHandlers._Blob.prototype.read = function(mappedValue) {
  var buffer = mappedValue.get("");
  if (!buffer) {
    return null;
  }
  
  /* Extract metadata */
  var contentType = mappedValue.get("contentType") || undefined;
  var fileName = mappedValue.get("fileName") || null;
  var serverFileId = mappedValue.get("remoteFileId") || null;
  var status = mappedValue.get("status") || null;
  
  /* Construct the BLOB from bytes and metadata */
  return wrm.data.Blob.fromBytes(buffer, contentType, {fileName:fileName, contentSignature:serverFileId, availabilityStatus:status});
};

/** @override */
wrm.data.XDTypeHandlers._Blob.prototype.write = function(mappedValue, value) {
  if (value instanceof wrm.data.BlobReference) {
    mappedValue.set("contentType", null);
    mappedValue.set("fileName", null);
    mappedValue.set("remoteFileId", value.getServerFileId());
    mappedValue.set("status", value.getStatus());
    mappedValue.set("", null);
    return;
  }
  
  if (!value) {
    mappedValue.set("contentType", null);
    mappedValue.set("fileName", null);
    mappedValue.set("remoteFileId", null);
    mappedValue.set("status", null);
    mappedValue.set("", null);
    return;
  }
  
  /* Set metadata */
  mappedValue.set("contentType", value.getContentType());
  mappedValue.set("fileName", value.getMetadata().fileName);
  mappedValue.set("remoteFileId", value.getMetadata().contentSignature);
  mappedValue.set("status", value.getMetadata().availabilityStatus);
  
  /* Load contents */
  return value.read().then(function(buffer) {
    mappedValue.set("", buffer);
  });
};

/*
 * Blob on file system type: map to a relative path stirng and additional metadata properties
 */

/**
 * @private
 * @constructor
 * @implements xdata.TypeHandler<!wrm.data.Blob|!wrm.data.BlobReference>
 */
wrm.data.XDTypeHandlers._BlobFS = function() {
};

/** @override */
wrm.data.XDTypeHandlers._BlobFS.prototype.getMapping = function() {
  return {"":xdata.SimpleType.STRING, "contentType":xdata.SimpleType.STRING, "fileName":xdata.SimpleType.STRING, "remoteFileId":xdata.SimpleType.STRING, "status":xdata.SimpleType.INTEGER};
};

/** @override */
wrm.data.XDTypeHandlers._BlobFS.prototype.getOperatorMapping = function(operator) {
  var ValueOperator = xdata.ValueOperator;
  switch(operator) {
    case ValueOperator.EMPTY:
    ;
    case ValueOperator.NOT_EMPTY:
    ;
    case ValueOperator.NULL:
    ;
    case ValueOperator.NOT_NULL:
      return operator;
    default:
      throw new Error("Operator '" + operator + "' not supported for BLOB values");;
  }
};

/** @override */
wrm.data.XDTypeHandlers._BlobFS.prototype.getOrderMapping = function(descending) {
  throw new Error("Ordering not supported for BLOB values");
};

/** @override */
wrm.data.XDTypeHandlers._BlobFS.prototype.read = function(mappedValue) {
  var path = mappedValue.get("");
  if (!path) {
    return null;
  }
  
  /* Extract metadata */
  var contentType = mappedValue.get("contentType") || undefined;
  var fileName = mappedValue.get("fileName") || null;
  var serverFileId = mappedValue.get("remoteFileId") || null;
  var status = mappedValue.get("status") || null;
  
  /* Construct the BLOB from the backing file and metadata */
  return this._retrieveFile(path).then(function(file) {
    return wrm.data.Blob.fromFile(file, contentType, {fileName:fileName, contentSignature:serverFileId, availabilityStatus:status});
  });
};

/**
 * @private
 * @param {string} path
 * @return {!Promise<!File>}
 */
wrm.data.XDTypeHandlers._BlobFS.prototype._retrieveFile = function(path) {
  var pathAndFileName = /(^.+)[/]([^/]+)$/.exec(path);
  return this._retrieveFileEntry(pathAndFileName[1], pathAndFileName[2]).then(function(fileEntry) {
    return new Promise(function(resolve, reject) {
      fileEntry.file(function(file) {
        resolve(file);
      }, wrm.util.toErrorReject(reject));
    });
  });
};

/**
 * @private
 * @param {string} dirPath
 * @param {string} fileName
 * @return {!Promise<!FileEntry>}
 */
wrm.data.XDTypeHandlers._BlobFS.prototype._retrieveFileEntry = function(dirPath, fileName) {
  return this._retrieveDirectoryEntry(dirPath).then(function(directory) {
    return wrm.util.fs.createNamedFile(directory, fileName);
  });
};

/**
 * @private
 * @param {string} path
 * @return {!Promise<!DirectoryEntry>}
 */
wrm.data.XDTypeHandlers._BlobFS.prototype._retrieveDirectoryEntry = function(path) {
  return wrm.util.fs.retrievePersistentDirectory().then(function(persistentDirEntry) {
    return wrm.util.fs.retrieveDirectory(persistentDirEntry, path);
  });
};

/** @override */
wrm.data.XDTypeHandlers._BlobFS.prototype.write = function(mappedValue, value) {
  if (value instanceof wrm.data.BlobReference) {
    mappedValue.set("contentType", null);
    mappedValue.set("fileName", null);
    mappedValue.set("remoteFileId", value.getServerFileId());
    mappedValue.set("status", value.getStatus());
    mappedValue.set("", null);
    return;
  }
  
  if (!value) {
    mappedValue.set("contentType", null);
    mappedValue.set("fileName", null);
    mappedValue.set("remoteFileId", null);
    mappedValue.set("status", null);
    mappedValue.set("", null);
    return;
  }
  
  throw new Error("Write handling of file-system-stored BLOBs is not implemented");
};

/*
 * Decimal type: map to a string representation of the number
 */

/**
 * @private
 * @constructor
 * @implements xdata.TypeHandler<!wrm.data.Decimal>
 */
wrm.data.XDTypeHandlers._Decimal = function() {
};

/** @override */
wrm.data.XDTypeHandlers._Decimal.prototype.getMapping = function() {
  return xdata.SimpleType.DECIMAL;
};

/** @override */
wrm.data.XDTypeHandlers._Decimal.prototype.getOperatorMapping = function(operator) {
  return (operator);
};

/** @override */
wrm.data.XDTypeHandlers._Decimal.prototype.getOrderMapping = function(descending) {
  return descending;
};

/** @override */
wrm.data.XDTypeHandlers._Decimal.prototype.read = function(mappedValue) {
  var str = mappedValue.getDefault();
  return str && wrm.data.Decimal.fromString(str);
};

/** @override */
wrm.data.XDTypeHandlers._Decimal.prototype.write = function(mappedValue, value) {
  var decimal = wrm.data.toDecimal(value);
  mappedValue.setDefault(decimal && decimal.toString());
};

/*
 * Date type: map to the Date simple type
 */

/**
 * @private
 * @constructor
 * @implements xdata.TypeHandler<!wrm.data.Date>
 */
wrm.data.XDTypeHandlers._Date = function() {
};

/** @override */
wrm.data.XDTypeHandlers._Date.prototype.getMapping = function() {
  return xdata.SimpleType.DATE;
};

/** @override */
wrm.data.XDTypeHandlers._Date.prototype.getOperatorMapping = function(operator) {
  return (operator);
};

/** @override */
wrm.data.XDTypeHandlers._Date.prototype.getOrderMapping = function(descending) {
  return descending;
};

/** @override */
wrm.data.XDTypeHandlers._Date.prototype.read = function(mappedValue) {
  var nativeDate = mappedValue.getDefault();
  return nativeDate && wrm.data.Date.fromDate(nativeDate);
};

/** @override */
wrm.data.XDTypeHandlers._Date.prototype.write = function(mappedValue, value) {
  var timestamp = wrm.data.toDate(value);
  mappedValue.setDefault(timestamp && timestamp.asDate());
};

/*
 * Time type: map to an ISO string representation
 */

/**
 * @private
 * @constructor
 * @implements xdata.TypeHandler<!wrm.data.Time>
 */
wrm.data.XDTypeHandlers._Time = function() {
};

/** @override */
wrm.data.XDTypeHandlers._Time.prototype.getMapping = function() {
  return xdata.SimpleType.STRING;
};

/** @override */
wrm.data.XDTypeHandlers._Time.prototype.getOperatorMapping = function(operator) {
  return (operator);
};

/** @override */
wrm.data.XDTypeHandlers._Time.prototype.getOrderMapping = function(descending) {
  return descending;
};

/** @override */
wrm.data.XDTypeHandlers._Time.prototype.read = function(mappedValue) {
  var str = mappedValue.getDefault();
  return str && wrm.data.Time.fromString(str);
};

/** @override */
wrm.data.XDTypeHandlers._Time.prototype.write = function(mappedValue, value) {
  var time = wrm.data.toTime(value);
  mappedValue.setDefault(time && time.toString());
};

/*
 * Timestamp type: map to the Date simple type
 */

/**
 * @private
 * @constructor
 * @implements xdata.TypeHandler<!wrm.data.DateTime>
 */
wrm.data.XDTypeHandlers._Timestamp = function() {
};

/** @override */
wrm.data.XDTypeHandlers._Timestamp.prototype.getMapping = function() {
  return xdata.SimpleType.DATE;
};

/** @override */
wrm.data.XDTypeHandlers._Timestamp.prototype.getOperatorMapping = function(operator) {
  return (operator);
};

/** @override */
wrm.data.XDTypeHandlers._Timestamp.prototype.getOrderMapping = function(descending) {
  return descending;
};

/** @override */
wrm.data.XDTypeHandlers._Timestamp.prototype.read = function(mappedValue) {
  var nativeDate = mappedValue.getDefault();
  return nativeDate && wrm.data.DateTime.fromDate(nativeDate);
};

/** @override */
wrm.data.XDTypeHandlers._Timestamp.prototype.write = function(mappedValue, value) {
  var timestamp = wrm.data.toTimestamp(value);
  mappedValue.setDefault(timestamp && timestamp.asDate());
};

/*
 * Other types: map directly to an XData simple type
 */

/**
 * @private
 * @template T
 * @constructor
 * @implements xdata.TypeHandler<T>
 * @param {!wrm.data.Type} type
 * @param {!xdata.SimpleType} xdSimpleType
 */
wrm.data.XDTypeHandlers._Direct = function(type, xdSimpleType) {
  
  /** @private */
  this._type = type;
  
  /** @private */
  this._xdSimpleType = xdSimpleType;
};

/** @override */
wrm.data.XDTypeHandlers._Direct.prototype.getMapping = function() {
  return this._xdSimpleType;
};

/** @override */
wrm.data.XDTypeHandlers._Direct.prototype.getOperatorMapping = function(operator) {
  return (operator);
};

/** @override */
wrm.data.XDTypeHandlers._Direct.prototype.getOrderMapping = function(descending) {
  return descending;
};

/** @override */
wrm.data.XDTypeHandlers._Direct.prototype.read = function(mappedValue) {
  return wrm.data.toSingle(this._type, mappedValue.getDefault());
};

/** @override */
wrm.data.XDTypeHandlers._Direct.prototype.write = function(mappedValue, value) {
  mappedValue.setDefault(wrm.data.toSingle(this._type, value));
};

/*
 * Register all handlers
 */

/**
 * @package
 * @param {!wrm.data.Type} type
 * @param {string=} modifier
 * @return {string}
 */
wrm.data.XDTypeHandlers.getName = function(type, modifier) {
  var s = "wr-" + type;
  return modifier ? s + "-" + modifier : s;
};

/**
 * @package
 * @const {!Object<string,!xdata.TypeHandler>}
 */
wrm.data.XDTypeHandlers.MAP = function() {
  var XDTypeHandlers = wrm.data.XDTypeHandlers;
  var Type = wrm.data.Type;
  
  /* Build a map of handlers by their constructed name */
  var map = {};
  map[XDTypeHandlers.getName(Type.BLOB)] = new wrm.data.XDTypeHandlers._Blob;
  map[XDTypeHandlers.getName(Type.BLOB, "fs")] = new wrm.data.XDTypeHandlers._BlobFS;
  map[XDTypeHandlers.getName(Type.BOOLEAN)] = new XDTypeHandlers._Direct(Type.BOOLEAN, xdata.SimpleType.BOOLEAN);
  map[XDTypeHandlers.getName(Type.DATE)] = new wrm.data.XDTypeHandlers._Date;
  map[XDTypeHandlers.getName(Type.DECIMAL)] = new wrm.data.XDTypeHandlers._Decimal;
  map[XDTypeHandlers.getName(Type.FLOAT)] = new XDTypeHandlers._Direct(Type.FLOAT, xdata.SimpleType.REAL);
  map[XDTypeHandlers.getName(Type.INTEGER)] = new XDTypeHandlers._Direct(Type.INTEGER, xdata.SimpleType.INTEGER);
  map[XDTypeHandlers.getName(Type.PASSWORD)] = new XDTypeHandlers._Direct(Type.PASSWORD, xdata.SimpleType.STRING);
  map[XDTypeHandlers.getName(Type.STRING)] = new XDTypeHandlers._Direct(Type.STRING, xdata.SimpleType.STRING);
  map[XDTypeHandlers.getName(Type.TEXT)] = new XDTypeHandlers._Direct(Type.TEXT, xdata.SimpleType.STRING);
  map[XDTypeHandlers.getName(Type.TIME)] = new wrm.data.XDTypeHandlers._Time;
  map[XDTypeHandlers.getName(Type.TIMESTAMP)] = new wrm.data.XDTypeHandlers._Timestamp;
  map[XDTypeHandlers.getName(Type.URL)] = new XDTypeHandlers._Direct(Type.URL, xdata.SimpleType.STRING);
  return map;
}();




//== wrm/val/Element.js =======================================================

wrm.val = {};

/**
 * @interface
 */
wrm.val.Element = function() {
};

/**
 * @param {string} messageKey
 * @param {!Object=} variables
 */
wrm.val.Element.prototype.addError = ABSTRACT_METHOD;




//== wrm/form/AbstractValidatedElement.js =====================================

wrm.form = {};


/**
 * @constructor
 * @implements wrm.val.Element
 */
wrm.form.AbstractValidatedElement = function() {
  
  /**
   * @private
   * @type {!Array.<string>}
   */
  this._errorMessages = [];
};

/**
 * @override
 * @const
 * @param {string} key
 * @param {!Object=} variables
 */
wrm.form.AbstractValidatedElement.prototype.addError = function(key, variables) {
  
  /* Compute the localized error message */
  var actualKey = this.getErrorMessageKey() || key;
  var actualVariables = this.augmentErrorMessageVariables(variables || {});
  var message = this.getLocalizationService().formatMessage(actualKey, actualVariables);
  
  this.recordErrorMessage(message);
};

/**
 * @protected
 * @param {!Object} variables
 * @return {!Object}
 */
wrm.form.AbstractValidatedElement.prototype.augmentErrorMessageVariables = function(variables) {
  return angular.extend({}, {"objectName":this.getFormSubService().getFormLabel()}, variables);
};

/**
 * @protected
 * @param {string} message
 */
wrm.form.AbstractValidatedElement.prototype.recordErrorMessage = ABSTRACT_METHOD;

/**
 * @protected
 * @return {?string}
 */
wrm.form.AbstractValidatedElement.prototype.getErrorMessageKey = ABSTRACT_METHOD;

/**
 * @protected
 * @return {!wrm.form.FormSubService}
 */
wrm.form.AbstractValidatedElement.prototype.getFormSubService = ABSTRACT_METHOD;

/**
 * @protected
 * @return {!wrm.l10n.LocalizationService}
 */
wrm.form.AbstractValidatedElement.prototype.getLocalizationService = ABSTRACT_METHOD;

/**
 * @package
 * @return {!Array.<string>}
 */
wrm.form.AbstractValidatedElement.prototype.getErrorMessages = function() {
  return this._errorMessages;
};




//== wrm/form/FormSubService.js ===============================================


/**
 * @interface
 * @extends wrm.SubService
 */
wrm.form.FormSubService = function() {
};

/**
 * @return {string}
 */
wrm.form.FormSubService.prototype.getFormLabel = function() {
};

/**
 * @param {string} viewPropertyRef
 * @return {?string}
 */
wrm.form.FormSubService.prototype.resolvePropertyFromView = function(viewPropertyRef) {
};

/**
 * @return {!Array<string>}
 */
wrm.form.FormSubService.prototype.getPropertyNames = function() {
};

/**
 * @param {string} propertyName
 * @return {string}
 */
wrm.form.FormSubService.prototype.getPropertyViewReference = function(propertyName) {
};

/**
 * @param {string} propertyName
 * @return {?wrm.data.Type}
 */
wrm.form.FormSubService.prototype.getPropertyType = function(propertyName) {
};

/**
 * @param {string} propertyName
 * @return {string}
 */
wrm.form.FormSubService.prototype.getPropertyLabel = function(propertyName) {
};

/**
 * @param {!wrm.nav.State} state
 */
wrm.form.FormSubService.prototype.publishFormState = ABSTRACT_METHOD;




//== wrm/form/DefaultFormSubService.js ========================================



/**
 * @constructor
 * @extends wrm.core.AbstractSubService
 * @implements wrm.form.FormSubService
 * @param {!wrm.Service} parent
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.form.DefaultFormSubService = function(parent, descr, manager) {
  wrm.core.AbstractSubService.call(this, parent, descr, manager);
  
  /** @private */
  this._parentService = parent;
  
  /**
   * @private
   * @type {string}
   */
  this._formLabel = descr["formLabel"];
  
  /**
   * @private
   * @type {string}
   */
  this._viewPropertyRefPrefix = descr["viewFormRef"] ? descr["viewFormRef"] + "." : "";
  
  /** @private */
  this._propertyInfos = this._createPropertyInfos(descr["properties"] || {});
  
  /** @private */
  this._propertyNames = Object.keys(this._propertyInfos);
};

extendConstructor(wrm.form.DefaultFormSubService, wrm.core.AbstractSubService);

/**
 * @private
 * @typedef {{type:?wrm.data.Type, label:string}}
 */
wrm.form.DefaultFormSubService._PropertyInfo;

/**
 * @private
 * @param {!Object} descr
 * @return {!Object.<string,!wrm.form.DefaultFormSubService._PropertyInfo>}
 */
wrm.form.DefaultFormSubService.prototype._createPropertyInfos = function(descr) {
  var result = {};
  
  Object.keys(descr).forEach(function(propertyName) {
    var propertyDescr = descr[propertyName];
    
    var typeName = propertyDescr["type"];
    var type = typeName ? wrm.util.obj.castEnumValue(wrm.data.Type, typeName) : null;
    var label = propertyDescr["label"] || propertyName;
    
    result[propertyName] = {type:type, label:label};
  });
  
  return result;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.getFormLabel = function() {
  return this._formLabel;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.resolvePropertyFromView = function(viewPropertyRef) {
  if (viewPropertyRef.indexOf(this._viewPropertyRefPrefix) < 0) {
    return null;
  }
  var propertyName = viewPropertyRef.substring(this._viewPropertyRefPrefix.length);
  if (!/^\w+$/.test(propertyName)) {
    return null;
  }
  return propertyName;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.getPropertyNames = function() {
  return this._propertyNames;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.getPropertyViewReference = function(propertyName) {
  return this._viewPropertyRefPrefix + propertyName;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.getPropertyType = function(propertyName) {
  return this._getPropertyInfo(propertyName).type;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.getPropertyLabel = function(propertyName) {
  return this._getPropertyInfo(propertyName).label;
};

/**
 * @package
 * @param {!wrm.nav.State} state
 * @return {?wrm.form.PublishedFormState}
 */
wrm.form.DefaultFormSubService.prototype.retrievePublishedFormState = function(state) {
  var componentId = this._parentService.getId();
  var propertyNames = this._propertyNames;
  
  /* Retrieve view and form state */
  var view = state.getComponentView(componentId);
  var formState = state.getComponentFormState(componentId);
  if (!view || !formState) {
    return null;
  }
  
  /* Retrieve the published form state from the view or create it anew */
  var publishedFormState = view["formState"];
  if (!publishedFormState) {
    publishedFormState = new wrm.form.PublishedFormState(formState, propertyNames);
    view["formState"] = publishedFormState;
  }
  
  return publishedFormState;
};

/** @override */
wrm.form.DefaultFormSubService.prototype.publishFormState = function(state) {
  this.retrievePublishedFormState(state);
};

/**
 * @private
 * @param {string} propertyName
 * @return {!wrm.form.DefaultFormSubService._PropertyInfo}
 */
wrm.form.DefaultFormSubService.prototype._getPropertyInfo = function(propertyName) {
  var info = this._propertyInfos[propertyName];
  if (!info) {
    throw new Error("Unknown form property '" + propertyName + "'");
  }
  return info;
};




//== wrm/form/PublishedFormState.js ===========================================


/**
 * @package
 * @constructor
 * @param {!wrm.form.FormState} formState
 * @param {!Array.<string>} propertyNames
 */
wrm.form.PublishedFormState = function(formState, propertyNames) {
  
  Object.defineProperties(this, {_formState:{value:formState}, _propertyNames:{value:propertyNames}, "_errorInfos":{value:[]}});
  
  /* Publish state for each property */
  propertyNames.forEach(function(propertyName) {
    Object.defineProperty(this, propertyName, {value:wrm.form.PublishedFormState._createPublishedPropertyState(formState, propertyName), enumerable:true});
  }, this);
};

/**
 * @private
 * @typedef {{message:string, vruleId:string}}
 */
wrm.form.PublishedFormState._ErrorInfo;

/**
 * @type { { _formState:!wrm.form.FormState, _errorInfos:!Array.<wrm.form.PublishedFormState._ErrorInfo>,
 *       _propertyNames:!Array.<string>, errors:!Array.<string>, valid:boolean, invalid:boolean, dirty:boolean } }
 */
wrm.form.PublishedFormState.prototype = Object.create((Object.prototype), {"republishErrors":{value:function(vruleId, newMessages) {
  var errorsAdded = wrm.form.PublishedFormState._republishErrors(this, vruleId, newMessages);
  this._formState.setValidity(!errorsAdded);
  return errorsAdded;
}}, errors:{get:function() {
  return this["_errorInfos"].map(function(errorInfo) {
    return errorInfo.message;
  });
}, enumerable:true}, valid:{get:function() {
  if (this["_errorInfos"].length > 0) {
    return false;
  }
  for (var i = 0;i < this._propertyNames.length;i++) {
    if (!this[this._propertyNames[i]].valid) {
      return false;
    }
  }
  return true;
}, enumerable:true}, invalid:{get:function() {
  if (this["_errorInfos"].length > 0) {
    return true;
  }
  for (var i = 0;i < this._propertyNames.length;i++) {
    if (this[this._propertyNames[i]].invalid) {
      return true;
    }
  }
  return false;
}, enumerable:true}, dirty:{get:function() {
  for (var i = 0;i < this._propertyNames.length;i++) {
    if (this[this._propertyNames[i]].dirty) {
      return true;
    }
  }
  return false;
}, enumerable:true}});

/**
 * @private
 * @typedef { { _formState:!wrm.form.FormState, _propertyName:string, _errorInfos:!Array.<wrm.form.PublishedFormState._ErrorInfo>,
 *          errors:!Array.<string>, valid:boolean, invalid:boolean, dirty:boolean } }
 */
wrm.form.PublishedFormState._PropertyState;

/**
 * @private
 * @param {!wrm.form.FormState} formState
 * @param {string} propertyName
 * @return {wrm.form.PublishedFormState._PropertyState}
 */
wrm.form.PublishedFormState._createPublishedPropertyState = function(formState, propertyName) {
  return (Object.create(wrm.form.PublishedFormState._PROPERTY_STATE_PROTOTYPE, {_formState:{value:formState}, _propertyName:{value:propertyName}, "_errorInfos":{value:[]}}));
};

/**
 * @private
 * @const
 * @type {wrm.form.PublishedFormState._PropertyState}
 */
wrm.form.PublishedFormState._PROPERTY_STATE_PROTOTYPE = (Object.create((Object.prototype), {"republishErrors":{value:function(vruleId, newMessages) {
  var errorsAdded = wrm.form.PublishedFormState._republishErrors(this, vruleId, newMessages);
  this._formState.setPropertyValidity(this._propertyName, !errorsAdded);
  return errorsAdded;
}}, errors:{get:function() {
  return this._formState.getPropertyPlatformErrors(this._propertyName).concat(this["_errorInfos"].map(function(errorInfo) {
    return errorInfo.message;
  }));
}, enumerable:true}, valid:{get:function() {
  if (this["_errorInfos"].length > 0) {
    return false;
  }
  var propertyState = this._formState.getProperty(this._propertyName);
  return !propertyState || propertyState.valid;
}, enumerable:true}, invalid:{get:function() {
  if (this["_errorInfos"].length > 0) {
    return true;
  }
  var propertyState = this._formState.getProperty(this._propertyName);
  return !!propertyState && propertyState.invalid;
}, enumerable:true}, dirty:{get:function() {
  var propertyState = this._formState.getProperty(this._propertyName);
  return !!propertyState && propertyState.dirty;
}, enumerable:true}}));

/**
 * @private
 * @param {!wrm.form.PublishedFormState|wrm.form.PublishedFormState._PropertyState} parent
 * @param {string} vruleId
 * @param {!Array.<string>} newMessages
 * @return {boolean}
 */
wrm.form.PublishedFormState._republishErrors = function(parent, vruleId, newMessages) {
  
  /* Retrieve error information (available both for top and property states) */    /** @type {!Array.<!wrm.form.PublishedFormState._ErrorInfo>} */
  var errorInfos = parent["_errorInfos"];
  
  /* Delete all previous errors of the same rule, keeping track of the first encountered */
  var insertIndex = -1;
  for (var i = 0;i < errorInfos.length;i++) {
    if (errorInfos[i].vruleId === vruleId) {
      errorInfos.splice(i, 1);
      if (insertIndex < 0) {
        insertIndex = i;
      }
      i--;
    }
  }
  if (insertIndex < 0) {
    insertIndex = errorInfos.length;
  }
  
  /* Insert the new errors at the found insert index */
  if (!newMessages) {
    return false;
  }
  newMessages.forEach(function(message) {
    errorInfos[insertIndex++] = {message:message, vruleId:vruleId};
  });
  return true;
};




//== wrm/val/Object.js ========================================================


/**
 * @interface
 * @extends wrm.val.Element
 */
wrm.val.Object = function() {
};

/**
 * @return {string}
 */
wrm.val.Object.prototype.getLabel = ABSTRACT_METHOD;

/**
 * @return {!Array.<!wrm.val.Property>}
 */
wrm.val.Object.prototype.getProperties = ABSTRACT_METHOD;

/**
 * @param {string} name
 * @return {!wrm.val.Property}
 */
wrm.val.Object.prototype.getProperty = ABSTRACT_METHOD;




//== wrm/form/ValidatedForm.js ================================================



/**
 * @package
 * @constructor
 * @extends wrm.form.AbstractValidatedElement
 * @implements wrm.val.Object
 * @param {!Array.<string>} propertyNames
 * @param {!wrm.form.FormState} formState
 * @param {?string} errorMessageKey
 * @param {!wrm.form.FormSubService} formSubService
 * @param {!wrm.l10n.LocalizationService} l10nService
 */
wrm.form.ValidatedForm = function(propertyNames, formState, errorMessageKey, formSubService, l10nService) {
  wrm.form.AbstractValidatedElement.call(this);
  
  /** @private */
  this._formLabel = formSubService.getFormLabel();
  
  /** @private */
  this._propertyNames = propertyNames;
  
  /** @private */
  this._formState = formState;
  
  /** @private */
  this._errorMessageKey = errorMessageKey;
  
  /** @private */
  this._formSubService = formSubService;
  
  /** @private */
  this._l10nService = l10nService;
  
  /**
   * @private
   * @type {!Object.<string,!wrm.form.ValidatedFormProperty>}
   */
  this._validatedProperties = {};
  
  /** @private */
  this._errorsMap = {};
};

extendConstructor(wrm.form.ValidatedForm, wrm.form.AbstractValidatedElement);

/**
 * @package
 * @return {!wrm.form.FormState}
 */
wrm.form.ValidatedForm.prototype.getFormState = function() {
  return this._formState;
};

/**
 * @package
 * @return {!Object.<string,!Array.<string>>}
 */
wrm.form.ValidatedForm.prototype.getErrorsMap = function() {
  return this._errorsMap;
};

/**
 * @package
 * @return {undefined}
 */
wrm.form.ValidatedForm.prototype.clearErrors = function() {
  this._errorsMap = {};
};

/** @override */
wrm.form.ValidatedForm.prototype.recordErrorMessage = function(message) {
  var list = this._errorsMap[""];
  if (!list) {
    this._errorsMap[""] = list = [];
  }
  list.push(message);
};

/** @override */
wrm.form.ValidatedForm.prototype.getErrorMessageKey = function() {
  return this._errorMessageKey;
};

/** @override */
wrm.form.ValidatedForm.prototype.getFormSubService = function() {
  return this._formSubService;
};

/** @override */
wrm.form.ValidatedForm.prototype.getLocalizationService = function() {
  return this._l10nService;
};

/** @override */
wrm.form.ValidatedForm.prototype.getLabel = function() {
  return this._formLabel;
};

/** @override */
wrm.form.ValidatedForm.prototype.getProperties = function() {
  return this._propertyNames.map(function(propertyName) {
    return this.getProperty(propertyName);
  }, this);
};

/** @override */
wrm.form.ValidatedForm.prototype.getProperty = function(name) {
  var property = this._validatedProperties[name];
  if (!property) {
    property = new wrm.form.ValidatedFormProperty(this, name);
    this._validatedProperties[name] = property;
  }
  return property;
};

/** @override */
wrm.form.ValidatedForm.prototype.toString = function() {
  return this._formLabel;
};




//== wrm/form/ValidationSubService.js =========================================


/**
 * @interface
 * @extends wrm.SubService
 */
wrm.form.ValidationSubService = function() {
};

/**
 * @param {!wrm.nav.Event} event
 * @param {!wrm.nav.State} state
 * @return {!Promise.<boolean>}
 */
wrm.form.ValidationSubService.prototype.validateEvent = function(event, state) {
};

/**
 * @param {!wrm.nav.State} state
 * @return {!Promise.<boolean>}
 */
wrm.form.ValidationSubService.prototype.validateFormObject = function(state) {
};

/**
 * @param {string} propertyName
 * @param {!wrm.nav.State} state
 * @return {!Promise.<boolean>}
 */
wrm.form.ValidationSubService.prototype.validateFormProperty = function(propertyName, state) {
};




//== wrm/val/RuleContext.js ===================================================


/**
 * @constructor
 * @param {!wrm.nav.Input} input
 * @param {!wrm.val.Element} element
 */
wrm.val.RuleContext = function(input, element) {
  
  /** @private */
  this._input = input;
  
  /** @private */
  this._element = element;
};

/**
 * @return {!wrm.nav.Input}
 */
wrm.val.RuleContext.prototype.getInput = function() {
  return this._input;
};

/**
 * @return {!wrm.val.Element}
 */
wrm.val.RuleContext.prototype.getElement = function() {
  return this._element;
};

/** @override */
wrm.val.RuleContext.prototype.toString = function() {
  return String(this._element) + " " + JSON.stringify(this._input);
};




//== wrm/val/ObjectRuleContext.js =============================================



/**
 * @constructor
 * @extends wrm.val.RuleContext
 * @param {!wrm.nav.Input} input
 * @param {!wrm.val.Object} object
 */
wrm.val.ObjectRuleContext = function(input, object) {
  wrm.val.RuleContext.call(this, input, object);
};

extendConstructor(wrm.val.ObjectRuleContext, wrm.val.RuleContext);

/**
 * @override
 * @return {!wrm.val.Object}
 */
wrm.val.ObjectRuleContext.prototype.getElement = function() {
  return (wrm.val.ObjectRuleContext._super.getElement.call(this));
};




//== wrm/val/PropertyRuleContext.js ===========================================



/**
 * @constructor
 * @extends wrm.val.RuleContext
 * @param {!wrm.nav.Input} input
 * @param {!wrm.val.Property} property
 */
wrm.val.PropertyRuleContext = function(input, property) {
  wrm.val.RuleContext.call(this, input, property);
};

extendConstructor(wrm.val.PropertyRuleContext, wrm.val.RuleContext);

/**
 * @override
 * @return {!wrm.val.Property}
 */
wrm.val.PropertyRuleContext.prototype.getElement = function() {
  return (wrm.val.PropertyRuleContext._super.getElement.call(this));
};




//== wrm/form/DefaultValidationSubService.js ==================================



/**
 * @constructor
 * @extends wrm.core.AbstractSubService
 * @implements wrm.form.ValidationSubService
 * @param {!wrm.ViewComponentService} parent
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.form.DefaultValidationSubService = function(parent, descr, manager) {
  wrm.core.AbstractSubService.call(this, parent, descr, manager);
  
  /** @private */
  this._parentService = parent;
  
  /** @private */
  this._l10nService;
  
  /**
   * @private
   * @type {wrm.form.DefaultValidationSubService._VInfo}
   */
  this._formInfo;
  
  /**
   * @private
   * @type {!Object.<string,wrm.form.DefaultValidationSubService._VInfo>}
   */
  this._propertyInfos;
  
  /**
   * @private
   * @type {!Array.<string>}
   */
  this._propertyNames;
};

extendConstructor(wrm.form.DefaultValidationSubService, wrm.core.AbstractSubService);

/** @override */
wrm.form.DefaultValidationSubService.prototype.initialize = function(descr) {
  var thisService = this;
  var manager = this.getManager();
  return Promise.all([manager.getLocalizationService().then(function(l10nService) {
    thisService._l10nService = l10nService;
  })]).then(function() {
    
    /* Initialize form validation information */
    return thisService._createVInfo(descr, true).then(function(result) {
      thisService._formInfo = result;
    });
  }).then(function() {
    
    /* Initialize property validation information */
    return thisService._createVInfos(descr["properties"] || {}).then(function(result) {
      thisService._propertyInfos = result;
      thisService._propertyNames = Object.keys(result);
    });
  });
};

/**
 * @private
 * @typedef {{events:!Object.<string,boolean>, vruleInfos:!Array.<wrm.form.DefaultValidationSubService._VRuleInfo>}}
 */
wrm.form.DefaultValidationSubService._VInfo;

/**
 * @private
 * @param {!Object} descr
 * @return {!Promise.<!Object.<string,wrm.form.DefaultValidationSubService._VInfo>>}
 */
wrm.form.DefaultValidationSubService.prototype._createVInfos = function(descr) {
  var thisService = this;
  var vInfos = {};
  
  /* Create information for each property */
  var promise = Object.keys(descr).reduce(function(chain, propertyName) {
    return chain.then(function() {
      return thisService._createVInfo(descr[propertyName]);
    }).then(function(vInfo) {
      vInfos[propertyName] = vInfo;
    });
  }, Promise.resolve());
  
  return promise.then(function() {
    return vInfos;
  });
};

/**
 * @private
 * @param {!Object} descr
 * @param {boolean=} allowLiveEvents
 * @return {!Promise.<wrm.form.DefaultValidationSubService._VInfo>}
 */
wrm.form.DefaultValidationSubService.prototype._createVInfo = function(descr, allowLiveEvents) {
  var thisService = this;
  
  var events = this._createEventsConfiguration(descr["events"]);
  if (allowLiveEvents && Object.keys(events).length > 0) {
    events["_live"] = true;
  }
  
  /* Create information for each validation rule */
  var vruleInfos = [];
  var rulesDescrs = descr["rules"] || [];
  var promise = rulesDescrs.reduce(function(chain, ruleDescr) {
    return chain.then(function() {
      return thisService._createVRuleInfo(ruleDescr);
    }).then(function(vruleInfo) {
      vruleInfos.push(vruleInfo);
    });
  }, Promise.resolve());
  
  return promise.then(function() {
    return {events:events, vruleInfos:vruleInfos};
  });
};

/**
 * @private
 * @typedef {{events:!Object.<string,boolean>, service:!wrm.val.ValidationRuleService, inputNames:!Array.<string>,
 *          errorMessageKey:?string}}
 */
wrm.form.DefaultValidationSubService._VRuleInfo;

/**
 * @private
 * @param {!Object} descr
 * @return {!Promise.<wrm.form.DefaultValidationSubService._VRuleInfo>}
 */
wrm.form.DefaultValidationSubService.prototype._createVRuleInfo = function(descr) {
  var events = this._createEventsConfiguration(descr["events"]);
  var inputNames = descr["inputs"] ? descr["inputs"].split("|") : [];
  var errorMessageKey = descr["errorMessage"] || null;
  
  /* Instantiate the validation rule descriptor */
  var service = null;
  var vruleId = descr["id"];
  var vruleDescr = descr["descr"];
  var promise = this.getManager().instantiateService(vruleId, vruleDescr).then(function(instances) {
    service = instances.main;
  });
  
  return promise.then(function() {
    return {events:events, service:service, inputNames:inputNames, errorMessageKey:errorMessageKey};
  });
};

/**
 * @private
 * @param {Object|string} eventsStringOrObject
 * @return {!Object.<string,boolean>}
 */
wrm.form.DefaultValidationSubService.prototype._createEventsConfiguration = function(eventsStringOrObject) {
  if (typeof eventsStringOrObject === "string") {
    var events = {};
    if (eventsStringOrObject) {
      eventsStringOrObject.split("|").forEach(function(eventName) {
        events[eventName] = true;
      });
    }
    return events;
  } else {
    if (eventsStringOrObject) {
      return eventsStringOrObject;
    }
  }
  return {};
};

/*
 * Validation operations
 */

/** @override */
wrm.form.DefaultValidationSubService.prototype.validateEvent = function(event, state) {
  var thisService = this;
  var componentId = this._parentService.getId();
  var propertyNames = this._propertyNames;
  
  var eventName = event.getSpecifier();
  var formState = state.getComponentFormState(componentId);
  if (!eventName || !formState) {
    return Promise.resolve(true);
  }
  
  var actualEventName = (eventName);
  var actualFormState = (formState);
  
  var errorFlags = new wrm.form.DefaultValidationSubService._ErrorFlags;
  var promise = propertyNames.reduce(function(chain, propertyName) {
    
    /* Validate each property */
    return chain.then(function() {
      return thisService._validateFormProperty(actualEventName, actualFormState, propertyName, errorFlags, state);
    });
  }, Promise.resolve()).then(function() {
    
    /* Validate the form */
    return thisService._validateForm(actualEventName, actualFormState, errorFlags, state);
  });
  
  /* Consider "valid" if no errors are added anywhere */
  return promise.then(function() {
    thisService._applyViewChanges(state);
    return !errorFlags.any;
  });
};

/** @override */
wrm.form.DefaultValidationSubService.prototype.validateFormObject = function(state) {
  var thisService = this;
  var componentId = this._parentService.getId();
  var formState = state.getComponentFormState(componentId);
  if (!formState) {
    return Promise.resolve(true);
  }
  
  var actualFormState = (formState);
  
  /* Validate and consider "valid" if no errors are added to the form */
  var errorFlags = new wrm.form.DefaultValidationSubService._ErrorFlags;
  return this._validateForm("_live", actualFormState, errorFlags, state).then(function() {
    thisService._applyViewChanges(state);
    return !errorFlags.onForm;
  });
};

/** @override */
wrm.form.DefaultValidationSubService.prototype.validateFormProperty = function(propertyName, state) {
  var thisService = this;
  var componentId = this._parentService.getId();
  var formState = state.getComponentFormState(componentId);
  if (!formState) {
    return Promise.resolve(true);
  }
  
  var actualFormState = (formState);
  
  /* Validate and consider "valid" if no errors are added to the property */
  var errorFlags = new wrm.form.DefaultValidationSubService._ErrorFlags;
  return this._validateFormProperty("_live", actualFormState, propertyName, errorFlags, state).then(function() {
    thisService._applyViewChanges(state);
    return !errorFlags.onProperties[propertyName];
  });
};

/**
 * @private
 * @param {string} eventName
 * @param {!wrm.form.FormState} formState
 * @param {!wrm.form.DefaultValidationSubService._ErrorFlags} errorFlags
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.form.DefaultValidationSubService.prototype._validateForm = function(eventName, formState, errorFlags, state) {
  var thisService = this;
  var formInfo = this._formInfo;
  
  if (!formState.getPlatformValidity()) {
    errorFlags.addToForm(true);
    return Promise.resolve();
  }
  
  /* Collect the validation rules to apply for the event */
  var appliedVruleInfos = [];
  formInfo.vruleInfos.forEach(function(vruleInfo) {
    var apply = vruleInfo.events[eventName];
    if (apply === undefined) {
      apply = formInfo.events[eventName] || false;
    }
    if (apply) {
      appliedVruleInfos.push(vruleInfo);
    } else {
      thisService._clearPublishedErrors(vruleInfo.service.getId(), errorFlags, state);
    }
  });
  
  return this._applyValidationRules(appliedVruleInfos, formState, null, errorFlags, state);
};

/**
 * @private
 * @param {string} eventName
 * @param {!wrm.form.FormState} formState
 * @param {string} propertyName
 * @param {!wrm.form.DefaultValidationSubService._ErrorFlags} errorFlags
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.form.DefaultValidationSubService.prototype._validateFormProperty = function(eventName, formState, propertyName, errorFlags, state) {
  var thisService = this;
  var formInfo = this._formInfo;
  
  if (!formState.getPropertyPlatformValidity(propertyName)) {
    errorFlags.addToProperty(propertyName, true);
    return Promise.resolve();
  }
  
  var propertyInfo = this._propertyInfos[propertyName];
  if (!propertyInfo) {
    return Promise.resolve();
  }
  
  /* Collect the validation rules to apply for the event */
  var appliedVruleInfos = [];
  propertyInfo.vruleInfos.forEach(function(vruleInfo) {
    var apply = vruleInfo.events[eventName];
    if (apply === undefined) {
      apply = propertyInfo.events[eventName];
    }
    if (apply === undefined) {
      apply = formInfo.events[eventName] || false;
    }
    if (apply) {
      appliedVruleInfos.push(vruleInfo);
    } else {
      thisService._clearPublishedErrors(vruleInfo.service.getId(), errorFlags, state);
    }
  });
  
  return this._applyValidationRules(appliedVruleInfos, formState, propertyName, errorFlags, state);
};

/*
 * Validation rule application
 */

/**
 * @private
 * @param {!Array.<wrm.form.DefaultValidationSubService._VRuleInfo>} vruleInfos
 * @param {!wrm.form.FormState} formState
 * @param {?string} propertyName
 * @param {!wrm.form.DefaultValidationSubService._ErrorFlags} errorFlags
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.form.DefaultValidationSubService.prototype._applyValidationRules = function(vruleInfos, formState, propertyName, errorFlags, state) {
  var thisService = this;
  
  /* Apply each validation rule, honoring the policy after each one */
  var stopped = false;
  return vruleInfos.reduce(function(chain, vruleInfo) {
    return chain.then(function() {
      if (stopped) {
        thisService._clearPublishedErrors(vruleInfo.service.getId(), errorFlags, state);
        return;
      }
      return thisService._applyValidationRule(vruleInfo, formState, propertyName, errorFlags, state).then(function(policy) {
        if (policy === wrm.val.RulePolicy.STOP) {
          stopped = true;
        }
      });
    });
  }, Promise.resolve());
};

/**
 * @private
 * @param {wrm.form.DefaultValidationSubService._VRuleInfo} vruleInfo
 * @param {!wrm.form.FormState} formState
 * @param {?string} propertyName
 * @param {!wrm.form.DefaultValidationSubService._ErrorFlags} errorFlags
 * @param {!wrm.nav.State} state
 * @return {!Promise.<wrm.val.RulePolicy>}
 */
wrm.form.DefaultValidationSubService.prototype._applyValidationRule = function(vruleInfo, formState, propertyName, errorFlags, state) {
  var thisService = this;
  var propertyNames = this._propertyNames;
  var l10nService = this._l10nService;
  var componentService = this._parentService;
  var manager = this.getManager();
  
  /** @type {!wrm.form.ValidatedForm} */
  var validatedForm = (undefined);
  
  /* Create the validated form object */
  var promise = Promise.resolve().then(function() {
    return manager.getFormSubService(componentService);
  }).then(function(formSubService) {
    validatedForm = new wrm.form.ValidatedForm(propertyNames, formState, vruleInfo.errorMessageKey, formSubService, l10nService);
  });
  
  /* Invoke the validation rule in the correct mode (form or property) */
  promise = promise.then(function() {
    var componentInput = state.getComponentInput(componentService.getId());
    if (propertyName) {
      return thisService._invokeFormPropertyValidationRule(vruleInfo, componentInput, validatedForm, propertyName);
    } else {
      return thisService._invokeFormValidationRule(vruleInfo, componentInput, validatedForm);
    }
  });
  
  /* Replace the errors on the published form state */
  var rulePolicy;
  return promise.then(function(result) {
    rulePolicy = result;
    return thisService._republishErrors(vruleInfo.service.getId(), validatedForm.getErrorsMap(), errorFlags, state);
  }).then(function() {
    return rulePolicy;
  });
};

/**
 * @private
 * @param {wrm.form.DefaultValidationSubService._VRuleInfo} vruleInfo
 * @param {!wrm.nav.Input} componentInput
 * @param {!wrm.form.ValidatedForm} validatedForm
 * @return {!Promise.<wrm.val.RulePolicy>}
 */
wrm.form.DefaultValidationSubService.prototype._invokeFormValidationRule = function(vruleInfo, componentInput, validatedForm) {
  var input = new wrm.form.DefaultValidationSubService._RuleInput(vruleInfo.inputNames, componentInput);
  var context = new wrm.val.ObjectRuleContext(input, validatedForm);
  validatedForm.clearErrors();
  return this._invokeValidationRule(vruleInfo.service, context);
};

/**
 * @private
 * @param {wrm.form.DefaultValidationSubService._VRuleInfo} vruleInfo
 * @param {!wrm.nav.Input} componentInput
 * @param {!wrm.form.ValidatedForm} validatedForm
 * @param {string} propertyName
 * @return {!Promise.<wrm.val.RulePolicy>}
 */
wrm.form.DefaultValidationSubService.prototype._invokeFormPropertyValidationRule = function(vruleInfo, componentInput, validatedForm, propertyName) {
  var input = new wrm.form.DefaultValidationSubService._RuleInput(vruleInfo.inputNames, componentInput);
  var context = new wrm.val.PropertyRuleContext(input, validatedForm.getProperty(propertyName));
  validatedForm.clearErrors();
  return this._invokeValidationRule(vruleInfo.service, context);
};

/**
 * @private
 * @constructor
 * @implements wrm.nav.Input
 * @param {!Array.<string>} inputNames
 * @param {!wrm.nav.Input} componentInput
 */
wrm.form.DefaultValidationSubService._RuleInput = function(inputNames, componentInput) {
  
  /* Copy the listed inputs on this object */
  inputNames.forEach(function(name) {
    var value = componentInput[name];
    if (value !== undefined) {
      this[name] = value;
    }
  }, this);
};

/**
 * @private
 * @param {!wrm.val.ValidationRuleService} ruleService
 * @param {!wrm.val.RuleContext} ruleContext
 * @return {!Promise.<wrm.val.RulePolicy>}
 */
wrm.form.DefaultValidationSubService.prototype._invokeValidationRule = function(ruleService, ruleContext) {
  var log = this.getLog();
  return Promise.resolve().then(function() {
    log.debug("Validating with", ruleService, "-", ruleContext);
    return ruleService.validate(ruleContext);
  }).then(function(policy) {
    return policy || wrm.val.RulePolicy.CONTINUE;
  }, function(e) {
    log.error("Validation internal error", e);
    throw e;
  });
};

/*
 * Form state publishing
 */

/**
 * @private
 * @constructor
 */
wrm.form.DefaultValidationSubService._ErrorFlags = function() {
  
  /** @type {boolean} */
  this.any = false;
  
  /** @type {boolean} */
  this.onForm = false;
  
  /** @type {!Object.<string,boolean>} */
  this.onProperties = {};
};

/**
 * @param {boolean} errorsAdded
 */
wrm.form.DefaultValidationSubService._ErrorFlags.prototype.addToForm = function(errorsAdded) {
  if (errorsAdded) {
    this.any = true;
    this.onForm = true;
  }
};

/**
 * @param {string} propertyName
 * @param {boolean} errorsAdded
 */
wrm.form.DefaultValidationSubService._ErrorFlags.prototype.addToProperty = function(propertyName, errorsAdded) {
  if (errorsAdded) {
    this.any = true;
    this.onProperties[propertyName] = true;
  }
};

/**
 * @private
 * @param {string} vruleId
 * @param {!Object.<string,!Array.<string>>} errorsMap
 * @param {!wrm.form.DefaultValidationSubService._ErrorFlags} errorFlags
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.form.DefaultValidationSubService.prototype._republishErrors = function(vruleId, errorsMap, errorFlags, state) {
  var propertyNames = this._propertyNames;
  var manager = this.getManager();
  var componentService = this._parentService;
  
  return manager.hasFormSubService(componentService).then(function(available) {
    if (available) {
      return manager.getFormSubService(componentService);
    }
    return null;
  }).then(function(formSubService) {
    if (!formSubService) {
      return;
    }
    
    /* Retrieve the published form state */
    var pubFormState = formSubService.retrievePublishedFormState(state);
    if (!pubFormState) {
      return;
    }
    
    /* Republish error messages of the form and of every property */
    errorFlags.addToForm(pubFormState["republishErrors"](vruleId, errorsMap[""]));
    propertyNames.forEach(function(propertyName) {
      var propertyErrorsAdded = pubFormState[propertyName]["republishErrors"](vruleId, errorsMap[propertyName]);
      errorFlags.addToProperty(propertyName, propertyErrorsAdded);
    });
  });
};

/**
 * @private
 * @param {string} vruleId
 * @param {!wrm.form.DefaultValidationSubService._ErrorFlags} errorFlags
 * @param {!wrm.nav.State} state
 * @return {!Promise}
 */
wrm.form.DefaultValidationSubService.prototype._clearPublishedErrors = function(vruleId, errorFlags, state) {
  return this._republishErrors(vruleId, {}, errorFlags, state);
};

/**
 * @param {!wrm.nav.State} state
 */
wrm.form.DefaultValidationSubService.prototype._applyViewChanges = function(state) {
  var componentId = this._parentService.getId();
  var view = state.getComponentView(componentId);
  if (view) {
    view.applyChanges();
  }
};




//== wrm/form/FormPropertyTracker.js ==========================================



/**
 * @internal
 * @constructor
 * @param {?wrm.form.FormState} formState
 * @param {?wrm.form.FormSubService} formSubService
 */
wrm.form.FormPropertyTracker = function(formState, formSubService) {
  
  /** @private */
  this._formState = formState;
  
  /** @private */
  this._formSubService = formSubService;
};

/**
 * @internal
 * @param {!Object} view
 * @return {!Object<string,*>}
 */
wrm.form.FormPropertyTracker.prototype.updatesStarted = function(view) {
  var formState = this._formState;
  var formSubService = this._formSubService;
  if (!formState || !formSubService) {
    return {};
  }
  
  /* Extract all current property values */
  var values = {};
  formSubService.getPropertyNames().forEach(function(propertyName) {
    var viewReference = formSubService.getPropertyViewReference(propertyName);
    var value = wrm.util.obj.lookupSafe(viewReference, view);
    values[propertyName] = value;
  });
  return values;
};

/**
 * @internal
 * @param {!Object} view
 * @param {!Object<string,*>} startValues
 * @return {undefined}
 */
wrm.form.FormPropertyTracker.prototype.updatesFinished = function(view, startValues) {
  var formState = this._formState;
  var formSubService = this._formSubService;
  if (!formState || !formSubService) {
    return;
  }
  
  /* Find changed properties */
  formSubService.getPropertyNames().forEach(function(propertyName) {
    var viewReference = formSubService.getPropertyViewReference(propertyName);
    var finishValue = wrm.util.obj.lookupSafe(viewReference, view);
    var startValue = startValues[propertyName];
    if (wrm.data.equal(startValue, finishValue)) {
      return;
    }
    
    /* Clear "dirty" state of changed property */
    formState.clearPropertyDirtiness(propertyName);
  });
};




//== wrm/form/FormState.js ====================================================


/**
 * @interface
 */
wrm.form.FormState = function() {
};

/**
 * @param {boolean} validity
 */
wrm.form.FormState.prototype.setValidity = ABSTRACT_METHOD;

/**
 * @return {undefined}
 */
wrm.form.FormState.prototype.publishValidViewValues = ABSTRACT_METHOD;

/**
 * @param {string} propertyName
 * @return {?{value:*, dirty:boolean, valid:boolean, invalid:boolean}}
 */
wrm.form.FormState.prototype.getProperty = ABSTRACT_METHOD;

/**
 * @param {string} propertyName
 * @param {boolean} validity
 */
wrm.form.FormState.prototype.setPropertyValidity = ABSTRACT_METHOD;

/**
 * @return {boolean}
 */
wrm.form.FormState.prototype.getPlatformValidity = ABSTRACT_METHOD;

/**
 * @param {string} propertyName
 * @return {boolean}
 */
wrm.form.FormState.prototype.getPropertyPlatformValidity = ABSTRACT_METHOD;

/**
 * @param {string} propertyName
 * @return {Array<string>}
 */
wrm.form.FormState.prototype.getPropertyPlatformErrors = ABSTRACT_METHOD;

/**
 * @param {string} propertyName
 */
wrm.form.FormState.prototype.clearPropertyDirtiness = ABSTRACT_METHOD;




//== wrm/val/Property.js ======================================================


/**
 * @interface
 * @extends wrm.val.Element
 */
wrm.val.Property = function() {
};

/**
 * @return {string}
 */
wrm.val.Property.prototype.getLabel = ABSTRACT_METHOD;

/**
 * @return {*}
 */
wrm.val.Property.prototype.getValue = ABSTRACT_METHOD;

/**
 * @return {!wrm.val.Object}
 */
wrm.val.Property.prototype.getObject = ABSTRACT_METHOD;




//== wrm/form/ValidatedFormProperty.js ========================================



/**
 * @package
 * @constructor
 * @extends wrm.form.AbstractValidatedElement
 * @implements wrm.val.Property
 * @param {!wrm.form.ValidatedForm} validatedForm
 * @param {string} propertyName
 */
wrm.form.ValidatedFormProperty = function(validatedForm, propertyName) {
  wrm.form.AbstractValidatedElement.call(this);
  
  /** @private */
  this._validatedForm = validatedForm;
  
  /** @private */
  this._propertyName = propertyName;
  
  /* Retrieve the state of the property (which must exist) */
  var propertyState = validatedForm.getFormState().getProperty(propertyName);
  if (!propertyState) {
    throw new Error("Form property '" + propertyName + "' not found");
  }
  
  /** @private */
  this._propertyState = propertyState;
  
  /** @private */
  this._propertyLabel = validatedForm.getFormSubService().getPropertyLabel(propertyName);
};

extendConstructor(wrm.form.ValidatedFormProperty, wrm.form.AbstractValidatedElement);

/** @override */
wrm.form.ValidatedFormProperty.prototype.augmentErrorMessageVariables = function(variables) {
  variables = wrm.form.ValidatedFormProperty._super.augmentErrorMessageVariables.call(this, variables);
  return angular.extend({}, {"propertyName":this._propertyLabel, "propertyValue":this._propertyState.value}, variables);
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.recordErrorMessage = function(message) {
  var errorsMap = this._validatedForm.getErrorsMap();
  var list = errorsMap[this._propertyName];
  if (!list) {
    errorsMap[this._propertyName] = list = [];
  }
  list.push(message);
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.getErrorMessageKey = function() {
  return this._validatedForm.getErrorMessageKey();
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.getFormSubService = function() {
  return this._validatedForm.getFormSubService();
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.getLocalizationService = function() {
  return this._validatedForm.getLocalizationService();
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.getLabel = function() {
  return this._propertyLabel;
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.getValue = function() {
  return this._propertyState.value;
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.getObject = function() {
  return this._validatedForm;
};

/** @override */
wrm.form.ValidatedFormProperty.prototype.toString = function() {
  return String(this._validatedForm) + "/" + this._propertyLabel + " (" + this._propertyName + ")";
};




//== wrm/l10n/LocaleInfo.js ===================================================


/**
 * @interface
 */
wrm.l10n.LocaleInfo = function() {
};

/**
 * @param {!wrm.l10n.NameWidth} width
 * @return {!Array<string>}
 */
wrm.l10n.LocaleInfo.prototype.getMonthNames = ABSTRACT_METHOD;

/**
 * @param {!wrm.l10n.NameWidth} width
 * @return {!Array<string>}
 */
wrm.l10n.LocaleInfo.prototype.getDayNames = ABSTRACT_METHOD;

/**
 * @return {number}
 */
wrm.l10n.LocaleInfo.prototype.getFirstDayOfWeek = ABSTRACT_METHOD;




//== wrm/l10n/NameWidth.js ====================================================


/**
 * @enum {string}
 */
wrm.l10n.NameWidth = {NARROW:"narrow", ABBREVIATED:"abbreviated", SHORT:"short", WIDE:"wide"};




//== wrm/Log.js ===============================================================


/**
 * @interface
 */
wrm.Log = function() {
};

/**
 * @param {...*} var_args
 */
wrm.Log.prototype.error = ABSTRACT_METHOD;

/**
 * @param {...*} var_args
 */
wrm.Log.prototype.warn = ABSTRACT_METHOD;

/**
 * @param {...*} var_args
 */
wrm.Log.prototype.info = ABSTRACT_METHOD;

/**
 * @param {...*} var_args
 */
wrm.Log.prototype.debug = ABSTRACT_METHOD;

/**
 * @return {boolean}
 */
wrm.Log.prototype.isDebugEnabled = ABSTRACT_METHOD;




//== wrm/nav/LoginDialog.js ===================================================



/**
 * @constructor
 * @template R
 * @extends wrm.nav.Dialog<R>
 * @param {string} message
 * @param {string=} defaultUsername
 * @param {boolean=} usernameChangeForbidden
 * @param {!Array<{label:string, value:R, default:(boolean|undefined)}>=} choices
 */
wrm.nav.LoginDialog = function(message, defaultUsername, usernameChangeForbidden, choices) {
  wrm.nav.Dialog.call(this, message, wrm.nav.Dialog.Flavor.POSITIVE, choices);
  
  /** @private */
  this._defaultUsername = defaultUsername || null;
  
  /** @private */
  this._usernameChangeForbidden = usernameChangeForbidden || false;
};

extendConstructor(wrm.nav.LoginDialog, wrm.nav.Dialog);

/**
 * @return {?string}
 */
wrm.nav.LoginDialog.prototype.getDefualtUsername = function() {
  return this._defaultUsername;
};

/**
 * @return {boolean}
 */
wrm.nav.LoginDialog.prototype.isUsernameChangeForbidden = function() {
  return this._usernameChangeForbidden;
};

/** @override */
wrm.nav.LoginDialog.prototype.toString = function() {
  return 'LoginDialog:"' + this.getMessage() + '"';
};




//== wrm/nav/MultipleRoute.js =================================================



/**
 * @constructor
 * @class
 * @implements wrm.nav.Route
 * @param {!Array<!wrm.nav.Route>} routes
 */
wrm.nav.MultipleRoute = function(routes) {
  
  /** @private */
  this._routes = routes.slice();
};

/** @override */
wrm.nav.MultipleRoute.prototype.isStationary = function() {
  for (var i = 0;i < this._routes.length;i++) {
    if (!this._routes[i].isStationary()) {
      return false;
    }
  }
  return true;
};

/**
 * @return {!Array<!wrm.nav.Route>}
 */
wrm.nav.MultipleRoute.prototype.getRoutes = function() {
  return this._routes;
};

/** @override */
wrm.nav.MultipleRoute.prototype.toString = function() {
  return "[" + this._routes.join(", ") + "]";
};




//== wrm/nav/Reuse.js =========================================================


/**
 * @enum {string}
 */
wrm.nav.Reuse = {NONE:"none", PARTIAL:"partial", FULL:"full"};




//== wrm/nav/ServiceRoute.js ==================================================



/**
 * @constructor
 * @class
 * @implements wrm.nav.Route
 * @param {string=} serviceId
 * @param {string=} gate
 */
wrm.nav.ServiceRoute = function(serviceId, gate) {
  if (serviceId === null || gate === null) {
    throw new Error("Invalid service or gate");
  }
  
  /**
   * @private
   * @type {?string}
   */
  this._serviceId = serviceId || null;
  
  /**
   * @private
   * @type {?string}
   */
  this._gate = gate || serviceId || null;
};

/** @override */
wrm.nav.ServiceRoute.prototype.isStationary = function() {
  return !this._serviceId;
};

/**
 * @return {?string}
 */
wrm.nav.ServiceRoute.prototype.getServiceId = function() {
  return this._serviceId;
};

/**
 * @return {?string}
 */
wrm.nav.ServiceRoute.prototype.getGate = function() {
  return this._gate;
};

/** @override */
wrm.nav.ServiceRoute.prototype.toString = function() {
  var s = [];
  if (this._serviceId || this._gate) {
    s.push(this._serviceId || "");
    if (this._gate) {
      s.push(":", this._gate);
    }
  } else {
    s.push("\x3cstationary\x3e");
  }
  return s.join("");
};




//== wrm/nav/VirtualRoute.js ==================================================



/**
 * @constructor
 * @class
 * @implements wrm.nav.Route
 * @param {!wrm.nav.VirtualRoute.Type} type
 */
wrm.nav.VirtualRoute = function(type) {
  
  /** @private */
  this._type = type;
};

/** @override */
wrm.nav.VirtualRoute.prototype.isStationary = function() {
  return false;
};

/**
 * @return {!wrm.nav.VirtualRoute.Type}
 */
wrm.nav.VirtualRoute.prototype.getType = function() {
  return this._type;
};

/** @override */
wrm.nav.VirtualRoute.prototype.toString = function() {
  return "\x3c" + this._type + "\x3e";
};

/*
 * Types
 */

/**
 * @enum {string}
 */
wrm.nav.VirtualRoute.Type = {BACK:"back", EXIT:"exit"};




//== wrm/Platform.js ==========================================================


/**
 * @interface
 */
wrm.Platform = function() {
};

/**
 * @return {string}
 */
wrm.Platform.prototype.getDeviceId = ABSTRACT_METHOD;

/**
 * @return {string}
 */
wrm.Platform.prototype.getDeviceModel = ABSTRACT_METHOD;

/**
 * @return {string}
 */
wrm.Platform.prototype.getDevicePlatform = ABSTRACT_METHOD;

/**
 * @return {string}
 */
wrm.Platform.prototype.getDevicePlatformVersion = ABSTRACT_METHOD;

/**
 * @return {string}
 */
wrm.Platform.prototype.getWebEngineType = ABSTRACT_METHOD;

/**
 * @param {string} category
 * @param {...*} var_args
 * @return {!wrm.Log}
 */
wrm.Platform.prototype.createLog = ABSTRACT_METHOD;

/**
 * @param {string} key
 * @return {!wrm.data.Dictionary}
 */
wrm.Platform.prototype.retrieveDictionary = ABSTRACT_METHOD;

/**
 * @param {string} path
 * @param {boolean=} raw
 * @return {!Promise<?*>}
 */
wrm.Platform.prototype.readAppFile = ABSTRACT_METHOD;

/**
 * @param {!angular.$http.Config} config
 * @return {!Promise<!angular.$http.Response>}
 */
wrm.Platform.prototype.makeHttpRequest = ABSTRACT_METHOD;

/**
 * @return {!Promise<string>|!Promise<null>}
 */
wrm.Platform.prototype.getNotificationDeviceId = ABSTRACT_METHOD;

/**
 * @return {!Promise<boolean>}
 */
wrm.Platform.prototype.hasPendingNotifications = ABSTRACT_METHOD;

/**
 * @param {function(?string)} listener
 */
wrm.Platform.prototype.addNotificationStatusListener = ABSTRACT_METHOD;

/**
 * @param {string} name
 * @param {function({title:string, message:string, parameters:!Object<string,string>})} handler
 * @return {!Promise}
 */
wrm.Platform.prototype.subscribeNotifications = ABSTRACT_METHOD;

/**
 * @return {string}
 */
wrm.Platform.prototype.getCurrentLocale = ABSTRACT_METHOD;

/**
 * @return {!wrm.l10n.LocaleInfo}
 */
wrm.Platform.prototype.getCurrentLocaleInfo = ABSTRACT_METHOD;

/**
 * @param {?string} locale
 * @return {!Promise<boolean>}
 */
wrm.Platform.prototype.overrideLocale = ABSTRACT_METHOD;




//== wrm/util/AsyncWorker.js ==================================================


/**
 * @constructor
 * @template T
 * @param {function(T)} workerFunction
 * @param {{maxBatchDuration:(number|undefined), batchInterval:(number|undefined)}=} options
 */
wrm.util.AsyncWorker = function(workerFunction, options) {
  
  /** @private */
  this._workerFunction = workerFunction;
  
  /**
   * @private
   * @type {number}
   */
  this._maxBatchDuration = options && options.maxBatchDuration || 100;
  
  /**
   * @private
   * @type {number}
   */
  this._batchInterval = options && options.batchInterval || 30;
  
  /**
   * @private
   * @type {!Array.<T>}
   */
  this._queue = [];
  
  /** @private */
  this._working = false;
};

/**
 * @param {T} item
 */
wrm.util.AsyncWorker.prototype.post = function(item) {
  this._queue.push(item);
  
  /* Start working */
  if (!this._working) {
    setTimeout(this._workBatch.bind(this), this._batchInterval);
    this._working = true;
  }
};

/**
 * @private
 * @return {undefined}
 */
wrm.util.AsyncWorker.prototype._workBatch = function() {
  var queue = this._queue;
  var startTime = (new Date).valueOf();
  var maxTime = this._maxBatchDuration;
  
  /* Work a limited number of items */
  do {
    var item = queue.shift();
    try {
      this._workerFunction(item);
    } catch (e) {
    }
  } while (queue.length > 0 && (new Date).valueOf() - startTime < maxTime);
  
  /* Schedule again if queue is not empty */
  if (queue.length > 0) {
    setTimeout(this._workBatch.bind(this), this._batchInterval);
  } else {
    this._working = false;
  }
};




//== wrm/util/Deferred.js =====================================================


/**
 * @constructor
 * @template T
 * @extends Promise<T>
 */
wrm.util.Deferred = function() {
  var thisDeferred = this;
  
  /**
   * @private
   * @type {function(T)}
   */
  this._resolve;
  
  /**
   * @private
   * @type {function(!Error)}
   */
  this._reject;
  
  /**
   * @private
   * @type {!Promise<T>}
   */
  this._promise = new Promise(function(resolve, reject) {
    thisDeferred._resolve = resolve;
    thisDeferred._reject = reject;
  });
};

/** @override */
wrm.util.Deferred.prototype.then = function(onFulfilled, onRejected) {
  return this._promise.then(onFulfilled, onRejected);
};

/** @override */
wrm.util.Deferred.prototype["catch"] = function(onRejected) {
  return this._promise["catch"](onRejected);
};

/** @override */
wrm.util.Deferred.prototype.toString = function() {
  return this._promise.toString();
};




//== wrm/util/ListenerList.js =================================================


/**
 * @constructor
 * @template T
 */
wrm.util.ListenerList = function() {
  
  /**
   * @private
   * @type {!Array<function(T)>}
   */
  this._listeners = [];
};

/**
 * @param {function(T)} listener
 */
wrm.util.ListenerList.prototype.add = function(listener) {
  if (!listener) {
    return;
  }
  for (var i = 0;i < this._listeners.length;i++) {
    if (this._listeners[i] === listener) {
      return;
    }
  }
  this._listeners.push(listener);
};

/**
 * @param {function(T)} listener
 */
wrm.util.ListenerList.prototype.remove = function(listener) {
  if (!listener) {
    return;
  }
  for (var i = 0;i < this._listeners.length;i++) {
    if (this._listeners[i] === listener) {
      this._listeners.splice(i, 1);
      return;
    }
  }
};

/**
 * @param {T} value
 */
wrm.util.ListenerList.prototype.notifyAll = function(value) {
  var errors = null;
  
  /* Call all listeners, keeping track of errors */
  for (var i = 0;i < this._listeners.length;i++) {
    try {
      this._listeners[i](value);
    } catch (e) {
      if (errors) {
        errors.push(e);
      } else {
        errors = [e];
      }
    }
  }
  
  /* Report all errors as a single one */
  if (errors) {
    return new Error("Error thrown by listeners:\n", errors.map(function(e) {
      return "---\n" + e.stack;
    }).join("\n"));
  }
};




//== wrm/val/ValidationRuleService.js =========================================


/**
 * @interface
 * @template C
 * @extends wrm.Service
 */
wrm.val.ValidationRuleService = function() {
};

/**
 * @param {!C} context
 * @return {undefined|!wrm.val.RulePolicy|!Promise.<undefined|!wrm.val.RulePolicy>}
 */
wrm.val.ValidationRuleService.prototype.validate = ABSTRACT_METHOD;




//== wrm/val/AbstractValidationRuleService.js =================================



/**
 * @constructor
 * @extends wrm.core.AbstractService
 * @implements wrm.val.ValidationRuleService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.val.AbstractValidationRuleService = function(id, descr, manager) {
  wrm.core.AbstractService.call(this, id, descr, manager);
  
  /**
   * @private
   * @type {string}
   */
  this._messageKeyPrefix = descr["messageKeyPrefix"] || "";
};

extendConstructor(wrm.val.AbstractValidationRuleService, wrm.core.AbstractService);

/** @override */
wrm.val.AbstractValidationRuleService.prototype.validate = ABSTRACT_METHOD;

/**
 * @protected
 * @const
 * @param {string} messageKey
 * @return {string}
 */
wrm.val.AbstractValidationRuleService.prototype.getMessageKey = function(messageKey) {
  return this._messageKeyPrefix + messageKey;
};




//== wrm/val/ObjectValidationRuleService.js ===================================


/**
 * @interface
 * @extends wrm.val.ValidationRuleService.<wrm.val.ObjectRuleContext>
 */
wrm.val.ObjectValidationRuleService = function() {
};




//== wrm/val/AbstractObjectValidationRuleService.js ===========================



/**
 * @constructor
 * @extends wrm.val.AbstractValidationRuleService
 * @implements wrm.val.ObjectValidationRuleService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.val.AbstractObjectValidationRuleService = function(id, descr, manager) {
  wrm.val.AbstractValidationRuleService.call(this, id, descr, manager);
};

extendConstructor(wrm.val.AbstractObjectValidationRuleService, wrm.val.AbstractValidationRuleService);




//== wrm/val/PropertyValidationRuleService.js =================================


/**
 * @interface
 * @extends wrm.val.ValidationRuleService.<wrm.val.PropertyRuleContext>
 */
wrm.val.PropertyValidationRuleService = function() {
};




//== wrm/val/AbstractPropertyValidationRuleService.js =========================



/**
 * @constructor
 * @extends wrm.val.AbstractValidationRuleService
 * @implements wrm.val.PropertyValidationRuleService
 * @param {string} id
 * @param {!Object} descr
 * @param {!wrm.core.Manager} manager
 */
wrm.val.AbstractPropertyValidationRuleService = function(id, descr, manager) {
  wrm.val.AbstractValidationRuleService.call(this, id, descr, manager);
};

extendConstructor(wrm.val.AbstractPropertyValidationRuleService, wrm.val.AbstractValidationRuleService);




//== wrm/val/RulePolicy.js ====================================================


/**
 * @enum {string}
 */
wrm.val.RulePolicy = {CONTINUE:"continue", STOP:"stop"};


exportSymbol("wrm", wrm);
})();})(this);